"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/eth-block-tracker";
exports.ids = ["vendor-chunks/eth-block-tracker"];
exports.modules = {

/***/ "(ssr)/./node_modules/eth-block-tracker/dist/BaseBlockTracker.js":
/*!*****************************************************************!*\
  !*** ./node_modules/eth-block-tracker/dist/BaseBlockTracker.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BaseBlockTracker = void 0;\nconst safe_event_emitter_1 = __importDefault(__webpack_require__(/*! @metamask/safe-event-emitter */ \"(ssr)/./node_modules/@metamask/safe-event-emitter/dist/cjs/index.js\"));\nconst sec = 1000;\nconst calculateSum = (accumulator, currentValue)=>accumulator + currentValue;\nconst blockTrackerEvents = [\n    \"sync\",\n    \"latest\"\n];\nclass BaseBlockTracker extends safe_event_emitter_1.default {\n    constructor(opts){\n        super();\n        // config\n        this._blockResetDuration = opts.blockResetDuration || 20 * sec;\n        this._usePastBlocks = opts.usePastBlocks || false;\n        // state\n        this._currentBlock = null;\n        this._isRunning = false;\n        // bind functions for internal use\n        this._onNewListener = this._onNewListener.bind(this);\n        this._onRemoveListener = this._onRemoveListener.bind(this);\n        this._resetCurrentBlock = this._resetCurrentBlock.bind(this);\n        // listen for handler changes\n        this._setupInternalEvents();\n    }\n    async destroy() {\n        this._cancelBlockResetTimeout();\n        await this._maybeEnd();\n        super.removeAllListeners();\n    }\n    isRunning() {\n        return this._isRunning;\n    }\n    getCurrentBlock() {\n        return this._currentBlock;\n    }\n    async getLatestBlock() {\n        // return if available\n        if (this._currentBlock) {\n            return this._currentBlock;\n        }\n        // wait for a new latest block\n        const latestBlock = await new Promise((resolve)=>this.once(\"latest\", resolve));\n        // return newly set current block\n        return latestBlock;\n    }\n    // dont allow module consumer to remove our internal event listeners\n    removeAllListeners(eventName) {\n        // perform default behavior, preserve fn arity\n        if (eventName) {\n            super.removeAllListeners(eventName);\n        } else {\n            super.removeAllListeners();\n        }\n        // re-add internal events\n        this._setupInternalEvents();\n        // trigger stop check just in case\n        this._onRemoveListener();\n        return this;\n    }\n    _setupInternalEvents() {\n        // first remove listeners for idempotence\n        this.removeListener(\"newListener\", this._onNewListener);\n        this.removeListener(\"removeListener\", this._onRemoveListener);\n        // then add them\n        this.on(\"newListener\", this._onNewListener);\n        this.on(\"removeListener\", this._onRemoveListener);\n    }\n    _onNewListener(eventName) {\n        // `newListener` is called *before* the listener is added\n        if (blockTrackerEvents.includes(eventName)) {\n            this._maybeStart();\n        }\n    }\n    _onRemoveListener() {\n        // `removeListener` is called *after* the listener is removed\n        if (this._getBlockTrackerEventCount() > 0) {\n            return;\n        }\n        this._maybeEnd();\n    }\n    async _maybeStart() {\n        if (this._isRunning) {\n            return;\n        }\n        this._isRunning = true;\n        // cancel setting latest block to stale\n        this._cancelBlockResetTimeout();\n        await this._start();\n        this.emit(\"_started\");\n    }\n    async _maybeEnd() {\n        if (!this._isRunning) {\n            return;\n        }\n        this._isRunning = false;\n        this._setupBlockResetTimeout();\n        await this._end();\n        this.emit(\"_ended\");\n    }\n    _getBlockTrackerEventCount() {\n        return blockTrackerEvents.map((eventName)=>this.listenerCount(eventName)).reduce(calculateSum);\n    }\n    _shouldUseNewBlock(newBlock) {\n        const currentBlock = this._currentBlock;\n        if (!currentBlock) {\n            return true;\n        }\n        const newBlockInt = hexToInt(newBlock);\n        const currentBlockInt = hexToInt(currentBlock);\n        return this._usePastBlocks && newBlockInt < currentBlockInt || newBlockInt > currentBlockInt;\n    }\n    _newPotentialLatest(newBlock) {\n        if (!this._shouldUseNewBlock(newBlock)) {\n            return;\n        }\n        this._setCurrentBlock(newBlock);\n    }\n    _setCurrentBlock(newBlock) {\n        const oldBlock = this._currentBlock;\n        this._currentBlock = newBlock;\n        this.emit(\"latest\", newBlock);\n        this.emit(\"sync\", {\n            oldBlock,\n            newBlock\n        });\n    }\n    _setupBlockResetTimeout() {\n        // clear any existing timeout\n        this._cancelBlockResetTimeout();\n        // clear latest block when stale\n        this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration);\n        // nodejs - dont hold process open\n        if (this._blockResetTimeout.unref) {\n            this._blockResetTimeout.unref();\n        }\n    }\n    _cancelBlockResetTimeout() {\n        if (this._blockResetTimeout) {\n            clearTimeout(this._blockResetTimeout);\n        }\n    }\n    _resetCurrentBlock() {\n        this._currentBlock = null;\n    }\n}\nexports.BaseBlockTracker = BaseBlockTracker;\n/**\n * Converts a number represented as a string in hexadecimal format into a native\n * number.\n *\n * @param hexInt - The hex string.\n * @returns The number.\n */ function hexToInt(hexInt) {\n    return Number.parseInt(hexInt, 16);\n} //# sourceMappingURL=BaseBlockTracker.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvZGlzdC9CYXNlQmxvY2tUcmFja2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLElBQUssSUFBSSxJQUFJLENBQUNBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBRSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsd0JBQXdCLEdBQUcsS0FBSztBQUNoQyxNQUFNRyx1QkFBdUJSLGdCQUFnQlMsbUJBQU9BLENBQUMseUdBQThCO0FBQ25GLE1BQU1DLE1BQU07QUFDWixNQUFNQyxlQUFlLENBQUNDLGFBQWFDLGVBQWlCRCxjQUFjQztBQUNsRSxNQUFNQyxxQkFBcUI7SUFBQztJQUFRO0NBQVM7QUFDN0MsTUFBTVAseUJBQXlCQyxxQkFBcUJPLE9BQU87SUFDdkRDLFlBQVlDLElBQUksQ0FBRTtRQUNkLEtBQUs7UUFDTCxTQUFTO1FBQ1QsSUFBSSxDQUFDQyxtQkFBbUIsR0FBR0QsS0FBS0Usa0JBQWtCLElBQUksS0FBS1Q7UUFDM0QsSUFBSSxDQUFDVSxjQUFjLEdBQUdILEtBQUtJLGFBQWEsSUFBSTtRQUM1QyxRQUFRO1FBQ1IsSUFBSSxDQUFDQyxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDQyxVQUFVLEdBQUc7UUFDbEIsa0NBQWtDO1FBQ2xDLElBQUksQ0FBQ0MsY0FBYyxHQUFHLElBQUksQ0FBQ0EsY0FBYyxDQUFDQyxJQUFJLENBQUMsSUFBSTtRQUNuRCxJQUFJLENBQUNDLGlCQUFpQixHQUFHLElBQUksQ0FBQ0EsaUJBQWlCLENBQUNELElBQUksQ0FBQyxJQUFJO1FBQ3pELElBQUksQ0FBQ0Usa0JBQWtCLEdBQUcsSUFBSSxDQUFDQSxrQkFBa0IsQ0FBQ0YsSUFBSSxDQUFDLElBQUk7UUFDM0QsNkJBQTZCO1FBQzdCLElBQUks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a0JBQWtCLENBQUNDLFdBQVc7WUFDcEM7UUFDSjtRQUNBLElBQUksQ0FBQ00sZ0JBQWdCLENBQUNOO0lBQzFCO0lBQ0FNLGlCQUFpQk4sUUFBUSxFQUFFO1FBQ3ZCLE1BQU1PLFdBQVcsSUFBSSxDQUFDdkMsYUFBYTtRQUNuQyxJQUFJLENBQUNBLGFBQWEsR0FBR2dDO1FBQ3JCLElBQUksQ0FBQ1AsSUFBSSxDQUFDLFVBQVVPO1FBQ3BCLElBQUksQ0FBQ1AsSUFBSSxDQUFDLFFBQVE7WUFBRWM7WUFBVVA7UUFBUztJQUMzQztJQUNBTiwwQkFBMEI7UUFDdEIsNkJBQTZCO1FBQzdCLElBQUksQ0FBQ2xCLHdCQUF3QjtRQUM3QixnQ0FBZ0M7UUFDaEMsSUFBSSxDQUFDZ0Msa0JBQWtCLEdBQUdDLFdBQVcsSUFBSSxDQUFDcEMsa0JBQWtCLEVBQUUsSUFBSSxDQUFDVCxtQkFBbUI7UUFDdEYsa0NBQWtDO1FBQ2xDLElBQUksSUFBSSxDQUFDNEMsa0JBQWtCLENBQUNFLEtBQUssRUFBRTtZQUMvQixJQUFJLENBQUNGLGtCQUFrQixDQUFDRSxLQUFLO1FBQ2pDO0lBQ0o7SUFDQWxDLDJCQUEyQjtRQUN2QixJQUFJLElBQUksQ0FBQ2dDLGtCQUFrQixFQUFFO1lBQ3pCRyxhQUFhLElBQUksQ0FBQ0gsa0JBQWtCO1FBQ3hDO0lBQ0o7SUFDQW5DLHFCQUFxQjtRQUNqQixJQUFJLENBQUNMLGFBQWEsR0FBRztJQUN6QjtBQUNKO0FBQ0FqQix3QkFBd0IsR0FBR0U7QUFDM0I7Ozs7OztDQU1DLEdBQ0QsU0FBU2tELFNBQVNTLE1BQU07SUFDcEIsT0FBT0MsT0FBT0MsUUFBUSxDQUFDRixRQUFRO0FBQ25DLEVBQ0EsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RhYmxlLXJvdXRlci13ZWIvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvZGlzdC9CYXNlQmxvY2tUcmFja2VyLmpzP2QwMjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJhc2VCbG9ja1RyYWNrZXIgPSB2b2lkIDA7XG5jb25zdCBzYWZlX2V2ZW50X2VtaXR0ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQG1ldGFtYXNrL3NhZmUtZXZlbnQtZW1pdHRlclwiKSk7XG5jb25zdCBzZWMgPSAxMDAwO1xuY29uc3QgY2FsY3VsYXRlU3VtID0gKGFjY3VtdWxhdG9yLCBjdXJyZW50VmFsdWUpID0+IGFjY3VtdWxhdG9yICsgY3VycmVudFZhbHVlO1xuY29uc3QgYmxvY2tUcmFja2VyRXZlbnRzID0gWydzeW5jJywgJ2xhdGVzdCddO1xuY2xhc3MgQmFzZUJsb2NrVHJhY2tlciBleHRlbmRzIHNhZmVfZXZlbnRfZW1pdHRlcl8xLmRlZmF1bHQge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gY29uZmlnXG4gICAgICAgIHRoaXMuX2Jsb2NrUmVzZXREdXJhdGlvbiA9IG9wdHMuYmxvY2tSZXNldER1cmF0aW9uIHx8IDIwICogc2VjO1xuICAgICAgICB0aGlzLl91c2VQYXN0QmxvY2tzID0gb3B0cy51c2VQYXN0QmxvY2tzIHx8IGZhbHNlO1xuICAgICAgICAvLyBzdGF0ZVxuICAgICAgICB0aGlzLl9jdXJyZW50QmxvY2sgPSBudWxsO1xuICAgICAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gYmluZCBmdW5jdGlvbnMgZm9yIGludGVybmFsIHVzZVxuICAgICAgICB0aGlzLl9vbk5ld0xpc3RlbmVyID0gdGhpcy5fb25OZXdMaXN0ZW5lci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9vblJlbW92ZUxpc3RlbmVyID0gdGhpcy5fb25SZW1vdmVMaXN0ZW5lci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9yZXNldEN1cnJlbnRCbG9jayA9IHRoaXMuX3Jlc2V0Q3VycmVudEJsb2NrLmJpbmQodGhpcyk7XG4gICAgICAgIC8vIGxpc3RlbiBmb3IgaGFuZGxlciBjaGFuZ2VzXG4gICAgICAgIHRoaXMuX3NldHVwSW50ZXJuYWxFdmVudHMoKTtcbiAgICB9XG4gICAgYXN5bmMgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fY2FuY2VsQmxvY2tSZXNldFRpbWVvdXQoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fbWF5YmVFbmQoKTtcbiAgICAgICAgc3VwZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIGlzUnVubmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzUnVubmluZztcbiAgICB9XG4gICAgZ2V0Q3VycmVudEJsb2NrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudEJsb2NrO1xuICAgIH1cbiAgICBhc3luYyBnZXRMYXRlc3RCbG9jaygpIHtcbiAgICAgICAgLy8gcmV0dXJuIGlmIGF2YWlsYWJsZVxuICAgICAgICBpZiAodGhpcy5fY3VycmVudEJsb2NrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudEJsb2NrO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdhaXQgZm9yIGEgbmV3IGxhdGVzdCBibG9ja1xuICAgICAgICBjb25zdCBsYXRlc3RCbG9jayA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB0aGlzLm9uY2UoJ2xhdGVzdCcsIHJlc29sdmUpKTtcbiAgICAgICAgLy8gcmV0dXJuIG5ld2x5IHNldCBjdXJyZW50IGJsb2NrXG4gICAgICAgIHJldHVybiBsYXRlc3RCbG9jaztcbiAgICB9XG4gICAgLy8gZG9udCBhbGxvdyBtb2R1bGUgY29uc3VtZXIgdG8gcmVtb3ZlIG91ciBpbnRlcm5hbCBldmVudCBsaXN0ZW5lcnNcbiAgICByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKSB7XG4gICAgICAgIC8vIHBlcmZvcm0gZGVmYXVsdCBiZWhhdmlvciwgcHJlc2VydmUgZm4gYXJpdHlcbiAgICAgICAgaWYgKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgc3VwZXIucmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZS1hZGQgaW50ZXJuYWwgZXZlbnRzXG4gICAgICAgIHRoaXMuX3NldHVwSW50ZXJuYWxFdmVudHMoKTtcbiAgICAgICAgLy8gdHJpZ2dlciBzdG9wIGNoZWNrIGp1c3QgaW4gY2FzZVxuICAgICAgICB0aGlzLl9vblJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBfc2V0dXBJbnRlcm5hbEV2ZW50cygpIHtcbiAgICAgICAgLy8gZmlyc3QgcmVtb3ZlIGxpc3RlbmVycyBmb3IgaWRlbXBvdGVuY2VcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignbmV3TGlzdGVuZXInLCB0aGlzLl9vbk5ld0xpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigncmVtb3ZlTGlzdGVuZXInLCB0aGlzLl9vblJlbW92ZUxpc3RlbmVyKTtcbiAgICAgICAgLy8gdGhlbiBhZGQgdGhlbVxuICAgICAgICB0aGlzLm9uKCduZXdMaXN0ZW5lcicsIHRoaXMuX29uTmV3TGlzdGVuZXIpO1xuICAgICAgICB0aGlzLm9uKCdyZW1vdmVMaXN0ZW5lcicsIHRoaXMuX29uUmVtb3ZlTGlzdGVuZXIpO1xuICAgIH1cbiAgICBfb25OZXdMaXN0ZW5lcihldmVudE5hbWUpIHtcbiAgICAgICAgLy8gYG5ld0xpc3RlbmVyYCBpcyBjYWxsZWQgKmJlZm9yZSogdGhlIGxpc3RlbmVyIGlzIGFkZGVkXG4gICAgICAgIGlmIChibG9ja1RyYWNrZXJFdmVudHMuaW5jbHVkZXMoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5fbWF5YmVTdGFydCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9vblJlbW92ZUxpc3RlbmVyKCkge1xuICAgICAgICAvLyBgcmVtb3ZlTGlzdGVuZXJgIGlzIGNhbGxlZCAqYWZ0ZXIqIHRoZSBsaXN0ZW5lciBpcyByZW1vdmVkXG4gICAgICAgIGlmICh0aGlzLl9nZXRCbG9ja1RyYWNrZXJFdmVudENvdW50KCkgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWF5YmVFbmQoKTtcbiAgICB9XG4gICAgYXN5bmMgX21heWJlU3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc1J1bm5pbmcgPSB0cnVlO1xuICAgICAgICAvLyBjYW5jZWwgc2V0dGluZyBsYXRlc3QgYmxvY2sgdG8gc3RhbGVcbiAgICAgICAgdGhpcy5fY2FuY2VsQmxvY2tSZXNldFRpbWVvdXQoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fc3RhcnQoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdfc3RhcnRlZCcpO1xuICAgIH1cbiAgICBhc3luYyBfbWF5YmVFbmQoKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNSdW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3NldHVwQmxvY2tSZXNldFRpbWVvdXQoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fZW5kKCk7XG4gICAgICAgIHRoaXMuZW1pdCgnX2VuZGVkJyk7XG4gICAgfVxuICAgIF9nZXRCbG9ja1RyYWNrZXJFdmVudENvdW50KCkge1xuICAgICAgICByZXR1cm4gYmxvY2tUcmFja2VyRXZlbnRzXG4gICAgICAgICAgICAubWFwKChldmVudE5hbWUpID0+IHRoaXMubGlzdGVuZXJDb3VudChldmVudE5hbWUpKVxuICAgICAgICAgICAgLnJlZHVjZShjYWxjdWxhdGVTdW0pO1xuICAgIH1cbiAgICBfc2hvdWxkVXNlTmV3QmxvY2sobmV3QmxvY2spIHtcbiAgICAgICAgY29uc3QgY3VycmVudEJsb2NrID0gdGhpcy5fY3VycmVudEJsb2NrO1xuICAgICAgICBpZiAoIWN1cnJlbnRCbG9jaykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3QmxvY2tJbnQgPSBoZXhUb0ludChuZXdCbG9jayk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRCbG9ja0ludCA9IGhleFRvSW50KGN1cnJlbnRCbG9jayk7XG4gICAgICAgIHJldHVybiAoKHRoaXMuX3VzZVBhc3RCbG9ja3MgJiYgbmV3QmxvY2tJbnQgPCBjdXJyZW50QmxvY2tJbnQpIHx8XG4gICAgICAgICAgICBuZXdCbG9ja0ludCA+IGN1cnJlbnRCbG9ja0ludCk7XG4gICAgfVxuICAgIF9uZXdQb3RlbnRpYWxMYXRlc3QobmV3QmxvY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zaG91bGRVc2VOZXdCbG9jayhuZXdCbG9jaykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRDdXJyZW50QmxvY2sobmV3QmxvY2spO1xuICAgIH1cbiAgICBfc2V0Q3VycmVudEJsb2NrKG5ld0Jsb2NrKSB7XG4gICAgICAgIGNvbnN0IG9sZEJsb2NrID0gdGhpcy5fY3VycmVudEJsb2NrO1xuICAgICAgICB0aGlzLl9jdXJyZW50QmxvY2sgPSBuZXdCbG9jaztcbiAgICAgICAgdGhpcy5lbWl0KCdsYXRlc3QnLCBuZXdCbG9jayk7XG4gICAgICAgIHRoaXMuZW1pdCgnc3luYycsIHsgb2xkQmxvY2ssIG5ld0Jsb2NrIH0pO1xuICAgIH1cbiAgICBfc2V0dXBCbG9ja1Jlc2V0VGltZW91dCgpIHtcbiAgICAgICAgLy8gY2xlYXIgYW55IGV4aXN0aW5nIHRpbWVvdXRcbiAgICAgICAgdGhpcy5fY2FuY2VsQmxvY2tSZXNldFRpbWVvdXQoKTtcbiAgICAgICAgLy8gY2xlYXIgbGF0ZXN0IGJsb2NrIHdoZW4gc3RhbGVcbiAgICAgICAgdGhpcy5fYmxvY2tSZXNldFRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuX3Jlc2V0Q3VycmVudEJsb2NrLCB0aGlzLl9ibG9ja1Jlc2V0RHVyYXRpb24pO1xuICAgICAgICAvLyBub2RlanMgLSBkb250IGhvbGQgcHJvY2VzcyBvcGVuXG4gICAgICAgIGlmICh0aGlzLl9ibG9ja1Jlc2V0VGltZW91dC51bnJlZikge1xuICAgICAgICAgICAgdGhpcy5fYmxvY2tSZXNldFRpbWVvdXQudW5yZWYoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfY2FuY2VsQmxvY2tSZXNldFRpbWVvdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9ibG9ja1Jlc2V0VGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2Jsb2NrUmVzZXRUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcmVzZXRDdXJyZW50QmxvY2soKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRCbG9jayA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlQmxvY2tUcmFja2VyID0gQmFzZUJsb2NrVHJhY2tlcjtcbi8qKlxuICogQ29udmVydHMgYSBudW1iZXIgcmVwcmVzZW50ZWQgYXMgYSBzdHJpbmcgaW4gaGV4YWRlY2ltYWwgZm9ybWF0IGludG8gYSBuYXRpdmVcbiAqIG51bWJlci5cbiAqXG4gKiBAcGFyYW0gaGV4SW50IC0gVGhlIGhleCBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyLlxuICovXG5mdW5jdGlvbiBoZXhUb0ludChoZXhJbnQpIHtcbiAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KGhleEludCwgMTYpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZUJsb2NrVHJhY2tlci5qcy5tYXAiXSwibmFtZXMiOlsiX19pbXBvcnREZWZhdWx0IiwibW9kIiwiX19lc01vZHVsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQmFzZUJsb2NrVHJhY2tlciIsInNhZmVfZXZlbnRfZW1pdHRlcl8xIiwicmVxdWlyZSIsInNlYyIsImNhbGN1bGF0ZVN1bSIsImFjY3VtdWxhdG9yIiwiY3VycmVudFZhbHVlIiwiYmxvY2tUcmFja2VyRXZlbnRzIiwiZGVmYXVsdCIsImNvbnN0cnVjdG9yIiwib3B0cyIsIl9ibG9ja1Jlc2V0RHVyYXRpb24iLCJibG9ja1Jlc2V0RHVyYXRpb24iLCJfdXNlUGFzdEJsb2NrcyIsInVzZVBhc3RCbG9ja3MiLCJfY3VycmVudEJsb2NrIiwiX2lzUnVubmluZyIsIl9vbk5ld0xpc3RlbmVyIiwiYmluZCIsIl9vblJlbW92ZUxpc3RlbmVyIiwiX3Jlc2V0Q3VycmVudEJsb2NrIiwiX3NldHVwSW50ZXJuYWxFdmVudHMiLCJkZXN0cm95IiwiX2NhbmNlbEJsb2NrUmVzZXRUaW1lb3V0IiwiX21heWJlRW5kIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiaXNSdW5uaW5nIiwiZ2V0Q3VycmVudEJsb2NrIiwiZ2V0TGF0ZXN0QmxvY2siLCJsYXRlc3RCbG9jayIsIlByb21pc2UiLCJyZXNvbHZlIiwib25jZSIsImV2ZW50TmFtZSIsInJlbW92ZUxpc3RlbmVyIiwib24iLCJpbmNsdWRlcyIsIl9tYXliZVN0YXJ0IiwiX2dldEJsb2NrVHJhY2tlckV2ZW50Q291bnQiLCJfc3RhcnQiLCJlbWl0IiwiX3NldHVwQmxvY2tSZXNldFRpbWVvdXQiLCJfZW5kIiwibWFwIiwibGlzdGVuZXJDb3VudCIsInJlZHVjZSIsIl9zaG91bGRVc2VOZXdCbG9jayIsIm5ld0Jsb2NrIiwiY3VycmVudEJsb2NrIiwibmV3QmxvY2tJbnQiLCJoZXhUb0ludCIsImN1cnJlbnRCbG9ja0ludCIsIl9uZXdQb3RlbnRpYWxMYXRlc3QiLCJfc2V0Q3VycmVudEJsb2NrIiwib2xkQmxvY2siLCJfYmxvY2tSZXNldFRpbWVvdXQiLCJzZXRUaW1lb3V0IiwidW5yZWYiLCJjbGVhclRpbWVvdXQiLCJoZXhJbnQiLCJOdW1iZXIiLCJwYXJzZUludCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/dist/BaseBlockTracker.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/dist/PollingBlockTracker.js":
/*!********************************************************************!*\
  !*** ./node_modules/eth-block-tracker/dist/PollingBlockTracker.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PollingBlockTracker = void 0;\nconst json_rpc_random_id_1 = __importDefault(__webpack_require__(/*! json-rpc-random-id */ \"(ssr)/./node_modules/json-rpc-random-id/index.js\"));\nconst pify_1 = __importDefault(__webpack_require__(/*! pify */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/pify/index.js\"));\nconst BaseBlockTracker_1 = __webpack_require__(/*! ./BaseBlockTracker */ \"(ssr)/./node_modules/eth-block-tracker/dist/BaseBlockTracker.js\");\nconst logging_utils_1 = __webpack_require__(/*! ./logging-utils */ \"(ssr)/./node_modules/eth-block-tracker/dist/logging-utils.js\");\nconst log = (0, logging_utils_1.createModuleLogger)(logging_utils_1.projectLogger, \"polling-block-tracker\");\nconst createRandomId = (0, json_rpc_random_id_1.default)();\nconst sec = 1000;\nclass PollingBlockTracker extends BaseBlockTracker_1.BaseBlockTracker {\n    constructor(opts = {}){\n        var _a;\n        // parse + validate args\n        if (!opts.provider) {\n            throw new Error(\"PollingBlockTracker - no provider specified.\");\n        }\n        super(Object.assign(Object.assign({}, opts), {\n            blockResetDuration: (_a = opts.blockResetDuration) !== null && _a !== void 0 ? _a : opts.pollingInterval\n        }));\n        // config\n        this._provider = opts.provider;\n        this._pollingInterval = opts.pollingInterval || 20 * sec;\n        this._retryTimeout = opts.retryTimeout || this._pollingInterval / 10;\n        this._keepEventLoopActive = opts.keepEventLoopActive === undefined ? true : opts.keepEventLoopActive;\n        this._setSkipCacheFlag = opts.setSkipCacheFlag || false;\n    }\n    // trigger block polling\n    async checkForLatestBlock() {\n        await this._updateLatestBlock();\n        return await this.getLatestBlock();\n    }\n    async _start() {\n        this._synchronize();\n    }\n    async _end() {\n    // No-op\n    }\n    async _synchronize() {\n        var _a;\n        while(this._isRunning){\n            try {\n                await this._updateLatestBlock();\n                const promise = timeout(this._pollingInterval, !this._keepEventLoopActive);\n                this.emit(\"_waitingForNextIteration\");\n                await promise;\n            } catch (err) {\n                const newErr = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:\\n${(_a = err.stack) !== null && _a !== void 0 ? _a : err}`);\n                try {\n                    this.emit(\"error\", newErr);\n                } catch (emitErr) {\n                    console.error(newErr);\n                }\n                const promise = timeout(this._retryTimeout, !this._keepEventLoopActive);\n                this.emit(\"_waitingForNextIteration\");\n                await promise;\n            }\n        }\n    }\n    async _updateLatestBlock() {\n        // fetch + set latest block\n        const latestBlock = await this._fetchLatestBlock();\n        this._newPotentialLatest(latestBlock);\n    }\n    async _fetchLatestBlock() {\n        const req = {\n            jsonrpc: \"2.0\",\n            id: createRandomId(),\n            method: \"eth_blockNumber\",\n            params: []\n        };\n        if (this._setSkipCacheFlag) {\n            req.skipCache = true;\n        }\n        log(\"Making request\", req);\n        const res = await (0, pify_1.default)((cb)=>this._provider.sendAsync(req, cb))();\n        log(\"Got response\", res);\n        if (res.error) {\n            throw new Error(`PollingBlockTracker - encountered error fetching block:\\n${res.error.message}`);\n        }\n        return res.result;\n    }\n}\nexports.PollingBlockTracker = PollingBlockTracker;\n/**\n * Waits for the specified amount of time.\n *\n * @param duration - The amount of time in milliseconds.\n * @param unref - Assuming this function is run in a Node context, governs\n * whether Node should wait before the `setTimeout` has completed before ending\n * the process (true for no, false for yes). Defaults to false.\n * @returns A promise that can be used to wait.\n */ function timeout(duration, unref) {\n    return new Promise((resolve)=>{\n        const timeoutRef = setTimeout(resolve, duration);\n        // don't keep process open\n        if (timeoutRef.unref && unref) {\n            timeoutRef.unref();\n        }\n    });\n} //# sourceMappingURL=PollingBlockTracker.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvZGlzdC9Qb2xsaW5nQmxvY2tUcmFja2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLElBQUssSUFBSSxJQUFJLENBQUNBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBRSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsMkJBQTJCLEdBQUcsS0FBSztBQUNuQyxNQUFNRyx1QkFBdUJSLGdCQUFnQlMsbUJBQU9BLENBQUMsNEVBQW9CO0FBQ3pFLE1BQU1DLFNBQVNWLGdCQUFnQlMsbUJBQU9BLENBQUMsK0VBQU07QUFDN0MsTUFBTUUscUJBQXFCRixtQkFBT0EsQ0FBQywyRkFBb0I7QUFDdkQsTUFBTUcsa0JBQWtCSCxtQkFBT0EsQ0FBQyxxRkFBaUI7QUFDakQsTUFBTUksTUFBTSxDQUFDLEdBQUdELGdCQUFnQkUsa0JBQWtCLEVBQUVGLGdCQUFnQkcsYUFBYSxFQUFFO0FBQ25GLE1BQU1DLGlCQUFpQixDQUFDLEdBQUdSLHFCQUFxQlMsT0FBTztBQUN2RCxNQUFNQyxNQUFNO0FBQ1osTUFBTVgsNEJBQTRCSSxtQkFBbUJRLGdCQUFnQjtJQUNqRUMsWUFBWUMsT0FBTyxDQUFDLENBQUMsQ0FBRTtRQUNuQixJQUFJQztRQUNKLHdCQUF3QjtRQUN4QixJQUFJLENBQUNELEtBQUtFLFFBQVEsRUFBRTtZQUNoQixNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQSxLQUFLLENBQUNyQixPQUFPc0IsTUFBTSxDQUFDdEIsT0FBT3NCLE1BQU0sQ0FBQyxDQUFDLEdBQUdKLE9BQU87WUFBRUssb0JBQW9CLENBQUNKLEtBQUtELEtBQUtLLGtCQUFrQixNQUFNLFFBQVFKLE9BQU8sS0FBSyxJQUFJQSxLQUFLRCxLQUFLTSxlQUFlO1FBQUM7UUFDeEos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QStDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RhYmxlLXJvdXRlci13ZWIvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvZGlzdC9Qb2xsaW5nQmxvY2tUcmFja2VyLmpzPzMxZDIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBvbGxpbmdCbG9ja1RyYWNrZXIgPSB2b2lkIDA7XG5jb25zdCBqc29uX3JwY19yYW5kb21faWRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwianNvbi1ycGMtcmFuZG9tLWlkXCIpKTtcbmNvbnN0IHBpZnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicGlmeVwiKSk7XG5jb25zdCBCYXNlQmxvY2tUcmFja2VyXzEgPSByZXF1aXJlKFwiLi9CYXNlQmxvY2tUcmFja2VyXCIpO1xuY29uc3QgbG9nZ2luZ191dGlsc18xID0gcmVxdWlyZShcIi4vbG9nZ2luZy11dGlsc1wiKTtcbmNvbnN0IGxvZyA9ICgwLCBsb2dnaW5nX3V0aWxzXzEuY3JlYXRlTW9kdWxlTG9nZ2VyKShsb2dnaW5nX3V0aWxzXzEucHJvamVjdExvZ2dlciwgJ3BvbGxpbmctYmxvY2stdHJhY2tlcicpO1xuY29uc3QgY3JlYXRlUmFuZG9tSWQgPSAoMCwganNvbl9ycGNfcmFuZG9tX2lkXzEuZGVmYXVsdCkoKTtcbmNvbnN0IHNlYyA9IDEwMDA7XG5jbGFzcyBQb2xsaW5nQmxvY2tUcmFja2VyIGV4dGVuZHMgQmFzZUJsb2NrVHJhY2tlcl8xLkJhc2VCbG9ja1RyYWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIHBhcnNlICsgdmFsaWRhdGUgYXJnc1xuICAgICAgICBpZiAoIW9wdHMucHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9sbGluZ0Jsb2NrVHJhY2tlciAtIG5vIHByb3ZpZGVyIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdHMpLCB7IGJsb2NrUmVzZXREdXJhdGlvbjogKF9hID0gb3B0cy5ibG9ja1Jlc2V0RHVyYXRpb24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG9wdHMucG9sbGluZ0ludGVydmFsIH0pKTtcbiAgICAgICAgLy8gY29uZmlnXG4gICAgICAgIHRoaXMuX3Byb3ZpZGVyID0gb3B0cy5wcm92aWRlcjtcbiAgICAgICAgdGhpcy5fcG9sbGluZ0ludGVydmFsID0gb3B0cy5wb2xsaW5nSW50ZXJ2YWwgfHwgMjAgKiBzZWM7XG4gICAgICAgIHRoaXMuX3JldHJ5VGltZW91dCA9IG9wdHMucmV0cnlUaW1lb3V0IHx8IHRoaXMuX3BvbGxpbmdJbnRlcnZhbCAvIDEwO1xuICAgICAgICB0aGlzLl9rZWVwRXZlbnRMb29wQWN0aXZlID1cbiAgICAgICAgICAgIG9wdHMua2VlcEV2ZW50TG9vcEFjdGl2ZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdHMua2VlcEV2ZW50TG9vcEFjdGl2ZTtcbiAgICAgICAgdGhpcy5fc2V0U2tpcENhY2hlRmxhZyA9IG9wdHMuc2V0U2tpcENhY2hlRmxhZyB8fCBmYWxzZTtcbiAgICB9XG4gICAgLy8gdHJpZ2dlciBibG9jayBwb2xsaW5nXG4gICAgYXN5bmMgY2hlY2tGb3JMYXRlc3RCbG9jaygpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlTGF0ZXN0QmxvY2soKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0TGF0ZXN0QmxvY2soKTtcbiAgICB9XG4gICAgYXN5bmMgX3N0YXJ0KCkge1xuICAgICAgICB0aGlzLl9zeW5jaHJvbml6ZSgpO1xuICAgIH1cbiAgICBhc3luYyBfZW5kKCkge1xuICAgICAgICAvLyBOby1vcFxuICAgIH1cbiAgICBhc3luYyBfc3luY2hyb25pemUoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgd2hpbGUgKHRoaXMuX2lzUnVubmluZykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVMYXRlc3RCbG9jaygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSB0aW1lb3V0KHRoaXMuX3BvbGxpbmdJbnRlcnZhbCwgIXRoaXMuX2tlZXBFdmVudExvb3BBY3RpdmUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnX3dhaXRpbmdGb3JOZXh0SXRlcmF0aW9uJyk7XG4gICAgICAgICAgICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdFcnIgPSBuZXcgRXJyb3IoYFBvbGxpbmdCbG9ja1RyYWNrZXIgLSBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBhdHRlbXB0aW5nIHRvIHVwZGF0ZSBsYXRlc3QgYmxvY2s6XFxuJHsoX2EgPSBlcnIuc3RhY2spICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGVycn1gKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3RXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVtaXRFcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihuZXdFcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gdGltZW91dCh0aGlzLl9yZXRyeVRpbWVvdXQsICF0aGlzLl9rZWVwRXZlbnRMb29wQWN0aXZlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ193YWl0aW5nRm9yTmV4dEl0ZXJhdGlvbicpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX3VwZGF0ZUxhdGVzdEJsb2NrKCkge1xuICAgICAgICAvLyBmZXRjaCArIHNldCBsYXRlc3QgYmxvY2tcbiAgICAgICAgY29uc3QgbGF0ZXN0QmxvY2sgPSBhd2FpdCB0aGlzLl9mZXRjaExhdGVzdEJsb2NrKCk7XG4gICAgICAgIHRoaXMuX25ld1BvdGVudGlhbExhdGVzdChsYXRlc3RCbG9jayk7XG4gICAgfVxuICAgIGFzeW5jIF9mZXRjaExhdGVzdEJsb2NrKCkge1xuICAgICAgICBjb25zdCByZXEgPSB7XG4gICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgIGlkOiBjcmVhdGVSYW5kb21JZCgpLFxuICAgICAgICAgICAgbWV0aG9kOiAnZXRoX2Jsb2NrTnVtYmVyJyxcbiAgICAgICAgICAgIHBhcmFtczogW10sXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLl9zZXRTa2lwQ2FjaGVGbGFnKSB7XG4gICAgICAgICAgICByZXEuc2tpcENhY2hlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsb2coJ01ha2luZyByZXF1ZXN0JywgcmVxKTtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgKDAsIHBpZnlfMS5kZWZhdWx0KSgoY2IpID0+IHRoaXMuX3Byb3ZpZGVyLnNlbmRBc3luYyhyZXEsIGNiKSkoKTtcbiAgICAgICAgbG9nKCdHb3QgcmVzcG9uc2UnLCByZXMpO1xuICAgICAgICBpZiAocmVzLmVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvbGxpbmdCbG9ja1RyYWNrZXIgLSBlbmNvdW50ZXJlZCBlcnJvciBmZXRjaGluZyBibG9jazpcXG4ke3Jlcy5lcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuUG9sbGluZ0Jsb2NrVHJhY2tlciA9IFBvbGxpbmdCbG9ja1RyYWNrZXI7XG4vKipcbiAqIFdhaXRzIGZvciB0aGUgc3BlY2lmaWVkIGFtb3VudCBvZiB0aW1lLlxuICpcbiAqIEBwYXJhbSBkdXJhdGlvbiAtIFRoZSBhbW91bnQgb2YgdGltZSBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcGFyYW0gdW5yZWYgLSBBc3N1bWluZyB0aGlzIGZ1bmN0aW9uIGlzIHJ1biBpbiBhIE5vZGUgY29udGV4dCwgZ292ZXJuc1xuICogd2hldGhlciBOb2RlIHNob3VsZCB3YWl0IGJlZm9yZSB0aGUgYHNldFRpbWVvdXRgIGhhcyBjb21wbGV0ZWQgYmVmb3JlIGVuZGluZ1xuICogdGhlIHByb2Nlc3MgKHRydWUgZm9yIG5vLCBmYWxzZSBmb3IgeWVzKS4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCBjYW4gYmUgdXNlZCB0byB3YWl0LlxuICovXG5mdW5jdGlvbiB0aW1lb3V0KGR1cmF0aW9uLCB1bnJlZikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBjb25zdCB0aW1lb3V0UmVmID0gc2V0VGltZW91dChyZXNvbHZlLCBkdXJhdGlvbik7XG4gICAgICAgIC8vIGRvbid0IGtlZXAgcHJvY2VzcyBvcGVuXG4gICAgICAgIGlmICh0aW1lb3V0UmVmLnVucmVmICYmIHVucmVmKSB7XG4gICAgICAgICAgICB0aW1lb3V0UmVmLnVucmVmKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBvbGxpbmdCbG9ja1RyYWNrZXIuanMubWFwIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlBvbGxpbmdCbG9ja1RyYWNrZXIiLCJqc29uX3JwY19yYW5kb21faWRfMSIsInJlcXVpcmUiLCJwaWZ5XzEiLCJCYXNlQmxvY2tUcmFja2VyXzEiLCJsb2dnaW5nX3V0aWxzXzEiLCJsb2ciLCJjcmVhdGVNb2R1bGVMb2dnZXIiLCJwcm9qZWN0TG9nZ2VyIiwiY3JlYXRlUmFuZG9tSWQiLCJkZWZhdWx0Iiwic2VjIiwiQmFzZUJsb2NrVHJhY2tlciIsImNvbnN0cnVjdG9yIiwib3B0cyIsIl9hIiwicHJvdmlkZXIiLCJFcnJvciIsImFzc2lnbiIsImJsb2NrUmVzZXREdXJhdGlvbiIsInBvbGxpbmdJbnRlcnZhbCIsIl9wcm92aWRlciIsIl9wb2xsaW5nSW50ZXJ2YWwiLCJfcmV0cnlUaW1lb3V0IiwicmV0cnlUaW1lb3V0IiwiX2tlZXBFdmVudExvb3BBY3RpdmUiLCJrZWVwRXZlbnRMb29wQWN0aXZlIiwidW5kZWZpbmVkIiwiX3NldFNraXBDYWNoZUZsYWciLCJzZXRTa2lwQ2FjaGVGbGFnIiwiY2hlY2tGb3JMYXRlc3RCbG9jayIsIl91cGRhdGVMYXRlc3RCbG9jayIsImdldExhdGVzdEJsb2NrIiwiX3N0YXJ0IiwiX3N5bmNocm9uaXplIiwiX2VuZCIsIl9pc1J1bm5pbmciLCJwcm9taXNlIiwidGltZW91dCIsImVtaXQiLCJlcnIiLCJuZXdFcnIiLCJzdGFjayIsImVtaXRFcnIiLCJjb25zb2xlIiwiZXJyb3IiLCJsYXRlc3RCbG9jayIsIl9mZXRjaExhdGVzdEJsb2NrIiwiX25ld1BvdGVudGlhbExhdGVzdCIsInJlcSIsImpzb25ycGMiLCJpZCIsIm1ldGhvZCIsInBhcmFtcyIsInNraXBDYWNoZSIsInJlcyIsImNiIiwic2VuZEFzeW5jIiwibWVzc2FnZSIsInJlc3VsdCIsImR1cmF0aW9uIiwidW5yZWYiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRpbWVvdXRSZWYiLCJzZXRUaW1lb3V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/dist/PollingBlockTracker.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/dist/SubscribeBlockTracker.js":
/*!**********************************************************************!*\
  !*** ./node_modules/eth-block-tracker/dist/SubscribeBlockTracker.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SubscribeBlockTracker = void 0;\nconst json_rpc_random_id_1 = __importDefault(__webpack_require__(/*! json-rpc-random-id */ \"(ssr)/./node_modules/json-rpc-random-id/index.js\"));\nconst BaseBlockTracker_1 = __webpack_require__(/*! ./BaseBlockTracker */ \"(ssr)/./node_modules/eth-block-tracker/dist/BaseBlockTracker.js\");\nconst createRandomId = (0, json_rpc_random_id_1.default)();\nclass SubscribeBlockTracker extends BaseBlockTracker_1.BaseBlockTracker {\n    constructor(opts = {}){\n        // parse + validate args\n        if (!opts.provider) {\n            throw new Error(\"SubscribeBlockTracker - no provider specified.\");\n        }\n        // BaseBlockTracker constructor\n        super(opts);\n        // config\n        this._provider = opts.provider;\n        this._subscriptionId = null;\n    }\n    async checkForLatestBlock() {\n        return await this.getLatestBlock();\n    }\n    async _start() {\n        if (this._subscriptionId === undefined || this._subscriptionId === null) {\n            try {\n                const blockNumber = await this._call(\"eth_blockNumber\");\n                this._subscriptionId = await this._call(\"eth_subscribe\", \"newHeads\");\n                this._provider.on(\"data\", this._handleSubData.bind(this));\n                this._newPotentialLatest(blockNumber);\n            } catch (e) {\n                this.emit(\"error\", e);\n            }\n        }\n    }\n    async _end() {\n        if (this._subscriptionId !== null && this._subscriptionId !== undefined) {\n            try {\n                await this._call(\"eth_unsubscribe\", this._subscriptionId);\n                this._subscriptionId = null;\n            } catch (e) {\n                this.emit(\"error\", e);\n            }\n        }\n    }\n    _call(method, ...params) {\n        return new Promise((resolve, reject)=>{\n            this._provider.sendAsync({\n                id: createRandomId(),\n                method,\n                params,\n                jsonrpc: \"2.0\"\n            }, (err, res)=>{\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(res.result);\n                }\n            });\n        });\n    }\n    _handleSubData(_, response) {\n        var _a;\n        if (response.method === \"eth_subscription\" && ((_a = response.params) === null || _a === void 0 ? void 0 : _a.subscription) === this._subscriptionId) {\n            this._newPotentialLatest(response.params.result.number);\n        }\n    }\n}\nexports.SubscribeBlockTracker = SubscribeBlockTracker; //# sourceMappingURL=SubscribeBlockTracker.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvZGlzdC9TdWJzY3JpYmVCbG9ja1RyYWNrZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsSUFBSyxJQUFJLElBQUksQ0FBQ0EsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FFLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCw2QkFBNkIsR0FBRyxLQUFLO0FBQ3JDLE1BQU1HLHVCQUF1QlIsZ0JBQWdCUyxtQkFBT0EsQ0FBQyw0RUFBb0I7QUFDekUsTUFBTUMscUJBQXFCRCxtQkFBT0EsQ0FBQywyRkFBb0I7QUFDdkQsTUFBTUUsaUJBQWlCLENBQUMsR0FBR0gscUJBQXFCSSxPQUFPO0FBQ3ZELE1BQU1MLDhCQUE4QkcsbUJBQW1CRyxnQkFBZ0I7SUFDbkVDLFlBQVlDLE9BQU8sQ0FBQyxDQUFDLENBQUU7UUFDbkIsd0JBQXdCO1FBQ3hCLElBQUksQ0FBQ0EsS0FBS0MsUUFBUSxFQUFFO1lBQ2hCLE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtRQUNBLCtCQUErQjtRQUMvQixLQUFLLENBQUNGO1FBQ04sU0FBUztRQUNULElBQUksQ0FBQ0csU0FBUyxHQUFHSCxLQUFLQyxRQUFRO1FBQzlCLElBQUksQ0FBQ0csZUFBZSxHQUFHO0lBQzNCO0lBQ0EsTUFBTUMsc0JBQXNCO1FBQ3hCLE9BQU8sTUFBTSxJQUFJLENBQUNDLGNBQWM7SUFDcEM7SUFDQSxNQUFNQyxTQUFTO1FBQ1gsSUFBSSxJQUFJLENBQUNILGVBQWUsS0FBS0ksYUFBYSxJQUFJLENBQUNKLGVBQWUsS0FBSyxNQUFNO1lBQ3JFLElBQUk7Z0JBQ0EsTUFBTUssY0FBZSxNQUFNLElBQUksQ0FBQ0MsS0FBSyxDQUFDO2dCQUN0QyxJQUFJLENBQUNOLGVBQWUsR0FBSSxNQUFNLElBQUksQ0FBQ00sS0FBSyxDQUFDLGlCQUFpQjtnQkFDMUQsSUFBSSxDQUFDUCxTQUFTLENBQUNRLEVBQUUsQ0FBQyxRQUFRLElBQUksQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUMsSUFBSTtnQkFDdkQsSUFBSSxDQUFDQyxtQkFBbUIsQ0FBQ0w7WUFDN0IsRUFDQSxPQUFPTSxHQUFHO2dCQUNOLElBQUksQ0FBQ0MsSUFBSSxDQUFDLFNBQVNEO1lBQ3ZCO1FBQ0o7SUFDSjtJQUNBLE1BQU1FLE9BQU87UUFDVCxJQUFJLElBQUksQ0FBQ2IsZUFBZSxLQUFLLFFBQVEsSUFBSSxDQUFDQSxlQUFlLEtBQUtJLFdBQVc7WUFDckUsSUFBSTtnQkFDQSxNQUFNLElBQUksQ0FBQ0UsS0FBSyxDQUFDLG1CQUFtQixJQUFJLENBQUNOLGVBQWU7Z0JBQ3hELElBQUksQ0FBQ0EsZUFBZSxHQUFHO1lBQzNCLEVBQ0EsT0FBT1csR0FBRztnQkFDTixJQUFJLENBQUNDLElBQUksQ0FBQyxTQUFTRDtZQUN2QjtRQUNKO0lBQ0o7SUFDQUwsTUFBTVEsTUFBTSxFQUFFLEdBQUdDLE1BQU0sRUFBRTtRQUNyQixPQUFPLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDekIsSUFBSSxDQUFDbkIsU0FBUyxDQUFDb0IsU0FBUyxDQUFDO2dCQUNyQkMsSUFBSTVCO2dCQUNKc0I7Z0JBQ0FDO2dCQUNBTSxTQUFTO1lBQ2IsR0FBRyxDQUFDQyxLQUFLQztnQkFDTCxJQUFJRCxLQUFLO29CQUNMSixPQUFPSTtnQkFDWCxPQUNLO29CQUNETCxRQUFRTSxJQUFJQyxNQUFNO2dCQUN0QjtZQUNKO1FBQ0o7SUFDSjtJQUNBaEIsZUFBZWlCLENBQUMsRUFBRUMsUUFBUSxFQUFFO1FBQ3hCLElBQUlDO1FBQ0osSUFBSUQsU0FBU1osTUFBTSxLQUFLLHNCQUNwQixDQUFDLENBQUNhLEtBQUtELFNBQVNYLE1BQU0sTUFBTSxRQUFRWSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdDLFlBQVksTUFBTSxJQUFJLENBQUM1QixlQUFlLEVBQUU7WUFDeEcsSUFBSSxDQUFDVSxtQkFBbUIsQ0FBQ2dCLFNBQVNYLE1BQU0sQ0FBQ1MsTUFBTSxDQUFDSyxNQUFNO1FBQzFEO0lBQ0o7QUFDSjtBQUNBM0MsNkJBQTZCLEdBQUdFLHVCQUNoQyxpREFBaUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGFibGUtcm91dGVyLXdlYi8uL25vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9kaXN0L1N1YnNjcmliZUJsb2NrVHJhY2tlci5qcz9iZDhhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdWJzY3JpYmVCbG9ja1RyYWNrZXIgPSB2b2lkIDA7XG5jb25zdCBqc29uX3JwY19yYW5kb21faWRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwianNvbi1ycGMtcmFuZG9tLWlkXCIpKTtcbmNvbnN0IEJhc2VCbG9ja1RyYWNrZXJfMSA9IHJlcXVpcmUoXCIuL0Jhc2VCbG9ja1RyYWNrZXJcIik7XG5jb25zdCBjcmVhdGVSYW5kb21JZCA9ICgwLCBqc29uX3JwY19yYW5kb21faWRfMS5kZWZhdWx0KSgpO1xuY2xhc3MgU3Vic2NyaWJlQmxvY2tUcmFja2VyIGV4dGVuZHMgQmFzZUJsb2NrVHJhY2tlcl8xLkJhc2VCbG9ja1RyYWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgICAgICAvLyBwYXJzZSArIHZhbGlkYXRlIGFyZ3NcbiAgICAgICAgaWYgKCFvcHRzLnByb3ZpZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1YnNjcmliZUJsb2NrVHJhY2tlciAtIG5vIHByb3ZpZGVyIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCYXNlQmxvY2tUcmFja2VyIGNvbnN0cnVjdG9yXG4gICAgICAgIHN1cGVyKG9wdHMpO1xuICAgICAgICAvLyBjb25maWdcbiAgICAgICAgdGhpcy5fcHJvdmlkZXIgPSBvcHRzLnByb3ZpZGVyO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25JZCA9IG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGNoZWNrRm9yTGF0ZXN0QmxvY2soKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldExhdGVzdEJsb2NrKCk7XG4gICAgfVxuICAgIGFzeW5jIF9zdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N1YnNjcmlwdGlvbklkID09PSB1bmRlZmluZWQgfHwgdGhpcy5fc3Vic2NyaXB0aW9uSWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSAoYXdhaXQgdGhpcy5fY2FsbCgnZXRoX2Jsb2NrTnVtYmVyJykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbklkID0gKGF3YWl0IHRoaXMuX2NhbGwoJ2V0aF9zdWJzY3JpYmUnLCAnbmV3SGVhZHMnKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvdmlkZXIub24oJ2RhdGEnLCB0aGlzLl9oYW5kbGVTdWJEYXRhLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX25ld1BvdGVudGlhbExhdGVzdChibG9ja051bWJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfZW5kKCkge1xuICAgICAgICBpZiAodGhpcy5fc3Vic2NyaXB0aW9uSWQgIT09IG51bGwgJiYgdGhpcy5fc3Vic2NyaXB0aW9uSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9jYWxsKCdldGhfdW5zdWJzY3JpYmUnLCB0aGlzLl9zdWJzY3JpcHRpb25JZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uSWQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NhbGwobWV0aG9kLCAuLi5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Byb3ZpZGVyLnNlbmRBc3luYyh7XG4gICAgICAgICAgICAgICAgaWQ6IGNyZWF0ZVJhbmRvbUlkKCksXG4gICAgICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgIH0sIChlcnIsIHJlcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlcy5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2hhbmRsZVN1YkRhdGEoXywgcmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAocmVzcG9uc2UubWV0aG9kID09PSAnZXRoX3N1YnNjcmlwdGlvbicgJiZcbiAgICAgICAgICAgICgoX2EgPSByZXNwb25zZS5wYXJhbXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdWJzY3JpcHRpb24pID09PSB0aGlzLl9zdWJzY3JpcHRpb25JZCkge1xuICAgICAgICAgICAgdGhpcy5fbmV3UG90ZW50aWFsTGF0ZXN0KHJlc3BvbnNlLnBhcmFtcy5yZXN1bHQubnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU3Vic2NyaWJlQmxvY2tUcmFja2VyID0gU3Vic2NyaWJlQmxvY2tUcmFja2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3Vic2NyaWJlQmxvY2tUcmFja2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJTdWJzY3JpYmVCbG9ja1RyYWNrZXIiLCJqc29uX3JwY19yYW5kb21faWRfMSIsInJlcXVpcmUiLCJCYXNlQmxvY2tUcmFja2VyXzEiLCJjcmVhdGVSYW5kb21JZCIsImRlZmF1bHQiLCJCYXNlQmxvY2tUcmFja2VyIiwiY29uc3RydWN0b3IiLCJvcHRzIiwicHJvdmlkZXIiLCJFcnJvciIsIl9wcm92aWRlciIsIl9zdWJzY3JpcHRpb25JZCIsImNoZWNrRm9yTGF0ZXN0QmxvY2siLCJnZXRMYXRlc3RCbG9jayIsIl9zdGFydCIsInVuZGVmaW5lZCIsImJsb2NrTnVtYmVyIiwiX2NhbGwiLCJvbiIsIl9oYW5kbGVTdWJEYXRhIiwiYmluZCIsIl9uZXdQb3RlbnRpYWxMYXRlc3QiLCJlIiwiZW1pdCIsIl9lbmQiLCJtZXRob2QiLCJwYXJhbXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInNlbmRBc3luYyIsImlkIiwianNvbnJwYyIsImVyciIsInJlcyIsInJlc3VsdCIsIl8iLCJyZXNwb25zZSIsIl9hIiwic3Vic2NyaXB0aW9uIiwibnVtYmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/dist/SubscribeBlockTracker.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/eth-block-tracker/dist/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    });\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = this && this.__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n__exportStar(__webpack_require__(/*! ./PollingBlockTracker */ \"(ssr)/./node_modules/eth-block-tracker/dist/PollingBlockTracker.js\"), exports);\n__exportStar(__webpack_require__(/*! ./SubscribeBlockTracker */ \"(ssr)/./node_modules/eth-block-tracker/dist/SubscribeBlockTracker.js\"), exports); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixJQUFLLElBQUksSUFBSSxDQUFDQSxlQUFlLElBQU1DLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCSixPQUFPTyxjQUFjLENBQUNMLEdBQUdHLElBQUk7UUFBRUcsWUFBWTtRQUFNQyxLQUFLO1lBQWEsT0FBT04sQ0FBQyxDQUFDQyxFQUFFO1FBQUU7SUFBRTtBQUN0RixJQUFNLFNBQVNGLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDdEIsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0JGLENBQUMsQ0FBQ0csR0FBRyxHQUFHRixDQUFDLENBQUNDLEVBQUU7QUFDaEIsQ0FBQztBQUNELElBQUlNLGVBQWUsSUFBSyxJQUFJLElBQUksQ0FBQ0EsWUFBWSxJQUFLLFNBQVNQLENBQUMsRUFBRVEsUUFBTztJQUNqRSxJQUFLLElBQUlDLEtBQUtULEVBQUcsSUFBSVMsTUFBTSxhQUFhLENBQUNaLE9BQU9hLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNKLFVBQVNDLElBQUliLGdCQUFnQlksVUFBU1IsR0FBR1M7QUFDM0g7QUFDQVosOENBQTZDO0lBQUVnQixPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdETixhQUFhTyxtQkFBT0EsQ0FBQyxpR0FBdUIsR0FBR047QUFDL0NELGFBQWFPLG1CQUFPQSxDQUFDLHFHQUF5QixHQUFHTixVQUNqRCxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGFibGUtcm91dGVyLXdlYi8uL25vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9kaXN0L2luZGV4LmpzP2FiYWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9Qb2xsaW5nQmxvY2tUcmFja2VyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9TdWJzY3JpYmVCbG9ja1RyYWNrZXJcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIl9fY3JlYXRlQmluZGluZyIsIk9iamVjdCIsImNyZWF0ZSIsIm8iLCJtIiwiayIsImsyIiwidW5kZWZpbmVkIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX19leHBvcnRTdGFyIiwiZXhwb3J0cyIsInAiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJ2YWx1ZSIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/dist/logging-utils.js":
/*!**************************************************************!*\
  !*** ./node_modules/eth-block-tracker/dist/logging-utils.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createModuleLogger = exports.projectLogger = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/index.js\");\nObject.defineProperty(exports, \"createModuleLogger\", ({\n    enumerable: true,\n    get: function() {\n        return utils_1.createModuleLogger;\n    }\n}));\nexports.projectLogger = (0, utils_1.createProjectLogger)(\"eth-block-tracker\"); //# sourceMappingURL=logging-utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvZGlzdC9sb2dnaW5nLXV0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwwQkFBMEIsR0FBR0EscUJBQXFCLEdBQUcsS0FBSztBQUMxRCxNQUFNSSxVQUFVQyxtQkFBT0EsQ0FBQywwR0FBaUI7QUFDekNQLHNEQUFxRDtJQUFFUSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPSCxRQUFRRixrQkFBa0I7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNuSUYscUJBQXFCLEdBQUcsQ0FBQyxHQUFHSSxRQUFRSSxtQkFBbUIsRUFBRSxzQkFDekQseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RhYmxlLXJvdXRlci13ZWIvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvZGlzdC9sb2dnaW5nLXV0aWxzLmpzP2RhMTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZU1vZHVsZUxvZ2dlciA9IGV4cG9ydHMucHJvamVjdExvZ2dlciA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL3V0aWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlTW9kdWxlTG9nZ2VyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18xLmNyZWF0ZU1vZHVsZUxvZ2dlcjsgfSB9KTtcbmV4cG9ydHMucHJvamVjdExvZ2dlciA9ICgwLCB1dGlsc18xLmNyZWF0ZVByb2plY3RMb2dnZXIpKCdldGgtYmxvY2stdHJhY2tlcicpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nZ2luZy11dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjcmVhdGVNb2R1bGVMb2dnZXIiLCJwcm9qZWN0TG9nZ2VyIiwidXRpbHNfMSIsInJlcXVpcmUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiY3JlYXRlUHJvamVjdExvZ2dlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/dist/logging-utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/assert.js":
/*!************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/assert.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.assertExhaustive = exports.assertStruct = exports.assert = exports.AssertionError = void 0;\nconst superstruct_1 = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\n/**\n * Type guard for determining whether the given value is an error object with a\n * `message` property, such as an instance of Error.\n *\n * @param error - The object to check.\n * @returns True or false, depending on the result.\n */ function isErrorWithMessage(error) {\n    return typeof error === \"object\" && error !== null && \"message\" in error;\n}\n/**\n * Check if a value is a constructor, i.e., a function that can be called with\n * the `new` keyword.\n *\n * @param fn - The value to check.\n * @returns `true` if the value is a constructor, or `false` otherwise.\n */ function isConstructable(fn) {\n    var _a, _b;\n    /* istanbul ignore next */ return Boolean(typeof ((_b = (_a = fn === null || fn === void 0 ? void 0 : fn.prototype) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name) === \"string\");\n}\n/**\n * Get the error message from an unknown error object. If the error object has\n * a `message` property, that property is returned. Otherwise, the stringified\n * error object is returned.\n *\n * @param error - The error object to get the message from.\n * @returns The error message.\n */ function getErrorMessage(error) {\n    const message = isErrorWithMessage(error) ? error.message : String(error);\n    // If the error ends with a period, remove it, as we'll add our own period.\n    if (message.endsWith(\".\")) {\n        return message.slice(0, -1);\n    }\n    return message;\n}\n/**\n * Initialise an {@link AssertionErrorConstructor} error.\n *\n * @param ErrorWrapper - The error class to use.\n * @param message - The error message.\n * @returns The error object.\n */ // eslint-disable-next-line @typescript-eslint/naming-convention\nfunction getError(ErrorWrapper, message) {\n    if (isConstructable(ErrorWrapper)) {\n        return new ErrorWrapper({\n            message\n        });\n    }\n    return ErrorWrapper({\n        message\n    });\n}\n/**\n * The default error class that is thrown if an assertion fails.\n */ class AssertionError extends Error {\n    constructor(options){\n        super(options.message);\n        this.code = \"ERR_ASSERTION\";\n    }\n}\nexports.AssertionError = AssertionError;\n/**\n * Same as Node.js assert.\n * If the value is falsy, throws an error, does nothing otherwise.\n *\n * @throws {@link AssertionError} If value is falsy.\n * @param value - The test that should be truthy to pass.\n * @param message - Message to be passed to {@link AssertionError} or an\n * {@link Error} instance to throw.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}. If a custom error class is provided for\n * the `message` argument, this argument is ignored.\n */ function assert(value, message = \"Assertion failed.\", // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper = AssertionError) {\n    if (!value) {\n        if (message instanceof Error) {\n            throw message;\n        }\n        throw getError(ErrorWrapper, message);\n    }\n}\nexports.assert = assert;\n/**\n * Assert a value against a Superstruct struct.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param errorPrefix - A prefix to add to the error message. Defaults to\n * \"Assertion failed\".\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the value is not valid.\n */ function assertStruct(value, struct, errorPrefix = \"Assertion failed\", // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper = AssertionError) {\n    try {\n        (0, superstruct_1.assert)(value, struct);\n    } catch (error) {\n        throw getError(ErrorWrapper, `${errorPrefix}: ${getErrorMessage(error)}.`);\n    }\n}\nexports.assertStruct = assertStruct;\n/**\n * Use in the default case of a switch that you want to be fully exhaustive.\n * Using this function forces the compiler to enforce exhaustivity during\n * compile-time.\n *\n * @example\n * ```\n * const number = 1;\n * switch (number) {\n *   case 0:\n *     ...\n *   case 1:\n *     ...\n *   default:\n *     assertExhaustive(snapPrefix);\n * }\n * ```\n * @param _object - The object on which the switch is being operated.\n */ function assertExhaustive(_object) {\n    throw new Error(\"Invalid branch reached. Should be detected during compilation.\");\n}\nexports.assertExhaustive = assertExhaustive; //# sourceMappingURL=assert.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2Fzc2VydC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsd0JBQXdCLEdBQUdBLG9CQUFvQixHQUFHQSxjQUFjLEdBQUdBLHNCQUFzQixHQUFHLEtBQUs7QUFDakcsTUFBTU0sZ0JBQWdCQyxtQkFBT0EsQ0FBQyxvRUFBYTtBQUMzQzs7Ozs7O0NBTUMsR0FDRCxTQUFTQyxtQkFBbUJDLEtBQUs7SUFDN0IsT0FBTyxPQUFPQSxVQUFVLFlBQVlBLFVBQVUsUUFBUSxhQUFhQTtBQUN2RTtBQUNBOzs7Ozs7Q0FNQyxHQUNELFNBQVNDLGdCQUFnQkMsRUFBRTtJQUN2QixJQUFJQyxJQUFJQztJQUNSLHdCQUF3QixHQUN4QixPQUFPQyxRQUFRLE9BQVEsRUFBQ0QsS0FBSyxDQUFDRCxLQUFLRCxPQUFPLFFBQVFBLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0ksU0FBUyxNQUFNLFFBQVFILE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0ksV0FBVyxNQUFNLFFBQVFILE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0ksSUFBSSxNQUFNO0FBQ3BNO0FBQ0E7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNDLGdCQUFnQlQsS0FBSztJQUMxQixNQUFNVSxVQUFVWCxtQkFBbUJDLFNBQVNBLE1BQU1VLE9BQU8sR0FBR0MsT0FBT1g7SUFDbkUsMkVBQTJFO0lBQzNFLElBQUlVLFFBQVFFLFFBQVEsQ0FBQyxNQUFNO1FBQ3ZCLE9BQU9GLFFBQVFHLEtBQUssQ0FBQyxHQUFHLENBQUM7SUFDN0I7SUFDQSxPQUFPSDtBQUNYO0FBQ0E7Ozs7OztDQU1DLEdBQ0QsZ0VBQWdFO0FBQ2hFLFNBQVNJLFNBQVNDLFlBQVksRUFBRUwsT0FBTztJQUNuQyxJQUFJVCxnQkFBZ0JjLGVBQWU7UUFDL0IsT0FBTyxJQUFJQSxhQUFhO1lBQ3BCTDtRQUNKO0lBQ0o7SUFDQSxPQUFPSyxhQUFhO1FBQ2hCTDtJQUNKO0FBQ0o7QUFDQTs7Q0FFQyxHQUNELE1BQU1kLHVCQUF1Qm9CO0lBQ3pCVCxZQUFZVSxPQUFPLENBQUU7UUFDakIsS0FBSyxDQUFDQSxRQUFRUCxPQUFPO1FBQ3JCLElBQUksQ0FBQ1EsSUFBSSxHQUFHO0lBQ2hCO0FBQ0o7QUFDQTNCLHNCQUFzQixHQUFHSztBQUN6Qjs7Ozs7Ozs7Ozs7Q0FXQyxHQUNELFNBQVNELE9BQU9ILEtBQUssRUFBRWtCLFVBQVUsbUJBQW1CLEVBQ3BELGdFQUFnRTtBQUNoRUssZUFBZW5CLGNBQWM7SUFDekIsSUFBSSxDQUFDSixPQUFPO1FBQ1IsSUFBSWtCLG1CQUFtQk0sT0FBTztZQUMxQixNQUFNTjtRQUNWO1FBQ0EsTUFBTUksU0FBU0MsY0FBY0w7SUFDakM7QUFDSjtBQUNBbkIsY0FBYyxHQUFHSTtBQUNqQjs7Ozs7Ozs7OztDQVVDLEdBQ0QsU0FBU0QsYUFBYUYsS0FBSyxFQUFFMkIsTUFBTSxFQUFFQyxjQUFjLGtCQUFrQixFQUNyRSxnRUFBZ0U7QUFDaEVMLGVBQWVuQixjQUFjO0lBQ3pCLElBQUk7UUFDQyxJQUFHQyxjQUFjRixNQUFNLEVBQUVILE9BQU8yQjtJQUNyQyxFQUNBLE9BQU9uQixPQUFPO1FBQ1YsTUFBTWMsU0FBU0MsY0FBYyxDQUFDLEVBQUVLLFlBQVksRUFBRSxFQUFFWCxnQkFBZ0JULE9BQU8sQ0FBQyxDQUFDO0lBQzdFO0FBQ0o7QUFDQVQsb0JBQW9CLEdBQUdHO0FBQ3ZCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkMsR0FDRCxTQUFTRCxpQkFBaUI0QixPQUFPO0lBQzdCLE1BQU0sSUFBSUwsTUFBTTtBQUNwQjtBQUNBekIsd0JBQXdCLEdBQUdFLGtCQUMzQixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGFibGUtcm91dGVyLXdlYi8uL25vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvYXNzZXJ0LmpzP2FlYzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFzc2VydEV4aGF1c3RpdmUgPSBleHBvcnRzLmFzc2VydFN0cnVjdCA9IGV4cG9ydHMuYXNzZXJ0ID0gZXhwb3J0cy5Bc3NlcnRpb25FcnJvciA9IHZvaWQgMDtcbmNvbnN0IHN1cGVyc3RydWN0XzEgPSByZXF1aXJlKFwic3VwZXJzdHJ1Y3RcIik7XG4vKipcbiAqIFR5cGUgZ3VhcmQgZm9yIGRldGVybWluaW5nIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIGVycm9yIG9iamVjdCB3aXRoIGFcbiAqIGBtZXNzYWdlYCBwcm9wZXJ0eSwgc3VjaCBhcyBhbiBpbnN0YW5jZSBvZiBFcnJvci5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybnMgVHJ1ZSBvciBmYWxzZSwgZGVwZW5kaW5nIG9uIHRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGlzRXJyb3JXaXRoTWVzc2FnZShlcnJvcikge1xuICAgIHJldHVybiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIGVycm9yICE9PSBudWxsICYmICdtZXNzYWdlJyBpbiBlcnJvcjtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGNvbnN0cnVjdG9yLCBpLmUuLCBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIGNhbGxlZCB3aXRoXG4gKiB0aGUgYG5ld2Aga2V5d29yZC5cbiAqXG4gKiBAcGFyYW0gZm4gLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGEgY29uc3RydWN0b3IsIG9yIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0NvbnN0cnVjdGFibGUoZm4pIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIEJvb2xlYW4odHlwZW9mICgoX2IgPSAoX2EgPSBmbiA9PT0gbnVsbCB8fCBmbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm4ucHJvdG90eXBlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29uc3RydWN0b3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5uYW1lKSA9PT0gJ3N0cmluZycpO1xufVxuLyoqXG4gKiBHZXQgdGhlIGVycm9yIG1lc3NhZ2UgZnJvbSBhbiB1bmtub3duIGVycm9yIG9iamVjdC4gSWYgdGhlIGVycm9yIG9iamVjdCBoYXNcbiAqIGEgYG1lc3NhZ2VgIHByb3BlcnR5LCB0aGF0IHByb3BlcnR5IGlzIHJldHVybmVkLiBPdGhlcndpc2UsIHRoZSBzdHJpbmdpZmllZFxuICogZXJyb3Igb2JqZWN0IGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciBvYmplY3QgdG8gZ2V0IHRoZSBtZXNzYWdlIGZyb20uXG4gKiBAcmV0dXJucyBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlKGVycm9yKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGlzRXJyb3JXaXRoTWVzc2FnZShlcnJvcikgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAvLyBJZiB0aGUgZXJyb3IgZW5kcyB3aXRoIGEgcGVyaW9kLCByZW1vdmUgaXQsIGFzIHdlJ2xsIGFkZCBvdXIgb3duIHBlcmlvZC5cbiAgICBpZiAobWVzc2FnZS5lbmRzV2l0aCgnLicpKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlLnNsaWNlKDAsIC0xKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG59XG4vKipcbiAqIEluaXRpYWxpc2UgYW4ge0BsaW5rIEFzc2VydGlvbkVycm9yQ29uc3RydWN0b3J9IGVycm9yLlxuICpcbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdXNlLlxuICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqIEByZXR1cm5zIFRoZSBlcnJvciBvYmplY3QuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmZ1bmN0aW9uIGdldEVycm9yKEVycm9yV3JhcHBlciwgbWVzc2FnZSkge1xuICAgIGlmIChpc0NvbnN0cnVjdGFibGUoRXJyb3JXcmFwcGVyKSkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yV3JhcHBlcih7XG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIEVycm9yV3JhcHBlcih7XG4gICAgICAgIG1lc3NhZ2UsXG4gICAgfSk7XG59XG4vKipcbiAqIFRoZSBkZWZhdWx0IGVycm9yIGNsYXNzIHRoYXQgaXMgdGhyb3duIGlmIGFuIGFzc2VydGlvbiBmYWlscy5cbiAqL1xuY2xhc3MgQXNzZXJ0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zLm1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmNvZGUgPSAnRVJSX0FTU0VSVElPTic7XG4gICAgfVxufVxuZXhwb3J0cy5Bc3NlcnRpb25FcnJvciA9IEFzc2VydGlvbkVycm9yO1xuLyoqXG4gKiBTYW1lIGFzIE5vZGUuanMgYXNzZXJ0LlxuICogSWYgdGhlIHZhbHVlIGlzIGZhbHN5LCB0aHJvd3MgYW4gZXJyb3IsIGRvZXMgbm90aGluZyBvdGhlcndpc2UuXG4gKlxuICogQHRocm93cyB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9IElmIHZhbHVlIGlzIGZhbHN5LlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHRlc3QgdGhhdCBzaG91bGQgYmUgdHJ1dGh5IHRvIHBhc3MuXG4gKiBAcGFyYW0gbWVzc2FnZSAtIE1lc3NhZ2UgdG8gYmUgcGFzc2VkIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0gb3IgYW5cbiAqIHtAbGluayBFcnJvcn0gaW5zdGFuY2UgdG8gdGhyb3cuXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LiBJZiBhIGN1c3RvbSBlcnJvciBjbGFzcyBpcyBwcm92aWRlZCBmb3JcbiAqIHRoZSBgbWVzc2FnZWAgYXJndW1lbnQsIHRoaXMgYXJndW1lbnQgaXMgaWdub3JlZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KHZhbHVlLCBtZXNzYWdlID0gJ0Fzc2VydGlvbiBmYWlsZWQuJywgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIgPSBBc3NlcnRpb25FcnJvcikge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBnZXRFcnJvcihFcnJvcldyYXBwZXIsIG1lc3NhZ2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzZXJ0ID0gYXNzZXJ0O1xuLyoqXG4gKiBBc3NlcnQgYSB2YWx1ZSBhZ2FpbnN0IGEgU3VwZXJzdHJ1Y3Qgc3RydWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB2YWxpZGF0ZS5cbiAqIEBwYXJhbSBzdHJ1Y3QgLSBUaGUgc3RydWN0IHRvIHZhbGlkYXRlIGFnYWluc3QuXG4gKiBAcGFyYW0gZXJyb3JQcmVmaXggLSBBIHByZWZpeCB0byBhZGQgdG8gdGhlIGVycm9yIG1lc3NhZ2UuIERlZmF1bHRzIHRvXG4gKiBcIkFzc2VydGlvbiBmYWlsZWRcIi5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFN0cnVjdCh2YWx1ZSwgc3RydWN0LCBlcnJvclByZWZpeCA9ICdBc3NlcnRpb24gZmFpbGVkJywgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIgPSBBc3NlcnRpb25FcnJvcikge1xuICAgIHRyeSB7XG4gICAgICAgICgwLCBzdXBlcnN0cnVjdF8xLmFzc2VydCkodmFsdWUsIHN0cnVjdCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBnZXRFcnJvcihFcnJvcldyYXBwZXIsIGAke2Vycm9yUHJlZml4fTogJHtnZXRFcnJvck1lc3NhZ2UoZXJyb3IpfS5gKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydFN0cnVjdCA9IGFzc2VydFN0cnVjdDtcbi8qKlxuICogVXNlIGluIHRoZSBkZWZhdWx0IGNhc2Ugb2YgYSBzd2l0Y2ggdGhhdCB5b3Ugd2FudCB0byBiZSBmdWxseSBleGhhdXN0aXZlLlxuICogVXNpbmcgdGhpcyBmdW5jdGlvbiBmb3JjZXMgdGhlIGNvbXBpbGVyIHRvIGVuZm9yY2UgZXhoYXVzdGl2aXR5IGR1cmluZ1xuICogY29tcGlsZS10aW1lLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqIGNvbnN0IG51bWJlciA9IDE7XG4gKiBzd2l0Y2ggKG51bWJlcikge1xuICogICBjYXNlIDA6XG4gKiAgICAgLi4uXG4gKiAgIGNhc2UgMTpcbiAqICAgICAuLi5cbiAqICAgZGVmYXVsdDpcbiAqICAgICBhc3NlcnRFeGhhdXN0aXZlKHNuYXBQcmVmaXgpO1xuICogfVxuICogYGBgXG4gKiBAcGFyYW0gX29iamVjdCAtIFRoZSBvYmplY3Qgb24gd2hpY2ggdGhlIHN3aXRjaCBpcyBiZWluZyBvcGVyYXRlZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0RXhoYXVzdGl2ZShfb2JqZWN0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJyYW5jaCByZWFjaGVkLiBTaG91bGQgYmUgZGV0ZWN0ZWQgZHVyaW5nIGNvbXBpbGF0aW9uLicpO1xufVxuZXhwb3J0cy5hc3NlcnRFeGhhdXN0aXZlID0gYXNzZXJ0RXhoYXVzdGl2ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc2VydC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJhc3NlcnRFeGhhdXN0aXZlIiwiYXNzZXJ0U3RydWN0IiwiYXNzZXJ0IiwiQXNzZXJ0aW9uRXJyb3IiLCJzdXBlcnN0cnVjdF8xIiwicmVxdWlyZSIsImlzRXJyb3JXaXRoTWVzc2FnZSIsImVycm9yIiwiaXNDb25zdHJ1Y3RhYmxlIiwiZm4iLCJfYSIsIl9iIiwiQm9vbGVhbiIsInByb3RvdHlwZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsImdldEVycm9yTWVzc2FnZSIsIm1lc3NhZ2UiLCJTdHJpbmciLCJlbmRzV2l0aCIsInNsaWNlIiwiZ2V0RXJyb3IiLCJFcnJvcldyYXBwZXIiLCJFcnJvciIsIm9wdGlvbnMiLCJjb2RlIiwic3RydWN0IiwiZXJyb3JQcmVmaXgiLCJfb2JqZWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/assert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/base64.js":
/*!************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/base64.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.base64 = void 0;\nconst superstruct_1 = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\nconst assert_1 = __webpack_require__(/*! ./assert */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/assert.js\");\n/**\n * Ensure that a provided string-based struct is valid base64.\n *\n * @param struct - The string based struct.\n * @param options - Optional options to specialize base64 validation. See {@link Base64Options} documentation.\n * @returns A superstruct validating base64.\n */ const base64 = (struct, options = {})=>{\n    var _a, _b;\n    const paddingRequired = (_a = options.paddingRequired) !== null && _a !== void 0 ? _a : false;\n    const characterSet = (_b = options.characterSet) !== null && _b !== void 0 ? _b : \"base64\";\n    let letters;\n    if (characterSet === \"base64\") {\n        letters = String.raw`[A-Za-z0-9+\\/]`;\n    } else {\n        (0, assert_1.assert)(characterSet === \"base64url\");\n        letters = String.raw`[-_A-Za-z0-9]`;\n    }\n    let re;\n    if (paddingRequired) {\n        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{3}=|${letters}{2}==)?$`, \"u\");\n    } else {\n        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{2,3}|${letters}{3}=|${letters}{2}==)?$`, \"u\");\n    }\n    return (0, superstruct_1.pattern)(struct, re);\n};\nexports.base64 = base64; //# sourceMappingURL=base64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2Jhc2U2NC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHLEtBQUs7QUFDdEIsTUFBTUcsZ0JBQWdCQyxtQkFBT0EsQ0FBQyxvRUFBYTtBQUMzQyxNQUFNQyxXQUFXRCxtQkFBT0EsQ0FBQyxvR0FBVTtBQUNuQzs7Ozs7O0NBTUMsR0FDRCxNQUFNRixTQUFTLENBQUNJLFFBQVFDLFVBQVUsQ0FBQyxDQUFDO0lBQ2hDLElBQUlDLElBQUlDO0lBQ1IsTUFBTUMsa0JBQWtCLENBQUNGLEtBQUtELFFBQVFHLGVBQWUsTUFBTSxRQUFRRixPQUFPLEtBQUssSUFBSUEsS0FBSztJQUN4RixNQUFNRyxlQUFlLENBQUNGLEtBQUtGLFFBQVFJLFlBQVksTUFBTSxRQUFRRixPQUFPLEtBQUssSUFBSUEsS0FBSztJQUNsRixJQUFJRztJQUNKLElBQUlELGlCQUFpQixVQUFVO1FBQzNCQyxVQUFVQyxPQUFPQyxHQUFHLENBQUUsY0FBYyxDQUFDO0lBQ3pDLE9BQ0s7UUFDQSxJQUFHVCxTQUFTVSxNQUFNLEVBQUVKLGlCQUFpQjtRQUN0Q0MsVUFBVUMsT0FBT0MsR0FBRyxDQUFFLGFBQWEsQ0FBQztJQUN4QztJQUNBLElBQUlFO0lBQ0osSUFBSU4saUJBQWlCO1FBQ2pCTSxLQUFLLElBQUlDLE9BQU8sQ0FBQyxJQUFJLEVBQUVMLFFBQVEsUUFBUSxFQUFFQSxRQUFRLEtBQUssRUFBRUEsUUFBUSxRQUFRLENBQUMsRUFBRTtJQUMvRSxPQUNLO1FBQ0RJLEtBQUssSUFBSUMsT0FBTyxDQUFDLElBQUksRUFBRUwsUUFBUSxRQUFRLEVBQUVBLFFBQVEsTUFBTSxFQUFFQSxRQUFRLEtBQUssRUFBRUEsUUFBUSxRQUFRLENBQUMsRUFBRTtJQUMvRjtJQUNBLE9BQU8sQ0FBQyxHQUFHVCxjQUFjZSxPQUFPLEVBQUVaLFFBQVFVO0FBQzlDO0FBQ0FoQixjQUFjLEdBQUdFLFFBQ2pCLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3N0YWJsZS1yb3V0ZXItd2ViLy4vbm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9iYXNlNjQuanM/YmVhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYmFzZTY0ID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJzdXBlcnN0cnVjdFwiKTtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcIi4vYXNzZXJ0XCIpO1xuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHByb3ZpZGVkIHN0cmluZy1iYXNlZCBzdHJ1Y3QgaXMgdmFsaWQgYmFzZTY0LlxuICpcbiAqIEBwYXJhbSBzdHJ1Y3QgLSBUaGUgc3RyaW5nIGJhc2VkIHN0cnVjdC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwgb3B0aW9ucyB0byBzcGVjaWFsaXplIGJhc2U2NCB2YWxpZGF0aW9uLiBTZWUge0BsaW5rIEJhc2U2NE9wdGlvbnN9IGRvY3VtZW50YXRpb24uXG4gKiBAcmV0dXJucyBBIHN1cGVyc3RydWN0IHZhbGlkYXRpbmcgYmFzZTY0LlxuICovXG5jb25zdCBiYXNlNjQgPSAoc3RydWN0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHBhZGRpbmdSZXF1aXJlZCA9IChfYSA9IG9wdGlvbnMucGFkZGluZ1JlcXVpcmVkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcbiAgICBjb25zdCBjaGFyYWN0ZXJTZXQgPSAoX2IgPSBvcHRpb25zLmNoYXJhY3RlclNldCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ2Jhc2U2NCc7XG4gICAgbGV0IGxldHRlcnM7XG4gICAgaWYgKGNoYXJhY3RlclNldCA9PT0gJ2Jhc2U2NCcpIHtcbiAgICAgICAgbGV0dGVycyA9IFN0cmluZy5yYXcgYFtBLVphLXowLTkrXFwvXWA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShjaGFyYWN0ZXJTZXQgPT09ICdiYXNlNjR1cmwnKTtcbiAgICAgICAgbGV0dGVycyA9IFN0cmluZy5yYXcgYFstX0EtWmEtejAtOV1gO1xuICAgIH1cbiAgICBsZXQgcmU7XG4gICAgaWYgKHBhZGRpbmdSZXF1aXJlZCkge1xuICAgICAgICByZSA9IG5ldyBSZWdFeHAoYF4oPzoke2xldHRlcnN9ezR9KSooPzoke2xldHRlcnN9ezN9PXwke2xldHRlcnN9ezJ9PT0pPyRgLCAndScpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmUgPSBuZXcgUmVnRXhwKGBeKD86JHtsZXR0ZXJzfXs0fSkqKD86JHtsZXR0ZXJzfXsyLDN9fCR7bGV0dGVyc317M309fCR7bGV0dGVyc317Mn09PSk/JGAsICd1Jyk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5wYXR0ZXJuKShzdHJ1Y3QsIHJlKTtcbn07XG5leHBvcnRzLmJhc2U2NCA9IGJhc2U2NDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2U2NC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJiYXNlNjQiLCJzdXBlcnN0cnVjdF8xIiwicmVxdWlyZSIsImFzc2VydF8xIiwic3RydWN0Iiwib3B0aW9ucyIsIl9hIiwiX2IiLCJwYWRkaW5nUmVxdWlyZWQiLCJjaGFyYWN0ZXJTZXQiLCJsZXR0ZXJzIiwiU3RyaW5nIiwicmF3IiwiYXNzZXJ0IiwicmUiLCJSZWdFeHAiLCJwYXR0ZXJuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/base64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/bytes.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/bytes.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createDataView = exports.concatBytes = exports.valueToBytes = exports.stringToBytes = exports.numberToBytes = exports.signedBigIntToBytes = exports.bigIntToBytes = exports.hexToBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToSignedBigInt = exports.bytesToBigInt = exports.bytesToHex = exports.assertIsBytes = exports.isBytes = void 0;\nconst assert_1 = __webpack_require__(/*! ./assert */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/assert.js\");\nconst hex_1 = __webpack_require__(/*! ./hex */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/hex.js\");\n// '0'.charCodeAt(0) === 48\nconst HEX_MINIMUM_NUMBER_CHARACTER = 48;\n// '9'.charCodeAt(0) === 57\nconst HEX_MAXIMUM_NUMBER_CHARACTER = 58;\nconst HEX_CHARACTER_OFFSET = 87;\n/**\n * Memoized function that returns an array to be used as a lookup table for\n * converting bytes to hexadecimal values.\n *\n * The array is created lazily and then cached for future use. The benefit of\n * this approach is that the performance of converting bytes to hex is much\n * better than if we were to call `toString(16)` on each byte.\n *\n * The downside is that the array is created once and then never garbage\n * collected. This is not a problem in practice because the array is only 256\n * elements long.\n *\n * @returns A function that returns the lookup table.\n */ function getPrecomputedHexValuesBuilder() {\n    // To avoid issues with tree shaking, we need to use a function to return the\n    // array. This is because the array is only used in the `bytesToHex` function\n    // and if we were to use a global variable, the array might be removed by the\n    // tree shaker.\n    const lookupTable = [];\n    return ()=>{\n        if (lookupTable.length === 0) {\n            for(let i = 0; i < 256; i++){\n                lookupTable.push(i.toString(16).padStart(2, \"0\"));\n            }\n        }\n        return lookupTable;\n    };\n}\n/**\n * Function implementation of the {@link getPrecomputedHexValuesBuilder}\n * function.\n */ const getPrecomputedHexValues = getPrecomputedHexValuesBuilder();\n/**\n * Check if a value is a `Uint8Array`.\n *\n * @param value - The value to check.\n * @returns Whether the value is a `Uint8Array`.\n */ function isBytes(value) {\n    return value instanceof Uint8Array;\n}\nexports.isBytes = isBytes;\n/**\n * Assert that a value is a `Uint8Array`.\n *\n * @param value - The value to check.\n * @throws If the value is not a `Uint8Array`.\n */ function assertIsBytes(value) {\n    (0, assert_1.assert)(isBytes(value), \"Value must be a Uint8Array.\");\n}\nexports.assertIsBytes = assertIsBytes;\n/**\n * Convert a `Uint8Array` to a hexadecimal string.\n *\n * @param bytes - The bytes to convert to a hexadecimal string.\n * @returns The hexadecimal string.\n */ function bytesToHex(bytes) {\n    assertIsBytes(bytes);\n    if (bytes.length === 0) {\n        return \"0x\";\n    }\n    const lookupTable = getPrecomputedHexValues();\n    const hexadecimal = new Array(bytes.length);\n    for(let i = 0; i < bytes.length; i++){\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        hexadecimal[i] = lookupTable[bytes[i]];\n    }\n    return (0, hex_1.add0x)(hexadecimal.join(\"\"));\n}\nexports.bytesToHex = bytesToHex;\n/**\n * Convert a `Uint8Array` to a `bigint`.\n *\n * To convert a `Uint8Array` to a `number` instead, use {@link bytesToNumber}.\n * To convert a two's complement encoded `Uint8Array` to a `bigint`, use\n * {@link bytesToSignedBigInt}.\n *\n * @param bytes - The bytes to convert to a `bigint`.\n * @returns The `bigint`.\n */ function bytesToBigInt(bytes) {\n    assertIsBytes(bytes);\n    const hexadecimal = bytesToHex(bytes);\n    return BigInt(hexadecimal);\n}\nexports.bytesToBigInt = bytesToBigInt;\n/**\n * Convert a `Uint8Array` to a signed `bigint`. This assumes that the bytes are\n * encoded in two's complement.\n *\n * To convert a `Uint8Array` to an unsigned `bigint` instead, use\n * {@link bytesToBigInt}.\n *\n * @see https://en.wikipedia.org/wiki/Two%27s_complement\n * @param bytes - The bytes to convert to a signed `bigint`.\n * @returns The signed `bigint`.\n */ function bytesToSignedBigInt(bytes) {\n    assertIsBytes(bytes);\n    let value = BigInt(0);\n    for (const byte of bytes){\n        // eslint-disable-next-line no-bitwise\n        value = (value << BigInt(8)) + BigInt(byte);\n    }\n    return BigInt.asIntN(bytes.length * 8, value);\n}\nexports.bytesToSignedBigInt = bytesToSignedBigInt;\n/**\n * Convert a `Uint8Array` to a `number`.\n *\n * To convert a `Uint8Array` to a `bigint` instead, use {@link bytesToBigInt}.\n *\n * @param bytes - The bytes to convert to a number.\n * @returns The number.\n * @throws If the resulting number is not a safe integer.\n */ function bytesToNumber(bytes) {\n    assertIsBytes(bytes);\n    const bigint = bytesToBigInt(bytes);\n    (0, assert_1.assert)(bigint <= BigInt(Number.MAX_SAFE_INTEGER), \"Number is not a safe integer. Use `bytesToBigInt` instead.\");\n    return Number(bigint);\n}\nexports.bytesToNumber = bytesToNumber;\n/**\n * Convert a UTF-8 encoded `Uint8Array` to a `string`.\n *\n * @param bytes - The bytes to convert to a string.\n * @returns The string.\n */ function bytesToString(bytes) {\n    assertIsBytes(bytes);\n    return new TextDecoder().decode(bytes);\n}\nexports.bytesToString = bytesToString;\n/**\n * Convert a hexadecimal string to a `Uint8Array`. The string can optionally be\n * prefixed with `0x`. It accepts even and odd length strings.\n *\n * If the value is \"0x\", an empty `Uint8Array` is returned.\n *\n * @param value - The hexadecimal string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */ function hexToBytes(value) {\n    var _a;\n    // \"0x\" is often used as empty byte array.\n    if (((_a = value === null || value === void 0 ? void 0 : value.toLowerCase) === null || _a === void 0 ? void 0 : _a.call(value)) === \"0x\") {\n        return new Uint8Array();\n    }\n    (0, hex_1.assertIsHexString)(value);\n    // Remove the `0x` prefix if it exists, and pad the string to have an even\n    // number of characters.\n    const strippedValue = (0, hex_1.remove0x)(value).toLowerCase();\n    const normalizedValue = strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;\n    const bytes = new Uint8Array(normalizedValue.length / 2);\n    for(let i = 0; i < bytes.length; i++){\n        // While this is not the prettiest way to convert a hexadecimal string to a\n        // `Uint8Array`, it is a lot faster than using `parseInt` to convert each\n        // character.\n        const c1 = normalizedValue.charCodeAt(i * 2);\n        const c2 = normalizedValue.charCodeAt(i * 2 + 1);\n        const n1 = c1 - (c1 < HEX_MAXIMUM_NUMBER_CHARACTER ? HEX_MINIMUM_NUMBER_CHARACTER : HEX_CHARACTER_OFFSET);\n        const n2 = c2 - (c2 < HEX_MAXIMUM_NUMBER_CHARACTER ? HEX_MINIMUM_NUMBER_CHARACTER : HEX_CHARACTER_OFFSET);\n        bytes[i] = n1 * 16 + n2;\n    }\n    return bytes;\n}\nexports.hexToBytes = hexToBytes;\n/**\n * Convert a `bigint` to a `Uint8Array`.\n *\n * This assumes that the `bigint` is an unsigned integer. To convert a signed\n * `bigint` instead, use {@link signedBigIntToBytes}.\n *\n * @param value - The bigint to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */ function bigIntToBytes(value) {\n    (0, assert_1.assert)(typeof value === \"bigint\", \"Value must be a bigint.\");\n    (0, assert_1.assert)(value >= BigInt(0), \"Value must be a non-negative bigint.\");\n    const hexadecimal = value.toString(16);\n    return hexToBytes(hexadecimal);\n}\nexports.bigIntToBytes = bigIntToBytes;\n/**\n * Check if a `bigint` fits in a certain number of bytes.\n *\n * @param value - The `bigint` to check.\n * @param bytes - The number of bytes.\n * @returns Whether the `bigint` fits in the number of bytes.\n */ function bigIntFits(value, bytes) {\n    (0, assert_1.assert)(bytes > 0);\n    /* eslint-disable no-bitwise */ const mask = value >> BigInt(31);\n    return !((~value & mask) + (value & ~mask) >> BigInt(bytes * 8 + ~0));\n/* eslint-enable no-bitwise */ }\n/**\n * Convert a signed `bigint` to a `Uint8Array`. This uses two's complement\n * encoding to represent negative numbers.\n *\n * To convert an unsigned `bigint` to a `Uint8Array` instead, use\n * {@link bigIntToBytes}.\n *\n * @see https://en.wikipedia.org/wiki/Two%27s_complement\n * @param value - The number to convert to bytes.\n * @param byteLength - The length of the resulting `Uint8Array`. If the number\n * is larger than the maximum value that can be represented by the given length,\n * an error is thrown.\n * @returns The bytes as `Uint8Array`.\n */ function signedBigIntToBytes(value, byteLength) {\n    (0, assert_1.assert)(typeof value === \"bigint\", \"Value must be a bigint.\");\n    (0, assert_1.assert)(typeof byteLength === \"number\", \"Byte length must be a number.\");\n    (0, assert_1.assert)(byteLength > 0, \"Byte length must be greater than 0.\");\n    (0, assert_1.assert)(bigIntFits(value, byteLength), \"Byte length is too small to represent the given value.\");\n    // ESLint doesn't like mutating function parameters, so to avoid having to\n    // disable the rule, we create a new variable.\n    let numberValue = value;\n    const bytes = new Uint8Array(byteLength);\n    for(let i = 0; i < bytes.length; i++){\n        bytes[i] = Number(BigInt.asUintN(8, numberValue));\n        // eslint-disable-next-line no-bitwise\n        numberValue >>= BigInt(8);\n    }\n    return bytes.reverse();\n}\nexports.signedBigIntToBytes = signedBigIntToBytes;\n/**\n * Convert a `number` to a `Uint8Array`.\n *\n * @param value - The number to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n * @throws If the number is not a safe integer.\n */ function numberToBytes(value) {\n    (0, assert_1.assert)(typeof value === \"number\", \"Value must be a number.\");\n    (0, assert_1.assert)(value >= 0, \"Value must be a non-negative number.\");\n    (0, assert_1.assert)(Number.isSafeInteger(value), \"Value is not a safe integer. Use `bigIntToBytes` instead.\");\n    const hexadecimal = value.toString(16);\n    return hexToBytes(hexadecimal);\n}\nexports.numberToBytes = numberToBytes;\n/**\n * Convert a `string` to a UTF-8 encoded `Uint8Array`.\n *\n * @param value - The string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */ function stringToBytes(value) {\n    (0, assert_1.assert)(typeof value === \"string\", \"Value must be a string.\");\n    return new TextEncoder().encode(value);\n}\nexports.stringToBytes = stringToBytes;\n/**\n * Convert a byte-like value to a `Uint8Array`. The value can be a `Uint8Array`,\n * a `bigint`, a `number`, or a `string`.\n *\n * This will attempt to guess the type of the value based on its type and\n * contents. For more control over the conversion, use the more specific\n * conversion functions, such as {@link hexToBytes} or {@link stringToBytes}.\n *\n * If the value is a `string`, and it is prefixed with `0x`, it will be\n * interpreted as a hexadecimal string. Otherwise, it will be interpreted as a\n * UTF-8 string. To convert a hexadecimal string to bytes without interpreting\n * it as a UTF-8 string, use {@link hexToBytes} instead.\n *\n * If the value is a `bigint`, it is assumed to be unsigned. To convert a signed\n * `bigint` to bytes, use {@link signedBigIntToBytes} instead.\n *\n * If the value is a `Uint8Array`, it will be returned as-is.\n *\n * @param value - The value to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */ function valueToBytes(value) {\n    if (typeof value === \"bigint\") {\n        return bigIntToBytes(value);\n    }\n    if (typeof value === \"number\") {\n        return numberToBytes(value);\n    }\n    if (typeof value === \"string\") {\n        if (value.startsWith(\"0x\")) {\n            return hexToBytes(value);\n        }\n        return stringToBytes(value);\n    }\n    if (isBytes(value)) {\n        return value;\n    }\n    throw new TypeError(`Unsupported value type: \"${typeof value}\".`);\n}\nexports.valueToBytes = valueToBytes;\n/**\n * Concatenate multiple byte-like values into a single `Uint8Array`. The values\n * can be `Uint8Array`, `bigint`, `number`, or `string`. This uses\n * {@link valueToBytes} under the hood to convert each value to bytes. Refer to\n * the documentation of that function for more information.\n *\n * @param values - The values to concatenate.\n * @returns The concatenated bytes as `Uint8Array`.\n */ function concatBytes(values) {\n    const normalizedValues = new Array(values.length);\n    let byteLength = 0;\n    for(let i = 0; i < values.length; i++){\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const value = valueToBytes(values[i]);\n        normalizedValues[i] = value;\n        byteLength += value.length;\n    }\n    const bytes = new Uint8Array(byteLength);\n    for(let i = 0, offset = 0; i < normalizedValues.length; i++){\n        // While we could simply spread the values into an array and use\n        // `Uint8Array.from`, that is a lot slower than using `Uint8Array.set`.\n        bytes.set(normalizedValues[i], offset);\n        offset += normalizedValues[i].length;\n    }\n    return bytes;\n}\nexports.concatBytes = concatBytes;\n/**\n * Create a {@link DataView} from a {@link Uint8Array}. This is a convenience\n * function that avoids having to create a {@link DataView} manually, which\n * requires passing the `byteOffset` and `byteLength` parameters every time.\n *\n * Not passing the `byteOffset` and `byteLength` parameters can result in\n * unexpected behavior when the {@link Uint8Array} is a view of a larger\n * {@link ArrayBuffer}, e.g., when using {@link Uint8Array.subarray}.\n *\n * This function also supports Node.js {@link Buffer}s.\n *\n * @example\n * ```typescript\n * const bytes = new Uint8Array([1, 2, 3]);\n *\n * // This is equivalent to:\n * // const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n * const dataView = createDataView(bytes);\n * ```\n * @param bytes - The bytes to create the {@link DataView} from.\n * @returns The {@link DataView}.\n */ function createDataView(bytes) {\n    // To maintain compatibility with Node.js, we need to check if the bytes are\n    // a Buffer. If so, we need to slice the buffer to get the underlying\n    // ArrayBuffer.\n    // eslint-disable-next-line no-restricted-globals\n    if (typeof Buffer !== \"undefined\" && bytes instanceof Buffer) {\n        const buffer = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);\n        return new DataView(buffer);\n    }\n    return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n}\nexports.createDataView = createDataView; //# sourceMappingURL=bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2J5dGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxzQkFBc0IsR0FBR0EsbUJBQW1CLEdBQUdBLG9CQUFvQixHQUFHQSxxQkFBcUIsR0FBR0EscUJBQXFCLEdBQUdBLDJCQUEyQixHQUFHQSxxQkFBcUIsR0FBR0Esa0JBQWtCLEdBQUdBLHFCQUFxQixHQUFHQSxxQkFBcUIsR0FBR0EsMkJBQTJCLEdBQUdBLHFCQUFxQixHQUFHQSxrQkFBa0IsR0FBR0EscUJBQXFCLEdBQUdBLGVBQWUsR0FBRyxLQUFLO0FBQzNXLE1BQU1pQixXQUFXQyxtQkFBT0EsQ0FBQyxvR0FBVTtBQUNuQyxNQUFNQyxRQUFRRCxtQkFBT0EsQ0FBQyw4RkFBTztBQUM3QiwyQkFBMkI7QUFDM0IsTUFBTUUsK0JBQStCO0FBQ3JDLDJCQUEyQjtBQUMzQixNQUFNQywrQkFBK0I7QUFDckMsTUFBTUMsdUJBQXVCO0FBQzdCOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDRCxTQUFTQztJQUNMLDZFQUE2RTtJQUM3RSw2RUFBNkU7SUFDN0UsNkVBQTZFO0lBQzdFLGVBQWU7SUFDZixNQUFNQyxjQUFjLEVBQUU7SUFDdEIsT0FBTztRQUNILElBQUlBLFlBQVlDLE1BQU0sS0FBSyxHQUFHO1lBQzFCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJLEtBQUtBLElBQUs7Z0JBQzFCRixZQUFZRyxJQUFJLENBQUNELEVBQUVFLFFBQVEsQ0FBQyxJQUFJQyxRQUFRLENBQUMsR0FBRztZQUNoRDtRQUNKO1FBQ0EsT0FBT0w7SUFDWDtBQUNKO0FBQ0E7OztDQUdDLEdBQ0QsTUFBTU0sMEJBQTBCUDtBQUNoQzs7Ozs7Q0FLQyxHQUNELFNBQVNQLFFBQVFmLEtBQUs7SUFDbEIsT0FBT0EsaUJBQWlCOEI7QUFDNUI7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QUFJLE9BQU93QyxXQUFXLGVBQWV4QyxpQkFBaUJ3QyxRQUFRO1FBQzFELE1BQU1DLFNBQVN6QyxNQUFNeUMsTUFBTSxDQUFDQyxLQUFLLENBQUMxQyxNQUFNMkMsVUFBVSxFQUFFM0MsTUFBTTJDLFVBQVUsR0FBRzNDLE1BQU0yQixVQUFVO1FBQ3ZGLE9BQU8sSUFBSWlCLFNBQVNIO0lBQ3hCO0lBQ0EsT0FBTyxJQUFJRyxTQUFTNUMsTUFBTXlDLE1BQU0sRUFBRXpDLE1BQU0yQyxVQUFVLEVBQUUzQyxNQUFNMkIsVUFBVTtBQUN4RTtBQUNBNUQsc0JBQXNCLEdBQUdFLGdCQUN6QixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGFibGUtcm91dGVyLXdlYi8uL25vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvYnl0ZXMuanM/ZDA4YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlRGF0YVZpZXcgPSBleHBvcnRzLmNvbmNhdEJ5dGVzID0gZXhwb3J0cy52YWx1ZVRvQnl0ZXMgPSBleHBvcnRzLnN0cmluZ1RvQnl0ZXMgPSBleHBvcnRzLm51bWJlclRvQnl0ZXMgPSBleHBvcnRzLnNpZ25lZEJpZ0ludFRvQnl0ZXMgPSBleHBvcnRzLmJpZ0ludFRvQnl0ZXMgPSBleHBvcnRzLmhleFRvQnl0ZXMgPSBleHBvcnRzLmJ5dGVzVG9TdHJpbmcgPSBleHBvcnRzLmJ5dGVzVG9OdW1iZXIgPSBleHBvcnRzLmJ5dGVzVG9TaWduZWRCaWdJbnQgPSBleHBvcnRzLmJ5dGVzVG9CaWdJbnQgPSBleHBvcnRzLmJ5dGVzVG9IZXggPSBleHBvcnRzLmFzc2VydElzQnl0ZXMgPSBleHBvcnRzLmlzQnl0ZXMgPSB2b2lkIDA7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydFwiKTtcbmNvbnN0IGhleF8xID0gcmVxdWlyZShcIi4vaGV4XCIpO1xuLy8gJzAnLmNoYXJDb2RlQXQoMCkgPT09IDQ4XG5jb25zdCBIRVhfTUlOSU1VTV9OVU1CRVJfQ0hBUkFDVEVSID0gNDg7XG4vLyAnOScuY2hhckNvZGVBdCgwKSA9PT0gNTdcbmNvbnN0IEhFWF9NQVhJTVVNX05VTUJFUl9DSEFSQUNURVIgPSA1ODtcbmNvbnN0IEhFWF9DSEFSQUNURVJfT0ZGU0VUID0gODc7XG4vKipcbiAqIE1lbW9pemVkIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBhcnJheSB0byBiZSB1c2VkIGFzIGEgbG9va3VwIHRhYmxlIGZvclxuICogY29udmVydGluZyBieXRlcyB0byBoZXhhZGVjaW1hbCB2YWx1ZXMuXG4gKlxuICogVGhlIGFycmF5IGlzIGNyZWF0ZWQgbGF6aWx5IGFuZCB0aGVuIGNhY2hlZCBmb3IgZnV0dXJlIHVzZS4gVGhlIGJlbmVmaXQgb2ZcbiAqIHRoaXMgYXBwcm9hY2ggaXMgdGhhdCB0aGUgcGVyZm9ybWFuY2Ugb2YgY29udmVydGluZyBieXRlcyB0byBoZXggaXMgbXVjaFxuICogYmV0dGVyIHRoYW4gaWYgd2Ugd2VyZSB0byBjYWxsIGB0b1N0cmluZygxNilgIG9uIGVhY2ggYnl0ZS5cbiAqXG4gKiBUaGUgZG93bnNpZGUgaXMgdGhhdCB0aGUgYXJyYXkgaXMgY3JlYXRlZCBvbmNlIGFuZCB0aGVuIG5ldmVyIGdhcmJhZ2VcbiAqIGNvbGxlY3RlZC4gVGhpcyBpcyBub3QgYSBwcm9ibGVtIGluIHByYWN0aWNlIGJlY2F1c2UgdGhlIGFycmF5IGlzIG9ubHkgMjU2XG4gKiBlbGVtZW50cyBsb25nLlxuICpcbiAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBsb29rdXAgdGFibGUuXG4gKi9cbmZ1bmN0aW9uIGdldFByZWNvbXB1dGVkSGV4VmFsdWVzQnVpbGRlcigpIHtcbiAgICAvLyBUbyBhdm9pZCBpc3N1ZXMgd2l0aCB0cmVlIHNoYWtpbmcsIHdlIG5lZWQgdG8gdXNlIGEgZnVuY3Rpb24gdG8gcmV0dXJuIHRoZVxuICAgIC8vIGFycmF5LiBUaGlzIGlzIGJlY2F1c2UgdGhlIGFycmF5IGlzIG9ubHkgdXNlZCBpbiB0aGUgYGJ5dGVzVG9IZXhgIGZ1bmN0aW9uXG4gICAgLy8gYW5kIGlmIHdlIHdlcmUgdG8gdXNlIGEgZ2xvYmFsIHZhcmlhYmxlLCB0aGUgYXJyYXkgbWlnaHQgYmUgcmVtb3ZlZCBieSB0aGVcbiAgICAvLyB0cmVlIHNoYWtlci5cbiAgICBjb25zdCBsb29rdXBUYWJsZSA9IFtdO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChsb29rdXBUYWJsZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsb29rdXBUYWJsZS5wdXNoKGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb29rdXBUYWJsZTtcbiAgICB9O1xufVxuLyoqXG4gKiBGdW5jdGlvbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUge0BsaW5rIGdldFByZWNvbXB1dGVkSGV4VmFsdWVzQnVpbGRlcn1cbiAqIGZ1bmN0aW9uLlxuICovXG5jb25zdCBnZXRQcmVjb21wdXRlZEhleFZhbHVlcyA9IGdldFByZWNvbXB1dGVkSGV4VmFsdWVzQnVpbGRlcigpO1xuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBpc0J5dGVzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheTtcbn1cbmV4cG9ydHMuaXNCeXRlcyA9IGlzQnl0ZXM7XG4vKipcbiAqIEFzc2VydCB0aGF0IGEgdmFsdWUgaXMgYSBgVWludDhBcnJheWAuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0J5dGVzKHZhbHVlKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoaXNCeXRlcyh2YWx1ZSksICdWYWx1ZSBtdXN0IGJlIGEgVWludDhBcnJheS4nKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNCeXRlcyA9IGFzc2VydElzQnl0ZXM7XG4vKipcbiAqIENvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgYXNzZXJ0SXNCeXRlcyhieXRlcyk7XG4gICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJzB4JztcbiAgICB9XG4gICAgY29uc3QgbG9va3VwVGFibGUgPSBnZXRQcmVjb21wdXRlZEhleFZhbHVlcygpO1xuICAgIGNvbnN0IGhleGFkZWNpbWFsID0gbmV3IEFycmF5KGJ5dGVzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICBoZXhhZGVjaW1hbFtpXSA9IGxvb2t1cFRhYmxlW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBoZXhfMS5hZGQweCkoaGV4YWRlY2ltYWwuam9pbignJykpO1xufVxuZXhwb3J0cy5ieXRlc1RvSGV4ID0gYnl0ZXNUb0hleDtcbi8qKlxuICogQ29udmVydCBhIGBVaW50OEFycmF5YCB0byBhIGBiaWdpbnRgLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBgbnVtYmVyYCBpbnN0ZWFkLCB1c2Uge0BsaW5rIGJ5dGVzVG9OdW1iZXJ9LlxuICogVG8gY29udmVydCBhIHR3bydzIGNvbXBsZW1lbnQgZW5jb2RlZCBgVWludDhBcnJheWAgdG8gYSBgYmlnaW50YCwgdXNlXG4gKiB7QGxpbmsgYnl0ZXNUb1NpZ25lZEJpZ0ludH0uXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBgYmlnaW50YC5cbiAqIEByZXR1cm5zIFRoZSBgYmlnaW50YC5cbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb0JpZ0ludChieXRlcykge1xuICAgIGFzc2VydElzQnl0ZXMoYnl0ZXMpO1xuICAgIGNvbnN0IGhleGFkZWNpbWFsID0gYnl0ZXNUb0hleChieXRlcyk7XG4gICAgcmV0dXJuIEJpZ0ludChoZXhhZGVjaW1hbCk7XG59XG5leHBvcnRzLmJ5dGVzVG9CaWdJbnQgPSBieXRlc1RvQmlnSW50O1xuLyoqXG4gKiBDb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGEgc2lnbmVkIGBiaWdpbnRgLiBUaGlzIGFzc3VtZXMgdGhhdCB0aGUgYnl0ZXMgYXJlXG4gKiBlbmNvZGVkIGluIHR3bydzIGNvbXBsZW1lbnQuXG4gKlxuICogVG8gY29udmVydCBhIGBVaW50OEFycmF5YCB0byBhbiB1bnNpZ25lZCBgYmlnaW50YCBpbnN0ZWFkLCB1c2VcbiAqIHtAbGluayBieXRlc1RvQmlnSW50fS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1R3byUyN3NfY29tcGxlbWVudFxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBzaWduZWQgYGJpZ2ludGAuXG4gKiBAcmV0dXJucyBUaGUgc2lnbmVkIGBiaWdpbnRgLlxuICovXG5mdW5jdGlvbiBieXRlc1RvU2lnbmVkQmlnSW50KGJ5dGVzKSB7XG4gICAgYXNzZXJ0SXNCeXRlcyhieXRlcyk7XG4gICAgbGV0IHZhbHVlID0gQmlnSW50KDApO1xuICAgIGZvciAoY29uc3QgYnl0ZSBvZiBieXRlcykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSA8PCBCaWdJbnQoOCkpICsgQmlnSW50KGJ5dGUpO1xuICAgIH1cbiAgICByZXR1cm4gQmlnSW50LmFzSW50TihieXRlcy5sZW5ndGggKiA4LCB2YWx1ZSk7XG59XG5leHBvcnRzLmJ5dGVzVG9TaWduZWRCaWdJbnQgPSBieXRlc1RvU2lnbmVkQmlnSW50O1xuLyoqXG4gKiBDb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGEgYG51bWJlcmAuXG4gKlxuICogVG8gY29udmVydCBhIGBVaW50OEFycmF5YCB0byBhIGBiaWdpbnRgIGluc3RlYWQsIHVzZSB7QGxpbmsgYnl0ZXNUb0JpZ0ludH0uXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBudW1iZXIuXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyLlxuICogQHRocm93cyBJZiB0aGUgcmVzdWx0aW5nIG51bWJlciBpcyBub3QgYSBzYWZlIGludGVnZXIuXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXIoYnl0ZXMpIHtcbiAgICBhc3NlcnRJc0J5dGVzKGJ5dGVzKTtcbiAgICBjb25zdCBiaWdpbnQgPSBieXRlc1RvQmlnSW50KGJ5dGVzKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShiaWdpbnQgPD0gQmlnSW50KE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSwgJ051bWJlciBpcyBub3QgYSBzYWZlIGludGVnZXIuIFVzZSBgYnl0ZXNUb0JpZ0ludGAgaW5zdGVhZC4nKTtcbiAgICByZXR1cm4gTnVtYmVyKGJpZ2ludCk7XG59XG5leHBvcnRzLmJ5dGVzVG9OdW1iZXIgPSBieXRlc1RvTnVtYmVyO1xuLyoqXG4gKiBDb252ZXJ0IGEgVVRGLTggZW5jb2RlZCBgVWludDhBcnJheWAgdG8gYSBgc3RyaW5nYC5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgYnl0ZXMgdG8gY29udmVydCB0byBhIHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9TdHJpbmcoYnl0ZXMpIHtcbiAgICBhc3NlcnRJc0J5dGVzKGJ5dGVzKTtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ5dGVzKTtcbn1cbmV4cG9ydHMuYnl0ZXNUb1N0cmluZyA9IGJ5dGVzVG9TdHJpbmc7XG4vKipcbiAqIENvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBgVWludDhBcnJheWAuIFRoZSBzdHJpbmcgY2FuIG9wdGlvbmFsbHkgYmVcbiAqIHByZWZpeGVkIHdpdGggYDB4YC4gSXQgYWNjZXB0cyBldmVuIGFuZCBvZGQgbGVuZ3RoIHN0cmluZ3MuXG4gKlxuICogSWYgdGhlIHZhbHVlIGlzIFwiMHhcIiwgYW4gZW1wdHkgYFVpbnQ4QXJyYXlgIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGhleFRvQnl0ZXModmFsdWUpIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gXCIweFwiIGlzIG9mdGVuIHVzZWQgYXMgZW1wdHkgYnl0ZSBhcnJheS5cbiAgICBpZiAoKChfYSA9IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS50b0xvd2VyQ2FzZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodmFsdWUpKSA9PT0gJzB4Jykge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICB9XG4gICAgKDAsIGhleF8xLmFzc2VydElzSGV4U3RyaW5nKSh2YWx1ZSk7XG4gICAgLy8gUmVtb3ZlIHRoZSBgMHhgIHByZWZpeCBpZiBpdCBleGlzdHMsIGFuZCBwYWQgdGhlIHN0cmluZyB0byBoYXZlIGFuIGV2ZW5cbiAgICAvLyBudW1iZXIgb2YgY2hhcmFjdGVycy5cbiAgICBjb25zdCBzdHJpcHBlZFZhbHVlID0gKDAsIGhleF8xLnJlbW92ZTB4KSh2YWx1ZSkudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBub3JtYWxpemVkVmFsdWUgPSBzdHJpcHBlZFZhbHVlLmxlbmd0aCAlIDIgPT09IDAgPyBzdHJpcHBlZFZhbHVlIDogYDAke3N0cmlwcGVkVmFsdWV9YDtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KG5vcm1hbGl6ZWRWYWx1ZS5sZW5ndGggLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIFdoaWxlIHRoaXMgaXMgbm90IHRoZSBwcmV0dGllc3Qgd2F5IHRvIGNvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYVxuICAgICAgICAvLyBgVWludDhBcnJheWAsIGl0IGlzIGEgbG90IGZhc3RlciB0aGFuIHVzaW5nIGBwYXJzZUludGAgdG8gY29udmVydCBlYWNoXG4gICAgICAgIC8vIGNoYXJhY3Rlci5cbiAgICAgICAgY29uc3QgYzEgPSBub3JtYWxpemVkVmFsdWUuY2hhckNvZGVBdChpICogMik7XG4gICAgICAgIGNvbnN0IGMyID0gbm9ybWFsaXplZFZhbHVlLmNoYXJDb2RlQXQoaSAqIDIgKyAxKTtcbiAgICAgICAgY29uc3QgbjEgPSBjMSAtXG4gICAgICAgICAgICAoYzEgPCBIRVhfTUFYSU1VTV9OVU1CRVJfQ0hBUkFDVEVSXG4gICAgICAgICAgICAgICAgPyBIRVhfTUlOSU1VTV9OVU1CRVJfQ0hBUkFDVEVSXG4gICAgICAgICAgICAgICAgOiBIRVhfQ0hBUkFDVEVSX09GRlNFVCk7XG4gICAgICAgIGNvbnN0IG4yID0gYzIgLVxuICAgICAgICAgICAgKGMyIDwgSEVYX01BWElNVU1fTlVNQkVSX0NIQVJBQ1RFUlxuICAgICAgICAgICAgICAgID8gSEVYX01JTklNVU1fTlVNQkVSX0NIQVJBQ1RFUlxuICAgICAgICAgICAgICAgIDogSEVYX0NIQVJBQ1RFUl9PRkZTRVQpO1xuICAgICAgICBieXRlc1tpXSA9IG4xICogMTYgKyBuMjtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuZXhwb3J0cy5oZXhUb0J5dGVzID0gaGV4VG9CeXRlcztcbi8qKlxuICogQ29udmVydCBhIGBiaWdpbnRgIHRvIGEgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIFRoaXMgYXNzdW1lcyB0aGF0IHRoZSBgYmlnaW50YCBpcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLiBUbyBjb252ZXJ0IGEgc2lnbmVkXG4gKiBgYmlnaW50YCBpbnN0ZWFkLCB1c2Uge0BsaW5rIHNpZ25lZEJpZ0ludFRvQnl0ZXN9LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBiaWdpbnQgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJpZ0ludFRvQnl0ZXModmFsdWUpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnLCAnVmFsdWUgbXVzdCBiZSBhIGJpZ2ludC4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh2YWx1ZSA+PSBCaWdJbnQoMCksICdWYWx1ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGJpZ2ludC4nKTtcbiAgICBjb25zdCBoZXhhZGVjaW1hbCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhoZXhhZGVjaW1hbCk7XG59XG5leHBvcnRzLmJpZ0ludFRvQnl0ZXMgPSBiaWdJbnRUb0J5dGVzO1xuLyoqXG4gKiBDaGVjayBpZiBhIGBiaWdpbnRgIGZpdHMgaW4gYSBjZXJ0YWluIG51bWJlciBvZiBieXRlcy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYGJpZ2ludGAgdG8gY2hlY2suXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgbnVtYmVyIG9mIGJ5dGVzLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgYGJpZ2ludGAgZml0cyBpbiB0aGUgbnVtYmVyIG9mIGJ5dGVzLlxuICovXG5mdW5jdGlvbiBiaWdJbnRGaXRzKHZhbHVlLCBieXRlcykge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGJ5dGVzID4gMCk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuICAgIGNvbnN0IG1hc2sgPSB2YWx1ZSA+PiBCaWdJbnQoMzEpO1xuICAgIHJldHVybiAhKCgofnZhbHVlICYgbWFzaykgKyAodmFsdWUgJiB+bWFzaykpID4+IEJpZ0ludChieXRlcyAqIDggKyB+MCkpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tYml0d2lzZSAqL1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgc2lnbmVkIGBiaWdpbnRgIHRvIGEgYFVpbnQ4QXJyYXlgLiBUaGlzIHVzZXMgdHdvJ3MgY29tcGxlbWVudFxuICogZW5jb2RpbmcgdG8gcmVwcmVzZW50IG5lZ2F0aXZlIG51bWJlcnMuXG4gKlxuICogVG8gY29udmVydCBhbiB1bnNpZ25lZCBgYmlnaW50YCB0byBhIGBVaW50OEFycmF5YCBpbnN0ZWFkLCB1c2VcbiAqIHtAbGluayBiaWdJbnRUb0J5dGVzfS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1R3byUyN3NfY29tcGxlbWVudFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIG51bWJlciB0byBjb252ZXJ0IHRvIGJ5dGVzLlxuICogQHBhcmFtIGJ5dGVMZW5ndGggLSBUaGUgbGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgYFVpbnQ4QXJyYXlgLiBJZiB0aGUgbnVtYmVyXG4gKiBpcyBsYXJnZXIgdGhhbiB0aGUgbWF4aW11bSB2YWx1ZSB0aGF0IGNhbiBiZSByZXByZXNlbnRlZCBieSB0aGUgZ2l2ZW4gbGVuZ3RoLFxuICogYW4gZXJyb3IgaXMgdGhyb3duLlxuICogQHJldHVybnMgVGhlIGJ5dGVzIGFzIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gc2lnbmVkQmlnSW50VG9CeXRlcyh2YWx1ZSwgYnl0ZUxlbmd0aCkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcsICdWYWx1ZSBtdXN0IGJlIGEgYmlnaW50LicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHR5cGVvZiBieXRlTGVuZ3RoID09PSAnbnVtYmVyJywgJ0J5dGUgbGVuZ3RoIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoYnl0ZUxlbmd0aCA+IDAsICdCeXRlIGxlbmd0aCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwLicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGJpZ0ludEZpdHModmFsdWUsIGJ5dGVMZW5ndGgpLCAnQnl0ZSBsZW5ndGggaXMgdG9vIHNtYWxsIHRvIHJlcHJlc2VudCB0aGUgZ2l2ZW4gdmFsdWUuJyk7XG4gICAgLy8gRVNMaW50IGRvZXNuJ3QgbGlrZSBtdXRhdGluZyBmdW5jdGlvbiBwYXJhbWV0ZXJzLCBzbyB0byBhdm9pZCBoYXZpbmcgdG9cbiAgICAvLyBkaXNhYmxlIHRoZSBydWxlLCB3ZSBjcmVhdGUgYSBuZXcgdmFyaWFibGUuXG4gICAgbGV0IG51bWJlclZhbHVlID0gdmFsdWU7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShieXRlTGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJ5dGVzW2ldID0gTnVtYmVyKEJpZ0ludC5hc1VpbnROKDgsIG51bWJlclZhbHVlKSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgIG51bWJlclZhbHVlID4+PSBCaWdJbnQoOCk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcy5yZXZlcnNlKCk7XG59XG5leHBvcnRzLnNpZ25lZEJpZ0ludFRvQnl0ZXMgPSBzaWduZWRCaWdJbnRUb0J5dGVzO1xuLyoqXG4gKiBDb252ZXJ0IGEgYG51bWJlcmAgdG8gYSBgVWludDhBcnJheWAuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIG51bWJlciB0byBjb252ZXJ0IHRvIGJ5dGVzLlxuICogQHJldHVybnMgVGhlIGJ5dGVzIGFzIGBVaW50OEFycmF5YC5cbiAqIEB0aHJvd3MgSWYgdGhlIG51bWJlciBpcyBub3QgYSBzYWZlIGludGVnZXIuXG4gKi9cbmZ1bmN0aW9uIG51bWJlclRvQnl0ZXModmFsdWUpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnVmFsdWUgbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh2YWx1ZSA+PSAwLCAnVmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoTnVtYmVyLmlzU2FmZUludGVnZXIodmFsdWUpLCAnVmFsdWUgaXMgbm90IGEgc2FmZSBpbnRlZ2VyLiBVc2UgYGJpZ0ludFRvQnl0ZXNgIGluc3RlYWQuJyk7XG4gICAgY29uc3QgaGV4YWRlY2ltYWwgPSB2YWx1ZS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMoaGV4YWRlY2ltYWwpO1xufVxuZXhwb3J0cy5udW1iZXJUb0J5dGVzID0gbnVtYmVyVG9CeXRlcztcbi8qKlxuICogQ29udmVydCBhIGBzdHJpbmdgIHRvIGEgVVRGLTggZW5jb2RlZCBgVWludDhBcnJheWAuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHN0cmluZyB0byBjb252ZXJ0IHRvIGJ5dGVzLlxuICogQHJldHVybnMgVGhlIGJ5dGVzIGFzIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9CeXRlcyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycsICdWYWx1ZSBtdXN0IGJlIGEgc3RyaW5nLicpO1xuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodmFsdWUpO1xufVxuZXhwb3J0cy5zdHJpbmdUb0J5dGVzID0gc3RyaW5nVG9CeXRlcztcbi8qKlxuICogQ29udmVydCBhIGJ5dGUtbGlrZSB2YWx1ZSB0byBhIGBVaW50OEFycmF5YC4gVGhlIHZhbHVlIGNhbiBiZSBhIGBVaW50OEFycmF5YCxcbiAqIGEgYGJpZ2ludGAsIGEgYG51bWJlcmAsIG9yIGEgYHN0cmluZ2AuXG4gKlxuICogVGhpcyB3aWxsIGF0dGVtcHQgdG8gZ3Vlc3MgdGhlIHR5cGUgb2YgdGhlIHZhbHVlIGJhc2VkIG9uIGl0cyB0eXBlIGFuZFxuICogY29udGVudHMuIEZvciBtb3JlIGNvbnRyb2wgb3ZlciB0aGUgY29udmVyc2lvbiwgdXNlIHRoZSBtb3JlIHNwZWNpZmljXG4gKiBjb252ZXJzaW9uIGZ1bmN0aW9ucywgc3VjaCBhcyB7QGxpbmsgaGV4VG9CeXRlc30gb3Ige0BsaW5rIHN0cmluZ1RvQnl0ZXN9LlxuICpcbiAqIElmIHRoZSB2YWx1ZSBpcyBhIGBzdHJpbmdgLCBhbmQgaXQgaXMgcHJlZml4ZWQgd2l0aCBgMHhgLCBpdCB3aWxsIGJlXG4gKiBpbnRlcnByZXRlZCBhcyBhIGhleGFkZWNpbWFsIHN0cmluZy4gT3RoZXJ3aXNlLCBpdCB3aWxsIGJlIGludGVycHJldGVkIGFzIGFcbiAqIFVURi04IHN0cmluZy4gVG8gY29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBieXRlcyB3aXRob3V0IGludGVycHJldGluZ1xuICogaXQgYXMgYSBVVEYtOCBzdHJpbmcsIHVzZSB7QGxpbmsgaGV4VG9CeXRlc30gaW5zdGVhZC5cbiAqXG4gKiBJZiB0aGUgdmFsdWUgaXMgYSBgYmlnaW50YCwgaXQgaXMgYXNzdW1lZCB0byBiZSB1bnNpZ25lZC4gVG8gY29udmVydCBhIHNpZ25lZFxuICogYGJpZ2ludGAgdG8gYnl0ZXMsIHVzZSB7QGxpbmsgc2lnbmVkQmlnSW50VG9CeXRlc30gaW5zdGVhZC5cbiAqXG4gKiBJZiB0aGUgdmFsdWUgaXMgYSBgVWludDhBcnJheWAsIGl0IHdpbGwgYmUgcmV0dXJuZWQgYXMtaXMuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiB2YWx1ZVRvQnl0ZXModmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICAgICAgICByZXR1cm4gYmlnSW50VG9CeXRlcyh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBudW1iZXJUb0J5dGVzKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgICAgIHJldHVybiBoZXhUb0J5dGVzKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5nVG9CeXRlcyh2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChpc0J5dGVzKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIHZhbHVlIHR5cGU6IFwiJHt0eXBlb2YgdmFsdWV9XCIuYCk7XG59XG5leHBvcnRzLnZhbHVlVG9CeXRlcyA9IHZhbHVlVG9CeXRlcztcbi8qKlxuICogQ29uY2F0ZW5hdGUgbXVsdGlwbGUgYnl0ZS1saWtlIHZhbHVlcyBpbnRvIGEgc2luZ2xlIGBVaW50OEFycmF5YC4gVGhlIHZhbHVlc1xuICogY2FuIGJlIGBVaW50OEFycmF5YCwgYGJpZ2ludGAsIGBudW1iZXJgLCBvciBgc3RyaW5nYC4gVGhpcyB1c2VzXG4gKiB7QGxpbmsgdmFsdWVUb0J5dGVzfSB1bmRlciB0aGUgaG9vZCB0byBjb252ZXJ0IGVhY2ggdmFsdWUgdG8gYnl0ZXMuIFJlZmVyIHRvXG4gKiB0aGUgZG9jdW1lbnRhdGlvbiBvZiB0aGF0IGZ1bmN0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIHRvIGNvbmNhdGVuYXRlLlxuICogQHJldHVybnMgVGhlIGNvbmNhdGVuYXRlZCBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKHZhbHVlcykge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRWYWx1ZXMgPSBuZXcgQXJyYXkodmFsdWVzLmxlbmd0aCk7XG4gICAgbGV0IGJ5dGVMZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVUb0J5dGVzKHZhbHVlc1tpXSk7XG4gICAgICAgIG5vcm1hbGl6ZWRWYWx1ZXNbaV0gPSB2YWx1ZTtcbiAgICAgICAgYnl0ZUxlbmd0aCArPSB2YWx1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZUxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIG9mZnNldCA9IDA7IGkgPCBub3JtYWxpemVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIFdoaWxlIHdlIGNvdWxkIHNpbXBseSBzcHJlYWQgdGhlIHZhbHVlcyBpbnRvIGFuIGFycmF5IGFuZCB1c2VcbiAgICAgICAgLy8gYFVpbnQ4QXJyYXkuZnJvbWAsIHRoYXQgaXMgYSBsb3Qgc2xvd2VyIHRoYW4gdXNpbmcgYFVpbnQ4QXJyYXkuc2V0YC5cbiAgICAgICAgYnl0ZXMuc2V0KG5vcm1hbGl6ZWRWYWx1ZXNbaV0sIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBub3JtYWxpemVkVmFsdWVzW2ldLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuZXhwb3J0cy5jb25jYXRCeXRlcyA9IGNvbmNhdEJ5dGVzO1xuLyoqXG4gKiBDcmVhdGUgYSB7QGxpbmsgRGF0YVZpZXd9IGZyb20gYSB7QGxpbmsgVWludDhBcnJheX0uIFRoaXMgaXMgYSBjb252ZW5pZW5jZVxuICogZnVuY3Rpb24gdGhhdCBhdm9pZHMgaGF2aW5nIHRvIGNyZWF0ZSBhIHtAbGluayBEYXRhVmlld30gbWFudWFsbHksIHdoaWNoXG4gKiByZXF1aXJlcyBwYXNzaW5nIHRoZSBgYnl0ZU9mZnNldGAgYW5kIGBieXRlTGVuZ3RoYCBwYXJhbWV0ZXJzIGV2ZXJ5IHRpbWUuXG4gKlxuICogTm90IHBhc3NpbmcgdGhlIGBieXRlT2Zmc2V0YCBhbmQgYGJ5dGVMZW5ndGhgIHBhcmFtZXRlcnMgY2FuIHJlc3VsdCBpblxuICogdW5leHBlY3RlZCBiZWhhdmlvciB3aGVuIHRoZSB7QGxpbmsgVWludDhBcnJheX0gaXMgYSB2aWV3IG9mIGEgbGFyZ2VyXG4gKiB7QGxpbmsgQXJyYXlCdWZmZXJ9LCBlLmcuLCB3aGVuIHVzaW5nIHtAbGluayBVaW50OEFycmF5LnN1YmFycmF5fS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGFsc28gc3VwcG9ydHMgTm9kZS5qcyB7QGxpbmsgQnVmZmVyfXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoWzEsIDIsIDNdKTtcbiAqXG4gKiAvLyBUaGlzIGlzIGVxdWl2YWxlbnQgdG86XG4gKiAvLyBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhieXRlcy5idWZmZXIsIGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmJ5dGVMZW5ndGgpO1xuICogY29uc3QgZGF0YVZpZXcgPSBjcmVhdGVEYXRhVmlldyhieXRlcyk7XG4gKiBgYGBcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBieXRlcyB0byBjcmVhdGUgdGhlIHtAbGluayBEYXRhVmlld30gZnJvbS5cbiAqIEByZXR1cm5zIFRoZSB7QGxpbmsgRGF0YVZpZXd9LlxuICovXG5mdW5jdGlvbiBjcmVhdGVEYXRhVmlldyhieXRlcykge1xuICAgIC8vIFRvIG1haW50YWluIGNvbXBhdGliaWxpdHkgd2l0aCBOb2RlLmpzLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBieXRlcyBhcmVcbiAgICAvLyBhIEJ1ZmZlci4gSWYgc28sIHdlIG5lZWQgdG8gc2xpY2UgdGhlIGJ1ZmZlciB0byBnZXQgdGhlIHVuZGVybHlpbmdcbiAgICAvLyBBcnJheUJ1ZmZlci5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGJ5dGVzIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGJ5dGVzLmJ1ZmZlci5zbGljZShieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlT2Zmc2V0ICsgYnl0ZXMuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhieXRlcy5idWZmZXIsIGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmJ5dGVMZW5ndGgpO1xufVxuZXhwb3J0cy5jcmVhdGVEYXRhVmlldyA9IGNyZWF0ZURhdGFWaWV3O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ynl0ZXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiY3JlYXRlRGF0YVZpZXciLCJjb25jYXRCeXRlcyIsInZhbHVlVG9CeXRlcyIsInN0cmluZ1RvQnl0ZXMiLCJudW1iZXJUb0J5dGVzIiwic2lnbmVkQmlnSW50VG9CeXRlcyIsImJpZ0ludFRvQnl0ZXMiLCJoZXhUb0J5dGVzIiwiYnl0ZXNUb1N0cmluZyIsImJ5dGVzVG9OdW1iZXIiLCJieXRlc1RvU2lnbmVkQmlnSW50IiwiYnl0ZXNUb0JpZ0ludCIsImJ5dGVzVG9IZXgiLCJhc3NlcnRJc0J5dGVzIiwiaXNCeXRlcyIsImFzc2VydF8xIiwicmVxdWlyZSIsImhleF8xIiwiSEVYX01JTklNVU1fTlVNQkVSX0NIQVJBQ1RFUiIsIkhFWF9NQVhJTVVNX05VTUJFUl9DSEFSQUNURVIiLCJIRVhfQ0hBUkFDVEVSX09GRlNFVCIsImdldFByZWNvbXB1dGVkSGV4VmFsdWVzQnVpbGRlciIsImxvb2t1cFRhYmxlIiwibGVuZ3RoIiwiaSIsInB1c2giLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiZ2V0UHJlY29tcHV0ZWRIZXhWYWx1ZXMiLCJVaW50OEFycmF5IiwiYXNzZXJ0IiwiYnl0ZXMiLCJoZXhhZGVjaW1hbCIsIkFycmF5IiwiYWRkMHgiLCJqb2luIiwiQmlnSW50IiwiYnl0ZSIsImFzSW50TiIsImJpZ2ludCIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJUZXh0RGVjb2RlciIsImRlY29kZSIsIl9hIiwidG9Mb3dlckNhc2UiLCJjYWxsIiwiYXNzZXJ0SXNIZXhTdHJpbmciLCJzdHJpcHBlZFZhbHVlIiwicmVtb3ZlMHgiLCJub3JtYWxpemVkVmFsdWUiLCJjMSIsImNoYXJDb2RlQXQiLCJjMiIsIm4xIiwibjIiLCJiaWdJbnRGaXRzIiwibWFzayIsImJ5dGVMZW5ndGgiLCJudW1iZXJWYWx1ZSIsImFzVWludE4iLCJyZXZlcnNlIiwiaXNTYWZlSW50ZWdlciIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwic3RhcnRzV2l0aCIsIlR5cGVFcnJvciIsInZhbHVlcyIsIm5vcm1hbGl6ZWRWYWx1ZXMiLCJvZmZzZXQiLCJzZXQiLCJCdWZmZXIiLCJidWZmZXIiLCJzbGljZSIsImJ5dGVPZmZzZXQiLCJEYXRhVmlldyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/checksum.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/checksum.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ChecksumStruct = void 0;\nconst superstruct_1 = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\nconst base64_1 = __webpack_require__(/*! ./base64 */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/base64.js\");\nexports.ChecksumStruct = (0, superstruct_1.size)((0, base64_1.base64)((0, superstruct_1.string)(), {\n    paddingRequired: true\n}), 44, 44); //# sourceMappingURL=checksum.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NoZWNrc3VtLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxzQkFBc0IsR0FBRyxLQUFLO0FBQzlCLE1BQU1HLGdCQUFnQkMsbUJBQU9BLENBQUMsb0VBQWE7QUFDM0MsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMsb0dBQVU7QUFDbkNKLHNCQUFzQixHQUFHLENBQUMsR0FBR0csY0FBY0csSUFBSSxFQUFFLENBQUMsR0FBR0QsU0FBU0UsTUFBTSxFQUFFLENBQUMsR0FBR0osY0FBY0ssTUFBTSxLQUFLO0lBQUVDLGlCQUFpQjtBQUFLLElBQUksSUFBSSxLQUNuSSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGFibGUtcm91dGVyLXdlYi8uL25vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2hlY2tzdW0uanM/ZDg5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hlY2tzdW1TdHJ1Y3QgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcInN1cGVyc3RydWN0XCIpO1xuY29uc3QgYmFzZTY0XzEgPSByZXF1aXJlKFwiLi9iYXNlNjRcIik7XG5leHBvcnRzLkNoZWNrc3VtU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEuc2l6ZSkoKDAsIGJhc2U2NF8xLmJhc2U2NCkoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCB7IHBhZGRpbmdSZXF1aXJlZDogdHJ1ZSB9KSwgNDQsIDQ0KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrc3VtLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkNoZWNrc3VtU3RydWN0Iiwic3VwZXJzdHJ1Y3RfMSIsInJlcXVpcmUiLCJiYXNlNjRfMSIsInNpemUiLCJiYXNlNjQiLCJzdHJpbmciLCJwYWRkaW5nUmVxdWlyZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/checksum.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/coercers.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/coercers.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createHex = exports.createBytes = exports.createBigInt = exports.createNumber = void 0;\nconst superstruct_1 = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\nconst assert_1 = __webpack_require__(/*! ./assert */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/assert.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/bytes.js\");\nconst hex_1 = __webpack_require__(/*! ./hex */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/hex.js\");\nconst NumberLikeStruct = (0, superstruct_1.union)([\n    (0, superstruct_1.number)(),\n    (0, superstruct_1.bigint)(),\n    (0, superstruct_1.string)(),\n    hex_1.StrictHexStruct\n]);\nconst NumberCoercer = (0, superstruct_1.coerce)((0, superstruct_1.number)(), NumberLikeStruct, Number);\nconst BigIntCoercer = (0, superstruct_1.coerce)((0, superstruct_1.bigint)(), NumberLikeStruct, BigInt);\nconst BytesLikeStruct = (0, superstruct_1.union)([\n    hex_1.StrictHexStruct,\n    (0, superstruct_1.instance)(Uint8Array)\n]);\nconst BytesCoercer = (0, superstruct_1.coerce)((0, superstruct_1.instance)(Uint8Array), (0, superstruct_1.union)([\n    hex_1.StrictHexStruct\n]), bytes_1.hexToBytes);\nconst HexCoercer = (0, superstruct_1.coerce)(hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array), bytes_1.bytesToHex);\n/**\n * Create a number from a number-like value.\n *\n * - If the value is a number, it is returned as-is.\n * - If the value is a `bigint`, it is converted to a number.\n * - If the value is a string, it is interpreted as a decimal number.\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is\n * interpreted as a hexadecimal number.\n *\n * This validates that the value is a number-like value, and that the resulting\n * number is not `NaN` or `Infinity`.\n *\n * @example\n * ```typescript\n * const value = createNumber('0x010203');\n * console.log(value); // 66051\n *\n * const otherValue = createNumber(123n);\n * console.log(otherValue); // 123\n * ```\n * @param value - The value to create the number from.\n * @returns The created number.\n * @throws If the value is not a number-like value, or if the resulting number\n * is `NaN` or `Infinity`.\n */ function createNumber(value) {\n    try {\n        const result = (0, superstruct_1.create)(value, NumberCoercer);\n        (0, assert_1.assert)(Number.isFinite(result), `Expected a number-like value, got \"${value}\".`);\n        return result;\n    } catch (error) {\n        if (error instanceof superstruct_1.StructError) {\n            throw new Error(`Expected a number-like value, got \"${value}\".`);\n        }\n        /* istanbul ignore next */ throw error;\n    }\n}\nexports.createNumber = createNumber;\n/**\n * Create a `bigint` from a number-like value.\n *\n * - If the value is a number, it is converted to a `bigint`.\n * - If the value is a `bigint`, it is returned as-is.\n * - If the value is a string, it is interpreted as a decimal number and\n * converted to a `bigint`.\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is\n * interpreted as a hexadecimal number and converted to a `bigint`.\n *\n * @example\n * ```typescript\n * const value = createBigInt('0x010203');\n * console.log(value); // 16909060n\n *\n * const otherValue = createBigInt(123);\n * console.log(otherValue); // 123n\n * ```\n * @param value - The value to create the bigint from.\n * @returns The created bigint.\n * @throws If the value is not a number-like value.\n */ function createBigInt(value) {\n    try {\n        // The `BigInt` constructor throws if the value is not a number-like value.\n        // There is no need to validate the value manually.\n        return (0, superstruct_1.create)(value, BigIntCoercer);\n    } catch (error) {\n        if (error instanceof superstruct_1.StructError) {\n            throw new Error(`Expected a number-like value, got \"${String(error.value)}\".`);\n        }\n        /* istanbul ignore next */ throw error;\n    }\n}\nexports.createBigInt = createBigInt;\n/**\n * Create a byte array from a bytes-like value.\n *\n * - If the value is a byte array, it is returned as-is.\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is interpreted\n * as a hexadecimal number and converted to a byte array.\n *\n * @example\n * ```typescript\n * const value = createBytes('0x010203');\n * console.log(value); // Uint8Array [ 1, 2, 3 ]\n *\n * const otherValue = createBytes('0x010203');\n * console.log(otherValue); // Uint8Array [ 1, 2, 3 ]\n * ```\n * @param value - The value to create the byte array from.\n * @returns The created byte array.\n * @throws If the value is not a bytes-like value.\n */ function createBytes(value) {\n    if (typeof value === \"string\" && value.toLowerCase() === \"0x\") {\n        return new Uint8Array();\n    }\n    try {\n        return (0, superstruct_1.create)(value, BytesCoercer);\n    } catch (error) {\n        if (error instanceof superstruct_1.StructError) {\n            throw new Error(`Expected a bytes-like value, got \"${String(error.value)}\".`);\n        }\n        /* istanbul ignore next */ throw error;\n    }\n}\nexports.createBytes = createBytes;\n/**\n * Create a hexadecimal string from a bytes-like value.\n *\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is returned\n * as-is.\n * - If the value is a `Uint8Array`, it is converted to a hex string.\n *\n * @example\n * ```typescript\n * const value = createHex(new Uint8Array([1, 2, 3]));\n * console.log(value); // '0x010203'\n *\n * const otherValue = createHex('0x010203');\n * console.log(otherValue); // '0x010203'\n * ```\n * @param value - The value to create the hex string from.\n * @returns The created hex string.\n * @throws If the value is not a bytes-like value.\n */ function createHex(value) {\n    if (value instanceof Uint8Array && value.length === 0 || typeof value === \"string\" && value.toLowerCase() === \"0x\") {\n        return \"0x\";\n    }\n    try {\n        return (0, superstruct_1.create)(value, HexCoercer);\n    } catch (error) {\n        if (error instanceof superstruct_1.StructError) {\n            throw new Error(`Expected a bytes-like value, got \"${String(error.value)}\".`);\n        }\n        /* istanbul ignore next */ throw error;\n    }\n}\nexports.createHex = createHex; //# sourceMappingURL=coercers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NvZXJjZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQkFBaUIsR0FBR0EsbUJBQW1CLEdBQUdBLG9CQUFvQixHQUFHQSxvQkFBb0IsR0FBRyxLQUFLO0FBQzdGLE1BQU1NLGdCQUFnQkMsbUJBQU9BLENBQUMsb0VBQWE7QUFDM0MsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMsb0dBQVU7QUFDbkMsTUFBTUUsVUFBVUYsbUJBQU9BLENBQUMsa0dBQVM7QUFDakMsTUFBTUcsUUFBUUgsbUJBQU9BLENBQUMsOEZBQU87QUFDN0IsTUFBTUksbUJBQW1CLENBQUMsR0FBR0wsY0FBY00sS0FBSyxFQUFFO0lBQUUsSUFBR04sY0FBY08sTUFBTTtJQUFNLElBQUdQLGNBQWNRLE1BQU07SUFBTSxJQUFHUixjQUFjUyxNQUFNO0lBQUtMLE1BQU1NLGVBQWU7Q0FBQztBQUNoSyxNQUFNQyxnQkFBZ0IsQ0FBQyxHQUFHWCxjQUFjWSxNQUFNLEVBQUUsQ0FBQyxHQUFHWixjQUFjTyxNQUFNLEtBQUtGLGtCQUFrQlE7QUFDL0YsTUFBTUMsZ0JBQWdCLENBQUMsR0FBR2QsY0FBY1ksTUFBTSxFQUFFLENBQUMsR0FBR1osY0FBY1EsTUFBTSxLQUFLSCxrQkFBa0JVO0FBQy9GLE1BQU1DLGtCQUFrQixDQUFDLEdBQUdoQixjQUFjTSxLQUFLLEVBQUU7SUFBQ0YsTUFBTU0sZUFBZTtJQUFHLElBQUdWLGNBQWNpQixRQUFRLEVBQUVDO0NBQVk7QUFDakgsTUFBTUMsZUFBZSxDQUFDLEdBQUduQixjQUFjWSxNQUFNLEVBQUUsQ0FBQyxHQUFHWixjQUFjaUIsUUFBUSxFQUFFQyxhQUFhLENBQUMsR0FBR2xCLGNBQWNNLEtBQUssRUFBRTtJQUFDRixNQUFNTSxlQUFlO0NBQUMsR0FBR1AsUUFBUWlCLFVBQVU7QUFDN0osTUFBTUMsYUFBYSxDQUFDLEdBQUdyQixjQUFjWSxNQUFNLEVBQUVSLE1BQU1NLGVBQWUsRUFBRSxDQUFDLEdBQUdWLGNBQWNpQixRQUFRLEVBQUVDLGFBQWFmLFFBQVFtQixVQUFVO0FBQy9IOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F3QkMsR0FDRCxTQUFTdkIsYUFBYUosS0FBSztJQUN2QixJQUFJO1FBQ0EsTUFBTTRCLFNBQVMsQ0FBQyxHQUFHdkIsY0FBY3dCLE1BQU0sRUFBRTdCLE9BQU9nQjtRQUMvQyxJQUFHVCxTQUFTdUIsTUFBTSxFQUFFWixPQUFPYSxRQUFRLENBQUNILFNBQVMsQ0FBQyxtQ0FBbUMsRUFBRTVCLE1BQU0sRUFBRSxDQUFDO1FBQzdGLE9BQU80QjtJQUNYLEVBQ0EsT0FBT0ksT0FBTztRQUNWLElBQUlBLGlCQUFpQjNCLGNBQWM0QixXQUFXLEVBQUU7WUFDNUMsTUFBTSxJQUFJQyxNQUFNLENBQUMsbUNBQW1DLEVBQUVsQyxNQUFNLEVBQUUsQ0FBQztRQUNuRTtRQUNBLHdCQUF3QixHQUN4QixNQUFNZ0M7SUFDVjtBQUNKO0FBQ0FqQyxvQkFBb0IsR0FBR0s7QUFDdkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXFCQyxHQUNELFNBQVNELGFBQWFILEtBQUs7SUFDdkIsSUFBSTtRQUNBLDJFQUEyRTtRQUMzRSxtREFBbUQ7UUFDbkQsT0FBTyxDQUFDLEdBQUdLLGNBQWN3QixNQUFNLEVBQUU3QixPQUFPbUI7SUFDNUMsRUFDQSxPQUFPYSxPQUFPO1FBQ1YsSUFBSUEsaUJBQWlCM0IsY0FBYzRCLFdBQVcsRUFBRTtZQUM1QyxNQUFNLElBQUlDLE1BQU0sQ0FBQyxtQ0FBbUMsRUFBRUMsT0FBT0gsTUFBTWhDLEtBQUssRUFBRSxFQUFFLENBQUM7UUFDakY7UUFDQSx3QkFBd0IsR0FDeEIsTUFBTWdDO0lBQ1Y7QUFDSjtBQUNBakMsb0JBQW9CLEdBQUdJO0FBQ3ZCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkMsR0FDRCxTQUFTRCxZQUFZRixLQUFLO0lBQ3RCLElBQUksT0FBT0EsVUFBVSxZQUFZQSxNQUFNb0MsV0FBVyxPQUFPLE1BQU07UUFDM0QsT0FBTyxJQUFJYjtJQUNmO0lBQ0EsSUFBSTtRQUNBLE9BQU8sQ0FBQyxHQUFHbEIsY0FBY3dCLE1BQU0sRUFBRTdCLE9BQU93QjtJQUM1QyxFQUNBLE9BQU9RLE9BQU87UUFDVixJQUFJQSxpQkFBaUIzQixjQUFjNEIsV0FBVyxFQUFFO1lBQzVDLE1BQU0sSUFBSUMsTUFBTSxDQUFDLGtDQUFrQyxFQUFFQyxPQUFPSCxNQUFNaEMsS0FBSyxFQUFFLEVBQUUsQ0FBQztRQUNoRjtRQUNBLHdCQUF3QixHQUN4QixNQUFNZ0M7SUFDVjtBQUNKO0FBQ0FqQyxtQkFBbUIsR0FBR0c7QUFDdEI7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUNELFNBQVNELFVBQVVELEtBQUs7SUFDcEIsSUFBSSxpQkFBa0J1QixjQUFjdkIsTUFBTXFDLE1BQU0sS0FBSyxLQUNoRCxPQUFPckMsVUFBVSxZQUFZQSxNQUFNb0MsV0FBVyxPQUFPLE1BQU87UUFDN0QsT0FBTztJQUNYO0lBQ0EsSUFBSTtRQUNBLE9BQU8sQ0FBQyxHQUFHL0IsY0FBY3dCLE1BQU0sRUFBRTdCLE9BQU8wQjtJQUM1QyxFQUNBLE9BQU9NLE9BQU87UUFDVixJQUFJQSxpQkFBaUIzQixjQUFjNEIsV0FBVyxFQUFFO1lBQzVDLE1BQU0sSUFBSUMsTUFBTSxDQUFDLGtDQUFrQyxFQUFFQyxPQUFPSCxNQUFNaEMsS0FBSyxFQUFFLEVBQUUsQ0FBQztRQUNoRjtRQUNBLHdCQUF3QixHQUN4QixNQUFNZ0M7SUFDVjtBQUNKO0FBQ0FqQyxpQkFBaUIsR0FBR0UsV0FDcEIsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RhYmxlLXJvdXRlci13ZWIvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NvZXJjZXJzLmpzPzE1ZjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUhleCA9IGV4cG9ydHMuY3JlYXRlQnl0ZXMgPSBleHBvcnRzLmNyZWF0ZUJpZ0ludCA9IGV4cG9ydHMuY3JlYXRlTnVtYmVyID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJzdXBlcnN0cnVjdFwiKTtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcIi4vYXNzZXJ0XCIpO1xuY29uc3QgYnl0ZXNfMSA9IHJlcXVpcmUoXCIuL2J5dGVzXCIpO1xuY29uc3QgaGV4XzEgPSByZXF1aXJlKFwiLi9oZXhcIik7XG5jb25zdCBOdW1iZXJMaWtlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEudW5pb24pKFsoMCwgc3VwZXJzdHJ1Y3RfMS5udW1iZXIpKCksICgwLCBzdXBlcnN0cnVjdF8xLmJpZ2ludCkoKSwgKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCBoZXhfMS5TdHJpY3RIZXhTdHJ1Y3RdKTtcbmNvbnN0IE51bWJlckNvZXJjZXIgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5jb2VyY2UpKCgwLCBzdXBlcnN0cnVjdF8xLm51bWJlcikoKSwgTnVtYmVyTGlrZVN0cnVjdCwgTnVtYmVyKTtcbmNvbnN0IEJpZ0ludENvZXJjZXIgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5jb2VyY2UpKCgwLCBzdXBlcnN0cnVjdF8xLmJpZ2ludCkoKSwgTnVtYmVyTGlrZVN0cnVjdCwgQmlnSW50KTtcbmNvbnN0IEJ5dGVzTGlrZVN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbaGV4XzEuU3RyaWN0SGV4U3RydWN0LCAoMCwgc3VwZXJzdHJ1Y3RfMS5pbnN0YW5jZSkoVWludDhBcnJheSldKTtcbmNvbnN0IEJ5dGVzQ29lcmNlciA9ICgwLCBzdXBlcnN0cnVjdF8xLmNvZXJjZSkoKDAsIHN1cGVyc3RydWN0XzEuaW5zdGFuY2UpKFVpbnQ4QXJyYXkpLCAoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoW2hleF8xLlN0cmljdEhleFN0cnVjdF0pLCBieXRlc18xLmhleFRvQnl0ZXMpO1xuY29uc3QgSGV4Q29lcmNlciA9ICgwLCBzdXBlcnN0cnVjdF8xLmNvZXJjZSkoaGV4XzEuU3RyaWN0SGV4U3RydWN0LCAoMCwgc3VwZXJzdHJ1Y3RfMS5pbnN0YW5jZSkoVWludDhBcnJheSksIGJ5dGVzXzEuYnl0ZXNUb0hleCk7XG4vKipcbiAqIENyZWF0ZSBhIG51bWJlciBmcm9tIGEgbnVtYmVyLWxpa2UgdmFsdWUuXG4gKlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBudW1iZXIsIGl0IGlzIHJldHVybmVkIGFzLWlzLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBgYmlnaW50YCwgaXQgaXMgY29udmVydGVkIHRvIGEgbnVtYmVyLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmcsIGl0IGlzIGludGVycHJldGVkIGFzIGEgZGVjaW1hbCBudW1iZXIuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGhleCBzdHJpbmcgKGkuZS4sIGl0IHN0YXJ0cyB3aXRoIFwiMHhcIiksIGl0IGlzXG4gKiBpbnRlcnByZXRlZCBhcyBhIGhleGFkZWNpbWFsIG51bWJlci5cbiAqXG4gKiBUaGlzIHZhbGlkYXRlcyB0aGF0IHRoZSB2YWx1ZSBpcyBhIG51bWJlci1saWtlIHZhbHVlLCBhbmQgdGhhdCB0aGUgcmVzdWx0aW5nXG4gKiBudW1iZXIgaXMgbm90IGBOYU5gIG9yIGBJbmZpbml0eWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHZhbHVlID0gY3JlYXRlTnVtYmVyKCcweDAxMDIwMycpO1xuICogY29uc29sZS5sb2codmFsdWUpOyAvLyA2NjA1MVxuICpcbiAqIGNvbnN0IG90aGVyVmFsdWUgPSBjcmVhdGVOdW1iZXIoMTIzbik7XG4gKiBjb25zb2xlLmxvZyhvdGhlclZhbHVlKTsgLy8gMTIzXG4gKiBgYGBcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjcmVhdGUgdGhlIG51bWJlciBmcm9tLlxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQgbnVtYmVyLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgbnVtYmVyLWxpa2UgdmFsdWUsIG9yIGlmIHRoZSByZXN1bHRpbmcgbnVtYmVyXG4gKiBpcyBgTmFOYCBvciBgSW5maW5pdHlgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVOdW1iZXIodmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5jcmVhdGUpKHZhbHVlLCBOdW1iZXJDb2VyY2VyKTtcbiAgICAgICAgKDAsIGFzc2VydF8xLmFzc2VydCkoTnVtYmVyLmlzRmluaXRlKHJlc3VsdCksIGBFeHBlY3RlZCBhIG51bWJlci1saWtlIHZhbHVlLCBnb3QgXCIke3ZhbHVlfVwiLmApO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2Ygc3VwZXJzdHJ1Y3RfMS5TdHJ1Y3RFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIG51bWJlci1saWtlIHZhbHVlLCBnb3QgXCIke3ZhbHVlfVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlTnVtYmVyID0gY3JlYXRlTnVtYmVyO1xuLyoqXG4gKiBDcmVhdGUgYSBgYmlnaW50YCBmcm9tIGEgbnVtYmVyLWxpa2UgdmFsdWUuXG4gKlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBudW1iZXIsIGl0IGlzIGNvbnZlcnRlZCB0byBhIGBiaWdpbnRgLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBgYmlnaW50YCwgaXQgaXMgcmV0dXJuZWQgYXMtaXMuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgaXQgaXMgaW50ZXJwcmV0ZWQgYXMgYSBkZWNpbWFsIG51bWJlciBhbmRcbiAqIGNvbnZlcnRlZCB0byBhIGBiaWdpbnRgLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBoZXggc3RyaW5nIChpLmUuLCBpdCBzdGFydHMgd2l0aCBcIjB4XCIpLCBpdCBpc1xuICogaW50ZXJwcmV0ZWQgYXMgYSBoZXhhZGVjaW1hbCBudW1iZXIgYW5kIGNvbnZlcnRlZCB0byBhIGBiaWdpbnRgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCB2YWx1ZSA9IGNyZWF0ZUJpZ0ludCgnMHgwMTAyMDMnKTtcbiAqIGNvbnNvbGUubG9nKHZhbHVlKTsgLy8gMTY5MDkwNjBuXG4gKlxuICogY29uc3Qgb3RoZXJWYWx1ZSA9IGNyZWF0ZUJpZ0ludCgxMjMpO1xuICogY29uc29sZS5sb2cob3RoZXJWYWx1ZSk7IC8vIDEyM25cbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNyZWF0ZSB0aGUgYmlnaW50IGZyb20uXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBiaWdpbnQuXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSBudW1iZXItbGlrZSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmlnSW50KHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gVGhlIGBCaWdJbnRgIGNvbnN0cnVjdG9yIHRocm93cyBpZiB0aGUgdmFsdWUgaXMgbm90IGEgbnVtYmVyLWxpa2UgdmFsdWUuXG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIG5lZWQgdG8gdmFsaWRhdGUgdGhlIHZhbHVlIG1hbnVhbGx5LlxuICAgICAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuY3JlYXRlKSh2YWx1ZSwgQmlnSW50Q29lcmNlcik7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBzdXBlcnN0cnVjdF8xLlN0cnVjdEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgbnVtYmVyLWxpa2UgdmFsdWUsIGdvdCBcIiR7U3RyaW5nKGVycm9yLnZhbHVlKX1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZUJpZ0ludCA9IGNyZWF0ZUJpZ0ludDtcbi8qKlxuICogQ3JlYXRlIGEgYnl0ZSBhcnJheSBmcm9tIGEgYnl0ZXMtbGlrZSB2YWx1ZS5cbiAqXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGJ5dGUgYXJyYXksIGl0IGlzIHJldHVybmVkIGFzLWlzLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBoZXggc3RyaW5nIChpLmUuLCBpdCBzdGFydHMgd2l0aCBcIjB4XCIpLCBpdCBpcyBpbnRlcnByZXRlZFxuICogYXMgYSBoZXhhZGVjaW1hbCBudW1iZXIgYW5kIGNvbnZlcnRlZCB0byBhIGJ5dGUgYXJyYXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHZhbHVlID0gY3JlYXRlQnl0ZXMoJzB4MDEwMjAzJyk7XG4gKiBjb25zb2xlLmxvZyh2YWx1ZSk7IC8vIFVpbnQ4QXJyYXkgWyAxLCAyLCAzIF1cbiAqXG4gKiBjb25zdCBvdGhlclZhbHVlID0gY3JlYXRlQnl0ZXMoJzB4MDEwMjAzJyk7XG4gKiBjb25zb2xlLmxvZyhvdGhlclZhbHVlKTsgLy8gVWludDhBcnJheSBbIDEsIDIsIDMgXVxuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY3JlYXRlIHRoZSBieXRlIGFycmF5IGZyb20uXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBieXRlIGFycmF5LlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgYnl0ZXMtbGlrZSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnl0ZXModmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAnMHgnKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuY3JlYXRlKSh2YWx1ZSwgQnl0ZXNDb2VyY2VyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIHN1cGVyc3RydWN0XzEuU3RydWN0RXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBieXRlcy1saWtlIHZhbHVlLCBnb3QgXCIke1N0cmluZyhlcnJvci52YWx1ZSl9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVCeXRlcyA9IGNyZWF0ZUJ5dGVzO1xuLyoqXG4gKiBDcmVhdGUgYSBoZXhhZGVjaW1hbCBzdHJpbmcgZnJvbSBhIGJ5dGVzLWxpa2UgdmFsdWUuXG4gKlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBoZXggc3RyaW5nIChpLmUuLCBpdCBzdGFydHMgd2l0aCBcIjB4XCIpLCBpdCBpcyByZXR1cm5lZFxuICogYXMtaXMuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGBVaW50OEFycmF5YCwgaXQgaXMgY29udmVydGVkIHRvIGEgaGV4IHN0cmluZy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgdmFsdWUgPSBjcmVhdGVIZXgobmV3IFVpbnQ4QXJyYXkoWzEsIDIsIDNdKSk7XG4gKiBjb25zb2xlLmxvZyh2YWx1ZSk7IC8vICcweDAxMDIwMydcbiAqXG4gKiBjb25zdCBvdGhlclZhbHVlID0gY3JlYXRlSGV4KCcweDAxMDIwMycpO1xuICogY29uc29sZS5sb2cob3RoZXJWYWx1ZSk7IC8vICcweDAxMDIwMydcbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNyZWF0ZSB0aGUgaGV4IHN0cmluZyBmcm9tLlxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQgaGV4IHN0cmluZy5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIGJ5dGVzLWxpa2UgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUhleCh2YWx1ZSkge1xuICAgIGlmICgodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJzB4JykpIHtcbiAgICAgICAgcmV0dXJuICcweCc7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5jcmVhdGUpKHZhbHVlLCBIZXhDb2VyY2VyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIHN1cGVyc3RydWN0XzEuU3RydWN0RXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBieXRlcy1saWtlIHZhbHVlLCBnb3QgXCIke1N0cmluZyhlcnJvci52YWx1ZSl9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVIZXggPSBjcmVhdGVIZXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2VyY2Vycy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjcmVhdGVIZXgiLCJjcmVhdGVCeXRlcyIsImNyZWF0ZUJpZ0ludCIsImNyZWF0ZU51bWJlciIsInN1cGVyc3RydWN0XzEiLCJyZXF1aXJlIiwiYXNzZXJ0XzEiLCJieXRlc18xIiwiaGV4XzEiLCJOdW1iZXJMaWtlU3RydWN0IiwidW5pb24iLCJudW1iZXIiLCJiaWdpbnQiLCJzdHJpbmciLCJTdHJpY3RIZXhTdHJ1Y3QiLCJOdW1iZXJDb2VyY2VyIiwiY29lcmNlIiwiTnVtYmVyIiwiQmlnSW50Q29lcmNlciIsIkJpZ0ludCIsIkJ5dGVzTGlrZVN0cnVjdCIsImluc3RhbmNlIiwiVWludDhBcnJheSIsIkJ5dGVzQ29lcmNlciIsImhleFRvQnl0ZXMiLCJIZXhDb2VyY2VyIiwiYnl0ZXNUb0hleCIsInJlc3VsdCIsImNyZWF0ZSIsImFzc2VydCIsImlzRmluaXRlIiwiZXJyb3IiLCJTdHJ1Y3RFcnJvciIsIkVycm9yIiwiU3RyaW5nIiwidG9Mb3dlckNhc2UiLCJsZW5ndGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/coercers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/collections.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/collections.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _FrozenMap_map, _FrozenSet_set;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FrozenSet = exports.FrozenMap = void 0;\n/**\n * A {@link ReadonlyMap} that cannot be modified after instantiation.\n * The implementation uses an inner map hidden via a private field, and the\n * immutability guarantee relies on it being impossible to get a reference\n * to this map.\n */ class FrozenMap {\n    constructor(entries){\n        _FrozenMap_map.set(this, void 0);\n        __classPrivateFieldSet(this, _FrozenMap_map, new Map(entries), \"f\");\n        Object.freeze(this);\n    }\n    get size() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").size;\n    }\n    [(_FrozenMap_map = new WeakMap(), Symbol.iterator)]() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\")[Symbol.iterator]();\n    }\n    entries() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").entries();\n    }\n    forEach(callbackfn, thisArg) {\n        // We have to wrap the specified callback in order to prevent it from\n        // receiving a reference to the inner map.\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").forEach((value, key, _map)=>callbackfn.call(thisArg, value, key, this));\n    }\n    get(key) {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").get(key);\n    }\n    has(key) {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").has(key);\n    }\n    keys() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").keys();\n    }\n    values() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").values();\n    }\n    toString() {\n        return `FrozenMap(${this.size}) {${this.size > 0 ? ` ${[\n            ...this.entries()\n        ].map(([key, value])=>`${String(key)} => ${String(value)}`).join(\", \")} ` : \"\"}}`;\n    }\n}\nexports.FrozenMap = FrozenMap;\n/**\n * A {@link ReadonlySet} that cannot be modified after instantiation.\n * The implementation uses an inner set hidden via a private field, and the\n * immutability guarantee relies on it being impossible to get a reference\n * to this set.\n */ class FrozenSet {\n    constructor(values){\n        _FrozenSet_set.set(this, void 0);\n        __classPrivateFieldSet(this, _FrozenSet_set, new Set(values), \"f\");\n        Object.freeze(this);\n    }\n    get size() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").size;\n    }\n    [(_FrozenSet_set = new WeakMap(), Symbol.iterator)]() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\")[Symbol.iterator]();\n    }\n    entries() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").entries();\n    }\n    forEach(callbackfn, thisArg) {\n        // We have to wrap the specified callback in order to prevent it from\n        // receiving a reference to the inner set.\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").forEach((value, value2, _set)=>callbackfn.call(thisArg, value, value2, this));\n    }\n    has(value) {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").has(value);\n    }\n    keys() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").keys();\n    }\n    values() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").values();\n    }\n    toString() {\n        return `FrozenSet(${this.size}) {${this.size > 0 ? ` ${[\n            ...this.values()\n        ].map((member)=>String(member)).join(\", \")} ` : \"\"}}`;\n    }\n}\nexports.FrozenSet = FrozenSet;\nObject.freeze(FrozenMap);\nObject.freeze(FrozenMap.prototype);\nObject.freeze(FrozenSet);\nObject.freeze(FrozenSet.prototype); //# sourceMappingURL=collections.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NvbGxlY3Rpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEseUJBQXlCLElBQUssSUFBSSxJQUFJLENBQUNBLHNCQUFzQixJQUFLLFNBQVVDLFFBQVEsRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsQ0FBQztJQUMzRyxJQUFJRCxTQUFTLEtBQUssTUFBTSxJQUFJRSxVQUFVO0lBQ3RDLElBQUlGLFNBQVMsT0FBTyxDQUFDQyxHQUFHLE1BQU0sSUFBSUMsVUFBVTtJQUM1QyxJQUFJLE9BQU9KLFVBQVUsYUFBYUQsYUFBYUMsU0FBUyxDQUFDRyxJQUFJLENBQUNILE1BQU1LLEdBQUcsQ0FBQ04sV0FBVyxNQUFNLElBQUlLLFVBQVU7SUFDdkcsT0FBTyxTQUFVLE1BQU1ELEVBQUVHLElBQUksQ0FBQ1AsVUFBVUUsU0FBU0UsSUFBSUEsRUFBRUYsS0FBSyxHQUFHQSxRQUFRRCxNQUFNTyxHQUFHLENBQUNSLFVBQVVFLFFBQVNBO0FBQ3hHO0FBQ0EsSUFBSU8seUJBQXlCLElBQUssSUFBSSxJQUFJLENBQUNBLHNCQUFzQixJQUFLLFNBQVVULFFBQVEsRUFBRUMsS0FBSyxFQUFFRSxJQUFJLEVBQUVDLENBQUM7SUFDcEcsSUFBSUQsU0FBUyxPQUFPLENBQUNDLEdBQUcsTUFBTSxJQUFJQyxVQUFVO0lBQzVDLElBQUksT0FBT0osVUFBVSxhQUFhRCxhQUFhQyxTQUFTLENBQUNHLElBQUksQ0FBQ0gsTUFBTUssR0FBRyxDQUFDTixXQUFXLE1BQU0sSUFBSUssVUFBVTtJQUN2RyxPQUFPRixTQUFTLE1BQU1DLElBQUlELFNBQVMsTUFBTUMsRUFBRUcsSUFBSSxDQUFDUCxZQUFZSSxJQUFJQSxFQUFFRixLQUFLLEdBQUdELE1BQU1TLEdBQUcsQ0FBQ1Y7QUFDeEY7QUFDQSxJQUFJVyxnQkFBZ0JDO0FBQ3BCQyw4Q0FBNkM7SUFBRVgsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RGEsaUJBQWlCLEdBQUdBLGlCQUFpQixHQUFHLEtBQUs7QUFDN0M7Ozs7O0NBS0MsR0FDRCxNQUFNRTtJQUNGQyxZQUFZQyxPQUFPLENBQUU7UUFDakJSLGVBQWVILEdBQUcsQ0FBQyxJQUFJLEVBQUUsS0FBSztRQUM5QlQsdUJBQXVCLElBQUksRUFBRVksZ0JBQWdCLElBQUlTLElBQUlELFVBQVU7UUFDL0ROLE9BQU9RLE1BQU0sQ0FBQyxJQUFJO0lBQ3RCO0lBQ0EsSUFBSUMsT0FBTztRQUNQLE9BQU9iLHVCQUF1QixJQUFJLEVBQUVFLGdCQUFnQixLQUFLVyxJQUFJO0lBQ2pFO0lBQ0EsQ0FBRVgsQ0FBQUEsaUJBQWlCLElBQUlZLFdBQVdDLE9BQU9DLFFBQVEsRUFBRSxHQUFHO1FBQ2xELE9BQU9oQix1QkFBdUIsSUFBSSxFQUFFRSxnQkFBZ0IsSUFBSSxDQUFDYSxPQUFPQyxRQUFRLENBQUM7SUFDN0U7SUFDQU4sVUFBVTtRQUNOLE9BQU9WLHVCQUF1QixJQUFJLEVBQUVFLGdCQUFnQixLQUFLUSxPQUFPO0lBQ3BFO0lBQ0FPLFFBQVFDLFVBQVUsRUFBRUMsT0FBTyxFQUFFO1FBQ3pCLHFFQUFxRTtRQUNyRSwwQ0FBMEM7UUFDMUMsT0FBT25CLHVCQUF1QixJQUFJLEVBQUVFLGdCQUFnQixLQUFLZSxPQUFPLENBQUMsQ0FBQ3hCLE9BQU8yQixLQUFLQyxPQUFTSCxXQUFXcEIsSUFBSSxDQUFDcUIsU0FBUzFCLE9BQU8yQixLQUFLLElBQUk7SUFDcEk7SUFDQW5CLElBQUltQixHQUFHLEVBQUU7UUFDTCxPQUFPcEIsdUJBQXVCLElBQUksRUFBRUUsZ0JBQWdCLEtBQUtELEdBQUcsQ0FBQ21CO0lBQ2pFO0lBQ0F2QixJQUFJdUIsR0FBRyxFQUFFO1FBQ0wsT0FBT3BCLHVCQUF1QixJQUFJLEVBQUVFLGdCQUFnQixLQUFLTCxHQUFHLENBQUN1QjtJQUNqRTtJQUNBRSxPQUFPO1FBQ0gsT0FBT3RCLHVCQUF1QixJQUFJLEVBQUVFLGdCQUFnQixLQUFLb0IsSUFBSTtJQUNqRTtJQUNBQyxTQUFTO1FBQ0wsT0FBT3ZCLHVCQUF1QixJQUFJLEVBQUVFLGdCQUFnQixLQUFLcUIsTUFBTTtJQUNuRTtJQUNBQyxXQUFXO1FBQ1AsT0FBTyxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUNYLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDQSxJQUFJLEdBQUcsSUFDekMsQ0FBQyxDQUFDLEVBQUU7ZUFBSSxJQUFJLENBQUNILE9BQU87U0FBRyxDQUNwQmUsR0FBRyxDQUFDLENBQUMsQ0FBQ0wsS0FBSzNCLE1BQU0sR0FBSyxDQUFDLEVBQUVpQyxPQUFPTixLQUFLLElBQUksRUFBRU0sT0FBT2pDLE9BQU8sQ0FBQyxFQUMxRGtDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUNoQixHQUFHLENBQUMsQ0FBQztJQUNmO0FBQ0o7QUFDQXJCLGlCQUFpQixHQUFHRTtBQUNwQjs7Ozs7Q0FLQyxHQUNELE1BQU1EO0lBQ0ZFLFlBQVljLE1BQU0sQ0FBRTtRQUNoQnBCLGVBQWVKLEdBQUcsQ0FBQyxJQUFJLEVBQUUsS0FBSztRQUM5QlQsdUJBQXVCLElBQUksRUFBRWEsZ0JBQWdCLElBQUl5QixJQUFJTCxTQUFTO1FBQzlEbkIsT0FBT1EsTUFBTSxDQUFDLElBQUk7SUFDdEI7SUFDQSxJQUFJQyxPQUFPO1FBQ1AsT0FBT2IsdUJBQXVCLElBQUksRUFBRUcsZ0JBQWdCLEtBQUtVLElBQUk7SUFDakU7SUFDQSxDQUFFVixDQUFBQSxpQkFBaUIsSUFBSVcsV0FBV0MsT0FBT0MsUUFBUSxFQUFFLEdBQUc7UUFDbEQsT0FBT2hCLHVCQUF1QixJQUFJLEVBQUVHLGdCQUFnQixJQUFJLENBQUNZLE9BQU9DLFFBQVEsQ0FBQztJQUM3RTtJQUNBTixVQUFVO1FBQ04sT0FBT1YsdUJBQXVCLElBQUksRUFBRUcsZ0JBQWdCLEtBQUtPLE9BQU87SUFDcEU7SUFDQU8sUUFBUUMsVUFBVSxFQUFFQyxPQUFPLEVBQUU7UUFDekIscUVBQXFFO1FBQ3JFLDBDQUEwQztRQUMxQyxPQUFPbkIsdUJBQXVCLElBQUksRUFBRUcsZ0JBQWdCLEtBQUtjLE9BQU8sQ0FBQyxDQUFDeEIsT0FBT29DLFFBQVFDLE9BQVNaLFdBQVdwQixJQUFJLENBQUNxQixTQUFTMUIsT0FBT29DLFFBQVEsSUFBSTtJQUMxSTtJQUNBaEMsSUFBSUosS0FBSyxFQUFFO1FBQ1AsT0FBT08sdUJBQXVCLElBQUksRUFBRUcsZ0JBQWdCLEtBQUtOLEdBQUcsQ0FBQ0o7SUFDakU7SUFDQTZCLE9BQU87UUFDSCxPQUFPdEIsdUJBQXVCLElBQUksRUFBRUcsZ0JBQWdCLEtBQUttQixJQUFJO0lBQ2pFO0lBQ0FDLFNBQVM7UUFDTCxPQUFPdkIsdUJBQXVCLElBQUksRUFBRUcsZ0JBQWdCLEtBQUtvQixNQUFNO0lBQ25FO0lBQ0FDLFdBQVc7UUFDUCxPQUFPLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQ1gsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUNBLElBQUksR0FBRyxJQUN6QyxDQUFDLENBQUMsRUFBRTtlQUFJLElBQUksQ0FBQ1UsTUFBTTtTQUFHLENBQUNFLEdBQUcsQ0FBQyxDQUFDTSxTQUFXTCxPQUFPSyxTQUFTSixJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FDcEUsR0FBRyxDQUFDLENBQUM7SUFDZjtBQUNKO0FBQ0FyQixpQkFBaUIsR0FBR0M7QUFDcEJILE9BQU9RLE1BQU0sQ0FBQ0o7QUFDZEosT0FBT1EsTUFBTSxDQUFDSixVQUFVd0IsU0FBUztBQUNqQzVCLE9BQU9RLE1BQU0sQ0FBQ0w7QUFDZEgsT0FBT1EsTUFBTSxDQUFDTCxVQUFVeUIsU0FBUyxHQUNqQyx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGFibGUtcm91dGVyLXdlYi8uL25vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY29sbGVjdGlvbnMuanM/OTdkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfRnJvemVuTWFwX21hcCwgX0Zyb3plblNldF9zZXQ7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZyb3plblNldCA9IGV4cG9ydHMuRnJvemVuTWFwID0gdm9pZCAwO1xuLyoqXG4gKiBBIHtAbGluayBSZWFkb25seU1hcH0gdGhhdCBjYW5ub3QgYmUgbW9kaWZpZWQgYWZ0ZXIgaW5zdGFudGlhdGlvbi5cbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiB1c2VzIGFuIGlubmVyIG1hcCBoaWRkZW4gdmlhIGEgcHJpdmF0ZSBmaWVsZCwgYW5kIHRoZVxuICogaW1tdXRhYmlsaXR5IGd1YXJhbnRlZSByZWxpZXMgb24gaXQgYmVpbmcgaW1wb3NzaWJsZSB0byBnZXQgYSByZWZlcmVuY2VcbiAqIHRvIHRoaXMgbWFwLlxuICovXG5jbGFzcyBGcm96ZW5NYXAge1xuICAgIGNvbnN0cnVjdG9yKGVudHJpZXMpIHtcbiAgICAgICAgX0Zyb3plbk1hcF9tYXAuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIG5ldyBNYXAoZW50cmllcyksIFwiZlwiKTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikuc2l6ZTtcbiAgICB9XG4gICAgWyhfRnJvemVuTWFwX21hcCA9IG5ldyBXZWFrTWFwKCksIFN5bWJvbC5pdGVyYXRvcildKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9XG4gICAgZW50cmllcygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS5lbnRyaWVzKCk7XG4gICAgfVxuICAgIGZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZykge1xuICAgICAgICAvLyBXZSBoYXZlIHRvIHdyYXAgdGhlIHNwZWNpZmllZCBjYWxsYmFjayBpbiBvcmRlciB0byBwcmV2ZW50IGl0IGZyb21cbiAgICAgICAgLy8gcmVjZWl2aW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBpbm5lciBtYXAuXG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikuZm9yRWFjaCgodmFsdWUsIGtleSwgX21hcCkgPT4gY2FsbGJhY2tmbi5jYWxsKHRoaXNBcmcsIHZhbHVlLCBrZXksIHRoaXMpKTtcbiAgICB9XG4gICAgZ2V0KGtleSkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpLmdldChrZXkpO1xuICAgIH1cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikuaGFzKGtleSk7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikua2V5cygpO1xuICAgIH1cbiAgICB2YWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikudmFsdWVzKCk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYEZyb3plbk1hcCgke3RoaXMuc2l6ZX0pIHske3RoaXMuc2l6ZSA+IDBcbiAgICAgICAgICAgID8gYCAke1suLi50aGlzLmVudHJpZXMoKV1cbiAgICAgICAgICAgICAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+IGAke1N0cmluZyhrZXkpfSA9PiAke1N0cmluZyh2YWx1ZSl9YClcbiAgICAgICAgICAgICAgICAuam9pbignLCAnKX0gYFxuICAgICAgICAgICAgOiAnJ319YDtcbiAgICB9XG59XG5leHBvcnRzLkZyb3plbk1hcCA9IEZyb3plbk1hcDtcbi8qKlxuICogQSB7QGxpbmsgUmVhZG9ubHlTZXR9IHRoYXQgY2Fubm90IGJlIG1vZGlmaWVkIGFmdGVyIGluc3RhbnRpYXRpb24uXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gdXNlcyBhbiBpbm5lciBzZXQgaGlkZGVuIHZpYSBhIHByaXZhdGUgZmllbGQsIGFuZCB0aGVcbiAqIGltbXV0YWJpbGl0eSBndWFyYW50ZWUgcmVsaWVzIG9uIGl0IGJlaW5nIGltcG9zc2libGUgdG8gZ2V0IGEgcmVmZXJlbmNlXG4gKiB0byB0aGlzIHNldC5cbiAqL1xuY2xhc3MgRnJvemVuU2V0IHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZXMpIHtcbiAgICAgICAgX0Zyb3plblNldF9zZXQuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0Zyb3plblNldF9zZXQsIG5ldyBTZXQodmFsdWVzKSwgXCJmXCIpO1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plblNldF9zZXQsIFwiZlwiKS5zaXplO1xuICAgIH1cbiAgICBbKF9Gcm96ZW5TZXRfc2V0ID0gbmV3IFdlYWtNYXAoKSwgU3ltYm9sLml0ZXJhdG9yKV0oKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBcImZcIilbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIH1cbiAgICBlbnRyaWVzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLmVudHJpZXMoKTtcbiAgICB9XG4gICAgZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgdG8gd3JhcCB0aGUgc3BlY2lmaWVkIGNhbGxiYWNrIGluIG9yZGVyIHRvIHByZXZlbnQgaXQgZnJvbVxuICAgICAgICAvLyByZWNlaXZpbmcgYSByZWZlcmVuY2UgdG8gdGhlIGlubmVyIHNldC5cbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plblNldF9zZXQsIFwiZlwiKS5mb3JFYWNoKCh2YWx1ZSwgdmFsdWUyLCBfc2V0KSA9PiBjYWxsYmFja2ZuLmNhbGwodGhpc0FyZywgdmFsdWUsIHZhbHVlMiwgdGhpcykpO1xuICAgIH1cbiAgICBoYXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plblNldF9zZXQsIFwiZlwiKS5oYXModmFsdWUpO1xuICAgIH1cbiAgICBrZXlzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLmtleXMoKTtcbiAgICB9XG4gICAgdmFsdWVzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLnZhbHVlcygpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBGcm96ZW5TZXQoJHt0aGlzLnNpemV9KSB7JHt0aGlzLnNpemUgPiAwXG4gICAgICAgICAgICA/IGAgJHtbLi4udGhpcy52YWx1ZXMoKV0ubWFwKChtZW1iZXIpID0+IFN0cmluZyhtZW1iZXIpKS5qb2luKCcsICcpfSBgXG4gICAgICAgICAgICA6ICcnfX1gO1xuICAgIH1cbn1cbmV4cG9ydHMuRnJvemVuU2V0ID0gRnJvemVuU2V0O1xuT2JqZWN0LmZyZWV6ZShGcm96ZW5NYXApO1xuT2JqZWN0LmZyZWV6ZShGcm96ZW5NYXAucHJvdG90eXBlKTtcbk9iamVjdC5mcmVlemUoRnJvemVuU2V0KTtcbk9iamVjdC5mcmVlemUoRnJvemVuU2V0LnByb3RvdHlwZSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2xsZWN0aW9ucy5qcy5tYXAiXSwibmFtZXMiOlsiX19jbGFzc1ByaXZhdGVGaWVsZFNldCIsInJlY2VpdmVyIiwic3RhdGUiLCJ2YWx1ZSIsImtpbmQiLCJmIiwiVHlwZUVycm9yIiwiaGFzIiwiY2FsbCIsInNldCIsIl9fY2xhc3NQcml2YXRlRmllbGRHZXQiLCJnZXQiLCJfRnJvemVuTWFwX21hcCIsIl9Gcm96ZW5TZXRfc2V0IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwiRnJvemVuU2V0IiwiRnJvemVuTWFwIiwiY29uc3RydWN0b3IiLCJlbnRyaWVzIiwiTWFwIiwiZnJlZXplIiwic2l6ZSIsIldlYWtNYXAiLCJTeW1ib2wiLCJpdGVyYXRvciIsImZvckVhY2giLCJjYWxsYmFja2ZuIiwidGhpc0FyZyIsImtleSIsIl9tYXAiLCJrZXlzIiwidmFsdWVzIiwidG9TdHJpbmciLCJtYXAiLCJTdHJpbmciLCJqb2luIiwiU2V0IiwidmFsdWUyIiwiX3NldCIsIm1lbWJlciIsInByb3RvdHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/collections.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/encryption-types.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/encryption-types.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n})); //# sourceMappingURL=encryption-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2VuY3J5cHRpb24tdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUMsRUFDN0QsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RhYmxlLXJvdXRlci13ZWIvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2VuY3J5cHRpb24tdHlwZXMuanM/MTNjOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVuY3J5cHRpb24tdHlwZXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/encryption-types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/hex.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/hex.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.remove0x = exports.add0x = exports.assertIsStrictHexString = exports.assertIsHexString = exports.isStrictHexString = exports.isHexString = exports.StrictHexStruct = exports.HexStruct = void 0;\nconst superstruct_1 = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\nconst assert_1 = __webpack_require__(/*! ./assert */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/assert.js\");\nexports.HexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^(?:0x)?[0-9a-f]+$/iu);\nexports.StrictHexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^0x[0-9a-f]+$/iu);\n/**\n * Check if a string is a valid hex string.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */ function isHexString(value) {\n    return (0, superstruct_1.is)(value, exports.HexStruct);\n}\nexports.isHexString = isHexString;\n/**\n * Strictly check if a string is a valid hex string. A valid hex string must\n * start with the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */ function isStrictHexString(value) {\n    return (0, superstruct_1.is)(value, exports.StrictHexStruct);\n}\nexports.isStrictHexString = isStrictHexString;\n/**\n * Assert that a value is a valid hex string.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */ function assertIsHexString(value) {\n    (0, assert_1.assert)(isHexString(value), \"Value must be a hexadecimal string.\");\n}\nexports.assertIsHexString = assertIsHexString;\n/**\n * Assert that a value is a valid hex string. A valid hex string must start with\n * the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */ function assertIsStrictHexString(value) {\n    (0, assert_1.assert)(isStrictHexString(value), 'Value must be a hexadecimal string, starting with \"0x\".');\n}\nexports.assertIsStrictHexString = assertIsStrictHexString;\n/**\n * Add the `0x`-prefix to a hexadecimal string. If the string already has the\n * prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to add the prefix to.\n * @returns The prefixed hexadecimal string.\n */ function add0x(hexadecimal) {\n    if (hexadecimal.startsWith(\"0x\")) {\n        return hexadecimal;\n    }\n    if (hexadecimal.startsWith(\"0X\")) {\n        return `0x${hexadecimal.substring(2)}`;\n    }\n    return `0x${hexadecimal}`;\n}\nexports.add0x = add0x;\n/**\n * Remove the `0x`-prefix from a hexadecimal string. If the string doesn't have\n * the prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to remove the prefix from.\n * @returns The un-prefixed hexadecimal string.\n */ function remove0x(hexadecimal) {\n    if (hexadecimal.startsWith(\"0x\") || hexadecimal.startsWith(\"0X\")) {\n        return hexadecimal.substring(2);\n    }\n    return hexadecimal;\n}\nexports.remove0x = remove0x; //# sourceMappingURL=hex.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2hleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZ0JBQWdCLEdBQUdBLGFBQWEsR0FBR0EsK0JBQStCLEdBQUdBLHlCQUF5QixHQUFHQSx5QkFBeUIsR0FBR0EsbUJBQW1CLEdBQUdBLHVCQUF1QixHQUFHQSxpQkFBaUIsR0FBRyxLQUFLO0FBQ3RNLE1BQU1VLGdCQUFnQkMsbUJBQU9BLENBQUMsb0VBQWE7QUFDM0MsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMsb0dBQVU7QUFDbkNYLGlCQUFpQixHQUFHLENBQUMsR0FBR1UsY0FBY0csT0FBTyxFQUFFLENBQUMsR0FBR0gsY0FBY0ksTUFBTSxLQUFLO0FBQzVFZCx1QkFBdUIsR0FBRyxDQUFDLEdBQUdVLGNBQWNHLE9BQU8sRUFBRSxDQUFDLEdBQUdILGNBQWNJLE1BQU0sS0FBSztBQUNsRjs7Ozs7Q0FLQyxHQUNELFNBQVNQLFlBQVlOLEtBQUs7SUFDdEIsT0FBTyxDQUFDLEdBQUdTLGNBQWNLLEVBQUUsRUFBRWQsT0FBT0QsUUFBUVMsU0FBUztBQUN6RDtBQUNBVCxtQkFBbUIsR0FBR087QUFDdEI7Ozs7OztDQU1DLEdBQ0QsU0FBU0Qsa0JBQWtCTCxLQUFLO0lBQzVCLE9BQU8sQ0FBQyxHQUFHUyxjQUFjSyxFQUFFLEVBQUVkLE9BQU9ELFFBQVFRLGVBQWU7QUFDL0Q7QUFDQVIseUJBQXlCLEdBQUdNO0FBQzVCOzs7OztDQUtDLEdBQ0QsU0FBU0Qsa0JBQWtCSixLQUFLO0lBQzNCLElBQUdXLFNBQVNJLE1BQU0sRUFBRVQsWUFBWU4sUUFBUTtBQUM3QztBQUNBRCx5QkFBeUIsR0FBR0s7QUFDNUI7Ozs7OztDQU1DLEdBQ0QsU0FBU0Qsd0JBQXdCSCxLQUFLO0lBQ2pDLElBQUdXLFNBQVNJLE1BQU0sRUFBRVYsa0JBQWtCTCxRQUFRO0FBQ25EO0FBQ0FELCtCQUErQixHQUFHSTtBQUNsQzs7Ozs7O0NBTUMsR0FDRCxTQUFTRCxNQUFNYyxXQUFXO0lBQ3RCLElBQUlBLFlBQVlDLFVBQVUsQ0FBQyxPQUFPO1FBQzlCLE9BQU9EO0lBQ1g7SUFDQSxJQUFJQSxZQUFZQyxVQUFVLENBQUMsT0FBTztRQUM5QixPQUFPLENBQUMsRUFBRSxFQUFFRCxZQUFZRSxTQUFTLENBQUMsR0FBRyxDQUFDO0lBQzFDO0lBQ0EsT0FBTyxDQUFDLEVBQUUsRUFBRUYsWUFBWSxDQUFDO0FBQzdCO0FBQ0FqQixhQUFhLEdBQUdHO0FBQ2hCOzs7Ozs7Q0FNQyxHQUNELFNBQVNELFNBQVNlLFdBQVc7SUFDekIsSUFBSUEsWUFBWUMsVUFBVSxDQUFDLFNBQVNELFlBQVlDLFVBQVUsQ0FBQyxPQUFPO1FBQzlELE9BQU9ELFlBQVlFLFNBQVMsQ0FBQztJQUNqQztJQUNBLE9BQU9GO0FBQ1g7QUFDQWpCLGdCQUFnQixHQUFHRSxVQUNuQiwrQkFBK0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGFibGUtcm91dGVyLXdlYi8uL25vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvaGV4LmpzP2M1MmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlbW92ZTB4ID0gZXhwb3J0cy5hZGQweCA9IGV4cG9ydHMuYXNzZXJ0SXNTdHJpY3RIZXhTdHJpbmcgPSBleHBvcnRzLmFzc2VydElzSGV4U3RyaW5nID0gZXhwb3J0cy5pc1N0cmljdEhleFN0cmluZyA9IGV4cG9ydHMuaXNIZXhTdHJpbmcgPSBleHBvcnRzLlN0cmljdEhleFN0cnVjdCA9IGV4cG9ydHMuSGV4U3RydWN0ID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJzdXBlcnN0cnVjdFwiKTtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcIi4vYXNzZXJ0XCIpO1xuZXhwb3J0cy5IZXhTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5wYXR0ZXJuKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksIC9eKD86MHgpP1swLTlhLWZdKyQvaXUpO1xuZXhwb3J0cy5TdHJpY3RIZXhTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5wYXR0ZXJuKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksIC9eMHhbMC05YS1mXSskL2l1KTtcbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgaXMgYSB2YWxpZCBoZXggc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaGV4IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gaXNIZXhTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkhleFN0cnVjdCk7XG59XG5leHBvcnRzLmlzSGV4U3RyaW5nID0gaXNIZXhTdHJpbmc7XG4vKipcbiAqIFN0cmljdGx5IGNoZWNrIGlmIGEgc3RyaW5nIGlzIGEgdmFsaWQgaGV4IHN0cmluZy4gQSB2YWxpZCBoZXggc3RyaW5nIG11c3RcbiAqIHN0YXJ0IHdpdGggdGhlIFwiMHhcIi1wcmVmaXguXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSB2YWxpZCBoZXggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdEhleFN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuU3RyaWN0SGV4U3RydWN0KTtcbn1cbmV4cG9ydHMuaXNTdHJpY3RIZXhTdHJpbmcgPSBpc1N0cmljdEhleFN0cmluZztcbi8qKlxuICogQXNzZXJ0IHRoYXQgYSB2YWx1ZSBpcyBhIHZhbGlkIGhleCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgaGV4IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNIZXhTdHJpbmcodmFsdWUpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShpc0hleFN0cmluZyh2YWx1ZSksICdWYWx1ZSBtdXN0IGJlIGEgaGV4YWRlY2ltYWwgc3RyaW5nLicpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0hleFN0cmluZyA9IGFzc2VydElzSGV4U3RyaW5nO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgaGV4IHN0cmluZy4gQSB2YWxpZCBoZXggc3RyaW5nIG11c3Qgc3RhcnQgd2l0aFxuICogdGhlIFwiMHhcIi1wcmVmaXguXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgaGV4IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNTdHJpY3RIZXhTdHJpbmcodmFsdWUpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShpc1N0cmljdEhleFN0cmluZyh2YWx1ZSksICdWYWx1ZSBtdXN0IGJlIGEgaGV4YWRlY2ltYWwgc3RyaW5nLCBzdGFydGluZyB3aXRoIFwiMHhcIi4nKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNTdHJpY3RIZXhTdHJpbmcgPSBhc3NlcnRJc1N0cmljdEhleFN0cmluZztcbi8qKlxuICogQWRkIHRoZSBgMHhgLXByZWZpeCB0byBhIGhleGFkZWNpbWFsIHN0cmluZy4gSWYgdGhlIHN0cmluZyBhbHJlYWR5IGhhcyB0aGVcbiAqIHByZWZpeCwgaXQgaXMgcmV0dXJuZWQgYXMtaXMuXG4gKlxuICogQHBhcmFtIGhleGFkZWNpbWFsIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBhZGQgdGhlIHByZWZpeCB0by5cbiAqIEByZXR1cm5zIFRoZSBwcmVmaXhlZCBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGFkZDB4KGhleGFkZWNpbWFsKSB7XG4gICAgaWYgKGhleGFkZWNpbWFsLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgcmV0dXJuIGhleGFkZWNpbWFsO1xuICAgIH1cbiAgICBpZiAoaGV4YWRlY2ltYWwuc3RhcnRzV2l0aCgnMFgnKSkge1xuICAgICAgICByZXR1cm4gYDB4JHtoZXhhZGVjaW1hbC5zdWJzdHJpbmcoMil9YDtcbiAgICB9XG4gICAgcmV0dXJuIGAweCR7aGV4YWRlY2ltYWx9YDtcbn1cbmV4cG9ydHMuYWRkMHggPSBhZGQweDtcbi8qKlxuICogUmVtb3ZlIHRoZSBgMHhgLXByZWZpeCBmcm9tIGEgaGV4YWRlY2ltYWwgc3RyaW5nLiBJZiB0aGUgc3RyaW5nIGRvZXNuJ3QgaGF2ZVxuICogdGhlIHByZWZpeCwgaXQgaXMgcmV0dXJuZWQgYXMtaXMuXG4gKlxuICogQHBhcmFtIGhleGFkZWNpbWFsIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byByZW1vdmUgdGhlIHByZWZpeCBmcm9tLlxuICogQHJldHVybnMgVGhlIHVuLXByZWZpeGVkIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlMHgoaGV4YWRlY2ltYWwpIHtcbiAgICBpZiAoaGV4YWRlY2ltYWwuc3RhcnRzV2l0aCgnMHgnKSB8fCBoZXhhZGVjaW1hbC5zdGFydHNXaXRoKCcwWCcpKSB7XG4gICAgICAgIHJldHVybiBoZXhhZGVjaW1hbC5zdWJzdHJpbmcoMik7XG4gICAgfVxuICAgIHJldHVybiBoZXhhZGVjaW1hbDtcbn1cbmV4cG9ydHMucmVtb3ZlMHggPSByZW1vdmUweDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhleC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJyZW1vdmUweCIsImFkZDB4IiwiYXNzZXJ0SXNTdHJpY3RIZXhTdHJpbmciLCJhc3NlcnRJc0hleFN0cmluZyIsImlzU3RyaWN0SGV4U3RyaW5nIiwiaXNIZXhTdHJpbmciLCJTdHJpY3RIZXhTdHJ1Y3QiLCJIZXhTdHJ1Y3QiLCJzdXBlcnN0cnVjdF8xIiwicmVxdWlyZSIsImFzc2VydF8xIiwicGF0dGVybiIsInN0cmluZyIsImlzIiwiYXNzZXJ0IiwiaGV4YWRlY2ltYWwiLCJzdGFydHNXaXRoIiwic3Vic3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/hex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/index.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = this && this.__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n__exportStar(__webpack_require__(/*! ./assert */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/assert.js\"), exports);\n__exportStar(__webpack_require__(/*! ./base64 */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/base64.js\"), exports);\n__exportStar(__webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/bytes.js\"), exports);\n__exportStar(__webpack_require__(/*! ./checksum */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/checksum.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coercers */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/coercers.js\"), exports);\n__exportStar(__webpack_require__(/*! ./collections */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/collections.js\"), exports);\n__exportStar(__webpack_require__(/*! ./encryption-types */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/encryption-types.js\"), exports);\n__exportStar(__webpack_require__(/*! ./hex */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/hex.js\"), exports);\n__exportStar(__webpack_require__(/*! ./json */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/json.js\"), exports);\n__exportStar(__webpack_require__(/*! ./keyring */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/keyring.js\"), exports);\n__exportStar(__webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/logging.js\"), exports);\n__exportStar(__webpack_require__(/*! ./misc */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/misc.js\"), exports);\n__exportStar(__webpack_require__(/*! ./number */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/number.js\"), exports);\n__exportStar(__webpack_require__(/*! ./opaque */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/opaque.js\"), exports);\n__exportStar(__webpack_require__(/*! ./time */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/time.js\"), exports);\n__exportStar(__webpack_require__(/*! ./transaction-types */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/transaction-types.js\"), exports);\n__exportStar(__webpack_require__(/*! ./versions */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/versions.js\"), exports); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLElBQUssSUFBSSxJQUFJLENBQUNBLGVBQWUsSUFBTUMsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDMUYsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0IsSUFBSUcsT0FBT1AsT0FBT1Esd0JBQXdCLENBQUNMLEdBQUdDO0lBQzlDLElBQUksQ0FBQ0csUUFBUyxVQUFTQSxPQUFPLENBQUNKLEVBQUVNLFVBQVUsR0FBR0YsS0FBS0csUUFBUSxJQUFJSCxLQUFLSSxZQUFZLEdBQUc7UUFDakZKLE9BQU87WUFBRUssWUFBWTtZQUFNQyxLQUFLO2dCQUFhLE9BQU9WLENBQUMsQ0FBQ0MsRUFBRTtZQUFFO1FBQUU7SUFDOUQ7SUFDQUosT0FBT2MsY0FBYyxDQUFDWixHQUFHRyxJQUFJRTtBQUNqQyxJQUFNLFNBQVNMLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDdEIsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0JGLENBQUMsQ0FBQ0csR0FBRyxHQUFHRixDQUFDLENBQUNDLEVBQUU7QUFDaEIsQ0FBQztBQUNELElBQUlXLGVBQWUsSUFBSyxJQUFJLElBQUksQ0FBQ0EsWUFBWSxJQUFLLFNBQVNaLENBQUMsRUFBRWEsUUFBTztJQUNqRSxJQUFLLElBQUlDLEtBQUtkLEVBQUcsSUFBSWMsTUFBTSxhQUFhLENBQUNqQixPQUFPa0IsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osVUFBU0MsSUFBSWxCLGdCQUFnQmlCLFVBQVNiLEdBQUdjO0FBQzNIO0FBQ0FqQiw4Q0FBNkM7SUFBRXFCLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0ROLGFBQWFPLG1CQUFPQSxDQUFDLG9HQUFVLEdBQUdOO0FBQ2xDRCxhQUFhTyxtQkFBT0EsQ0FBQyxvR0FBVSxHQUFHTjtBQUNsQ0QsYUFBYU8sbUJBQU9BLENBQUMsa0dBQVMsR0FBR047QUFDakNELGFBQWFPLG1CQUFPQSxDQUFDLHdHQUFZLEdBQUdOO0FBQ3BDRCxhQUFhTyxtQkFBT0EsQ0FBQyx3R0FBWSxHQUFHTjtBQUNwQ0QsYUFBYU8sbUJBQU9BLENBQUMsOEdBQWUsR0FBR047QUFDdkNELGFBQWFPLG1CQUFPQSxDQUFDLHdIQUFvQixHQUFHTjtBQUM1Q0QsYUFBYU8sbUJBQU9BLENBQUMsOEZBQU8sR0FBR047QUFDL0JELGFBQWFPLG1CQUFPQSxDQUFDLGdHQUFRLEdBQUdOO0FBQ2hDRCxhQUFhTyxtQkFBT0EsQ0FBQyxzR0FBVyxHQUFHTjtBQUNuQ0QsYUFBYU8sbUJBQU9BLENBQUMsc0dBQVcsR0FBR047QUFDbkNELGFBQWFPLG1CQUFPQSxDQUFDLGdHQUFRLEdBQUdOO0FBQ2hDRCxhQUFhTyxtQkFBT0EsQ0FBQyxvR0FBVSxHQUFHTjtBQUNsQ0QsYUFBYU8sbUJBQU9BLENBQUMsb0dBQVUsR0FBR047QUFDbENELGFBQWFPLG1CQUFPQSxDQUFDLGdHQUFRLEdBQUdOO0FBQ2hDRCxhQUFhTyxtQkFBT0EsQ0FBQywwSEFBcUIsR0FBR047QUFDN0NELGFBQWFPLG1CQUFPQSxDQUFDLHdHQUFZLEdBQUdOLFVBQ3BDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3N0YWJsZS1yb3V0ZXItd2ViLy4vbm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9pbmRleC5qcz8wY2UwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNzZXJ0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlNjRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2J5dGVzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jaGVja3N1bVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29lcmNlcnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbGxlY3Rpb25zXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9lbmNyeXB0aW9uLXR5cGVzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9oZXhcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2pzb25cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2tleXJpbmdcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2xvZ2dpbmdcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21pc2NcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL251bWJlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vb3BhcXVlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90aW1lXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90cmFuc2FjdGlvbi10eXBlc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmVyc2lvbnNcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIl9fY3JlYXRlQmluZGluZyIsIk9iamVjdCIsImNyZWF0ZSIsIm8iLCJtIiwiayIsImsyIiwidW5kZWZpbmVkIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZXNNb2R1bGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZXhwb3J0U3RhciIsImV4cG9ydHMiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwidmFsdWUiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/json.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/json.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getJsonRpcIdValidator = exports.assertIsJsonRpcError = exports.isJsonRpcError = exports.assertIsJsonRpcFailure = exports.isJsonRpcFailure = exports.assertIsJsonRpcSuccess = exports.isJsonRpcSuccess = exports.assertIsJsonRpcResponse = exports.isJsonRpcResponse = exports.assertIsPendingJsonRpcResponse = exports.isPendingJsonRpcResponse = exports.JsonRpcResponseStruct = exports.JsonRpcFailureStruct = exports.JsonRpcSuccessStruct = exports.PendingJsonRpcResponseStruct = exports.assertIsJsonRpcRequest = exports.isJsonRpcRequest = exports.assertIsJsonRpcNotification = exports.isJsonRpcNotification = exports.JsonRpcNotificationStruct = exports.JsonRpcRequestStruct = exports.JsonRpcParamsStruct = exports.JsonRpcErrorStruct = exports.JsonRpcIdStruct = exports.JsonRpcVersionStruct = exports.jsonrpc2 = exports.getJsonSize = exports.isValidJson = exports.JsonStruct = exports.UnsafeJsonStruct = void 0;\nconst superstruct_1 = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\nconst assert_1 = __webpack_require__(/*! ./assert */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/assert.js\");\n/**\n * A struct to check if the given value is finite number. Superstruct's\n * `number()` struct does not check if the value is finite.\n *\n * @returns A struct to check if the given value is finite number.\n */ const finiteNumber = ()=>(0, superstruct_1.define)(\"finite number\", (value)=>{\n        return (0, superstruct_1.is)(value, (0, superstruct_1.number)()) && Number.isFinite(value);\n    });\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * Note that this struct is unsafe. For safe validation, use {@link JsonStruct}.\n */ // We cannot infer the type of the struct, because it is recursive.\nexports.UnsafeJsonStruct = (0, superstruct_1.union)([\n    (0, superstruct_1.literal)(null),\n    (0, superstruct_1.boolean)(),\n    finiteNumber(),\n    (0, superstruct_1.string)(),\n    (0, superstruct_1.array)((0, superstruct_1.lazy)(()=>exports.UnsafeJsonStruct)),\n    (0, superstruct_1.record)((0, superstruct_1.string)(), (0, superstruct_1.lazy)(()=>exports.UnsafeJsonStruct))\n]);\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * This struct sanitizes the value before validating it, so that it is safe to\n * use with untrusted input.\n */ exports.JsonStruct = (0, superstruct_1.define)(\"Json\", (value, context)=>{\n    /**\n     * Helper function that runs the given struct validator and returns the\n     * validation errors, if any. If the value is valid, it returns `true`.\n     *\n     * @param innerValue - The value to validate.\n     * @param struct - The struct to use for validation.\n     * @returns The validation errors, or `true` if the value is valid.\n     */ function checkStruct(innerValue, struct) {\n        const iterator = struct.validator(innerValue, context);\n        const errors = [\n            ...iterator\n        ];\n        if (errors.length > 0) {\n            return errors;\n        }\n        return true;\n    }\n    try {\n        // The plain value must be a valid JSON value, but it may be altered in the\n        // process of JSON serialization, so we need to validate it again after\n        // serialization. This has the added benefit that the returned error messages\n        // will be more helpful, as they will point to the exact location of the\n        // invalid value.\n        //\n        // This seems overcomplicated, but without checking the plain value first,\n        // there are some cases where the validation passes, even though the value is\n        // not valid JSON. For example, `undefined` is not valid JSON, but serializing\n        // it will remove it from the object, so the validation will pass.\n        const unsafeResult = checkStruct(value, exports.UnsafeJsonStruct);\n        if (unsafeResult !== true) {\n            return unsafeResult;\n        }\n        // JavaScript engines are highly optimized for this specific use case of\n        // JSON parsing and stringifying, so there should be no performance impact.\n        return checkStruct(JSON.parse(JSON.stringify(value)), exports.UnsafeJsonStruct);\n    } catch (error) {\n        if (error instanceof RangeError) {\n            return \"Circular reference detected\";\n        }\n        return false;\n    }\n});\n/**\n * Check if the given value is a valid {@link Json} value, i.e., a value that is\n * serializable to JSON.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid {@link Json} value.\n */ function isValidJson(value) {\n    return (0, superstruct_1.is)(value, exports.JsonStruct);\n}\nexports.isValidJson = isValidJson;\n/**\n * Get the size of a JSON value in bytes. This also validates the value.\n *\n * @param value - The JSON value to get the size of.\n * @returns The size of the JSON value in bytes.\n */ function getJsonSize(value) {\n    (0, assert_1.assertStruct)(value, exports.JsonStruct, \"Invalid JSON value\");\n    const json = JSON.stringify(value);\n    return new TextEncoder().encode(json).byteLength;\n}\nexports.getJsonSize = getJsonSize;\n/**\n * The string '2.0'.\n */ exports.jsonrpc2 = \"2.0\";\nexports.JsonRpcVersionStruct = (0, superstruct_1.literal)(exports.jsonrpc2);\nexports.JsonRpcIdStruct = (0, superstruct_1.nullable)((0, superstruct_1.union)([\n    (0, superstruct_1.number)(),\n    (0, superstruct_1.string)()\n]));\nexports.JsonRpcErrorStruct = (0, superstruct_1.object)({\n    code: (0, superstruct_1.integer)(),\n    message: (0, superstruct_1.string)(),\n    data: (0, superstruct_1.optional)(exports.JsonStruct),\n    stack: (0, superstruct_1.optional)((0, superstruct_1.string)())\n});\nexports.JsonRpcParamsStruct = (0, superstruct_1.optional)((0, superstruct_1.union)([\n    (0, superstruct_1.record)((0, superstruct_1.string)(), exports.JsonStruct),\n    (0, superstruct_1.array)(exports.JsonStruct)\n]));\nexports.JsonRpcRequestStruct = (0, superstruct_1.object)({\n    id: exports.JsonRpcIdStruct,\n    jsonrpc: exports.JsonRpcVersionStruct,\n    method: (0, superstruct_1.string)(),\n    params: exports.JsonRpcParamsStruct\n});\nexports.JsonRpcNotificationStruct = (0, superstruct_1.omit)(exports.JsonRpcRequestStruct, [\n    \"id\"\n]);\n/**\n * Check if the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcNotification}\n * object.\n */ function isJsonRpcNotification(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcNotificationStruct);\n}\nexports.isJsonRpcNotification = isJsonRpcNotification;\n/**\n * Assert that the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcNotification} object.\n */ function assertIsJsonRpcNotification(value, // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcNotificationStruct, \"Invalid JSON-RPC notification\", ErrorWrapper);\n}\nexports.assertIsJsonRpcNotification = assertIsJsonRpcNotification;\n/**\n * Check if the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcRequest} object.\n */ function isJsonRpcRequest(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcRequestStruct);\n}\nexports.isJsonRpcRequest = isJsonRpcRequest;\n/**\n * Assert that the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The JSON-RPC request or notification to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcRequest} object.\n */ function assertIsJsonRpcRequest(value, // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcRequestStruct, \"Invalid JSON-RPC request\", ErrorWrapper);\n}\nexports.assertIsJsonRpcRequest = assertIsJsonRpcRequest;\nexports.PendingJsonRpcResponseStruct = (0, superstruct_1.object)({\n    id: exports.JsonRpcIdStruct,\n    jsonrpc: exports.JsonRpcVersionStruct,\n    result: (0, superstruct_1.optional)((0, superstruct_1.unknown)()),\n    error: (0, superstruct_1.optional)(exports.JsonRpcErrorStruct)\n});\nexports.JsonRpcSuccessStruct = (0, superstruct_1.object)({\n    id: exports.JsonRpcIdStruct,\n    jsonrpc: exports.JsonRpcVersionStruct,\n    result: exports.JsonStruct\n});\nexports.JsonRpcFailureStruct = (0, superstruct_1.object)({\n    id: exports.JsonRpcIdStruct,\n    jsonrpc: exports.JsonRpcVersionStruct,\n    error: exports.JsonRpcErrorStruct\n});\nexports.JsonRpcResponseStruct = (0, superstruct_1.union)([\n    exports.JsonRpcSuccessStruct,\n    exports.JsonRpcFailureStruct\n]);\n/**\n * Type guard to check whether specified JSON-RPC response is a\n * {@link PendingJsonRpcResponse}.\n *\n * @param response - The JSON-RPC response to check.\n * @returns Whether the specified JSON-RPC response is pending.\n */ function isPendingJsonRpcResponse(response) {\n    return (0, superstruct_1.is)(response, exports.PendingJsonRpcResponseStruct);\n}\nexports.isPendingJsonRpcResponse = isPendingJsonRpcResponse;\n/**\n * Assert that the given value is a valid {@link PendingJsonRpcResponse} object.\n *\n * @param response - The JSON-RPC response to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link PendingJsonRpcResponse}\n * object.\n */ function assertIsPendingJsonRpcResponse(response, // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(response, exports.PendingJsonRpcResponseStruct, \"Invalid pending JSON-RPC response\", ErrorWrapper);\n}\nexports.assertIsPendingJsonRpcResponse = assertIsPendingJsonRpcResponse;\n/**\n * Type guard to check if a value is a {@link JsonRpcResponse}.\n *\n * @param response - The object to check.\n * @returns Whether the object is a JsonRpcResponse.\n */ function isJsonRpcResponse(response) {\n    return (0, superstruct_1.is)(response, exports.JsonRpcResponseStruct);\n}\nexports.isJsonRpcResponse = isJsonRpcResponse;\n/**\n * Assert that the given value is a valid {@link JsonRpcResponse} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcResponse} object.\n */ function assertIsJsonRpcResponse(value, // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcResponseStruct, \"Invalid JSON-RPC response\", ErrorWrapper);\n}\nexports.assertIsJsonRpcResponse = assertIsJsonRpcResponse;\n/**\n * Check if the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcSuccess} object.\n */ function isJsonRpcSuccess(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcSuccessStruct);\n}\nexports.isJsonRpcSuccess = isJsonRpcSuccess;\n/**\n * Assert that the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcSuccess} object.\n */ function assertIsJsonRpcSuccess(value, // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcSuccessStruct, \"Invalid JSON-RPC success response\", ErrorWrapper);\n}\nexports.assertIsJsonRpcSuccess = assertIsJsonRpcSuccess;\n/**\n * Check if the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcFailure} object.\n */ function isJsonRpcFailure(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcFailureStruct);\n}\nexports.isJsonRpcFailure = isJsonRpcFailure;\n/**\n * Assert that the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcFailure} object.\n */ function assertIsJsonRpcFailure(value, // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcFailureStruct, \"Invalid JSON-RPC failure response\", ErrorWrapper);\n}\nexports.assertIsJsonRpcFailure = assertIsJsonRpcFailure;\n/**\n * Check if the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcError} object.\n */ function isJsonRpcError(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcErrorStruct);\n}\nexports.isJsonRpcError = isJsonRpcError;\n/**\n * Assert that the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcError} object.\n */ function assertIsJsonRpcError(value, // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcErrorStruct, \"Invalid JSON-RPC error\", ErrorWrapper);\n}\nexports.assertIsJsonRpcError = assertIsJsonRpcError;\n/**\n * Gets a function for validating JSON-RPC request / response `id` values.\n *\n * By manipulating the options of this factory, you can control the behavior\n * of the resulting validator for some edge cases. This is useful because e.g.\n * `null` should sometimes but not always be permitted.\n *\n * Note that the empty string (`''`) is always permitted by the JSON-RPC\n * specification, but that kind of sucks and you may want to forbid it in some\n * instances anyway.\n *\n * For more details, see the\n * [JSON-RPC Specification](https://www.jsonrpc.org/specification).\n *\n * @param options - An options object.\n * @param options.permitEmptyString - Whether the empty string (i.e. `''`)\n * should be treated as a valid ID. Default: `true`\n * @param options.permitFractions - Whether fractional numbers (e.g. `1.2`)\n * should be treated as valid IDs. Default: `false`\n * @param options.permitNull - Whether `null` should be treated as a valid ID.\n * Default: `true`\n * @returns The JSON-RPC ID validator function.\n */ function getJsonRpcIdValidator(options) {\n    const { permitEmptyString, permitFractions, permitNull } = Object.assign({\n        permitEmptyString: true,\n        permitFractions: false,\n        permitNull: true\n    }, options);\n    /**\n     * Type guard for {@link JsonRpcId}.\n     *\n     * @param id - The JSON-RPC ID value to check.\n     * @returns Whether the given ID is valid per the options given to the\n     * factory.\n     */ const isValidJsonRpcId = (id)=>{\n        return Boolean(typeof id === \"number\" && (permitFractions || Number.isInteger(id)) || typeof id === \"string\" && (permitEmptyString || id.length > 0) || permitNull && id === null);\n    };\n    return isValidJsonRpcId;\n}\nexports.getJsonRpcIdValidator = getJsonRpcIdValidator; //# sourceMappingURL=json.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2pzb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDZCQUE2QixHQUFHQSw0QkFBNEIsR0FBR0Esc0JBQXNCLEdBQUdBLDhCQUE4QixHQUFHQSx3QkFBd0IsR0FBR0EsOEJBQThCLEdBQUdBLHdCQUF3QixHQUFHQSwrQkFBK0IsR0FBR0EseUJBQXlCLEdBQUdBLHNDQUFzQyxHQUFHQSxnQ0FBZ0MsR0FBR0EsNkJBQTZCLEdBQUdBLDRCQUE0QixHQUFHQSw0QkFBNEIsR0FBR0Esb0NBQW9DLEdBQUdBLDhCQUE4QixHQUFHQSx3QkFBd0IsR0FBR0EsbUNBQW1DLEdBQUdBLDZCQUE2QixHQUFHQSxpQ0FBaUMsR0FBR0EsNEJBQTRCLEdBQUdBLDJCQUEyQixHQUFHQSwwQkFBMEIsR0FBR0EsdUJBQXVCLEdBQUdBLDRCQUE0QixHQUFHQSxnQkFBZ0IsR0FBR0EsbUJBQW1CLEdBQUdBLG1CQUFtQixHQUFHQSxrQkFBa0IsR0FBR0Esd0JBQXdCLEdBQUcsS0FBSztBQUM1NEIsTUFBTWdDLGdCQUFnQkMsbUJBQU9BLENBQUMsb0VBQWE7QUFDM0MsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMsb0dBQVU7QUFDbkM7Ozs7O0NBS0MsR0FDRCxNQUFNRSxlQUFlLElBQU0sQ0FBQyxHQUFHSCxjQUFjSSxNQUFNLEVBQUUsaUJBQWlCLENBQUNuQztRQUNuRSxPQUFPLENBQUMsR0FBRytCLGNBQWNLLEVBQUUsRUFBRXBDLE9BQU8sQ0FBQyxHQUFHK0IsY0FBY00sTUFBTSxRQUFRQyxPQUFPQyxRQUFRLENBQUN2QztJQUN4RjtBQUNBOzs7O0NBSUMsR0FDRCxtRUFBbUU7QUFDbkVELHdCQUF3QixHQUFHLENBQUMsR0FBR2dDLGNBQWNTLEtBQUssRUFBRTtJQUMvQyxJQUFHVCxjQUFjVSxPQUFPLEVBQUU7SUFDMUIsSUFBR1YsY0FBY1csT0FBTztJQUN6QlI7SUFDQyxJQUFHSCxjQUFjWSxNQUFNO0lBQ3ZCLElBQUdaLGNBQWNhLEtBQUssRUFBRSxDQUFDLEdBQUdiLGNBQWNjLElBQUksRUFBRSxJQUFNOUMsUUFBUStCLGdCQUFnQjtJQUM5RSxJQUFHQyxjQUFjZSxNQUFNLEVBQUUsQ0FBQyxHQUFHZixjQUFjWSxNQUFNLEtBQUssQ0FBQyxHQUFHWixjQUFjYyxJQUFJLEVBQUUsSUFBTTlDLFFBQVErQixnQkFBZ0I7Q0FDaEg7QUFDRDs7Ozs7Q0FLQyxHQUNEL0Isa0JBQWtCLEdBQUcsQ0FBQyxHQUFHZ0MsY0FBY0ksTUFBTSxFQUFFLFFBQVEsQ0FBQ25DLE9BQU8rQztJQUMzRDs7Ozs7OztLQU9DLEdBQ0QsU0FBU0MsWUFBWUMsVUFBVSxFQUFFQyxNQUFNO1FBQ25DLE1BQU1DLFdBQVdELE9BQU9FLFNBQVMsQ0FBQ0gsWUFBWUY7UUFDOUMsTUFBTU0sU0FBUztlQUFJRjtTQUFTO1FBQzVCLElBQUlFLE9BQU9DLE1BQU0sR0FBRyxHQUFHO1lBQ25CLE9BQU9EO1FBQ1g7UUFDQSxPQUFPO0lBQ1g7SUFDQSxJQUFJO1FBQ0EsMkVBQTJFO1FBQzNFLHVFQUF1RTtRQUN2RSw2RUFBNkU7UUFDN0Usd0VBQXdFO1FBQ3hFLGlCQUFpQjtRQUNqQixFQUFFO1FBQ0YsMEVBQTBFO1FBQzFFLDZFQUE2RTtRQUM3RSw4RUFBOEU7UUFDOUUsa0VBQWtFO1FBQ2xFLE1BQU1FLGVBQWVQLFlBQVloRCxPQUFPRCxRQUFRK0IsZ0JBQWdCO1FBQ2hFLElBQUl5QixpQkFBaUIsTUFBTTtZQUN2QixPQUFPQTtRQUNYO1FBQ0Esd0VBQXdFO1FBQ3hFLDJFQUEyRTtRQUMzRSxPQUFPUCxZQUFZUSxLQUFLQyxLQUFLLENBQUNELEtBQUtFLFNBQVMsQ0FBQzFELFNBQVNELFFBQVErQixnQkFBZ0I7SUFDbEYsRUFDQSxPQUFPNkIsT0FBTztRQUNWLElBQUlBLGlCQUFpQkMsWUFBWTtZQUM3QixPQUFPO1FBQ1g7UUFDQSxPQUFPO0lBQ1g7QUFDSjtBQUNBOzs7Ozs7Q0FNQyxHQUNELFNBQVNoQyxZQUFZNUIsS0FBSztJQUN0QixPQUFPLENBQUMsR0FBRytCLGNBQWNLLEVBQUUsRUFBRXBDLE9BQU9ELFFBQVE4QixVQUFVO0FBQzFEO0FBQ0E5QixtQkFBbUIsR0FBRzZCO0FBQ3RCOzs7OztDQUtDLEdBQ0QsU0FBU0QsWUFBWTNCLEtBQUs7SUFDckIsSUFBR2lDLFNBQVM0QixZQUFZLEVBQUU3RCxPQUFPRCxRQUFROEIsVUFBVSxFQUFFO0lBQ3RELE1BQU1pQyxPQUFPTixLQUFLRSxTQUFTLENBQUMxRDtJQUM1QixPQUFPLElBQUkrRCxjQUFjQyxNQUFNLENBQUNGLE1BQU1HLFVBQVU7QUFDcEQ7QUFDQWxFLG1CQUFtQixHQUFHNEI7QUFDdEI7O0NBRUMsR0FDRDVCLGdCQUFnQixHQUFHO0FBQ25CQSw0QkFBNEIsR0FBRyxDQUFDLEdBQUdnQyxjQUFjVSxPQUFPLEVBQUUxQyxRQUFRMkIsUUFBUTtBQUMxRTNCLHVCQUF1QixHQUFHLENBQUMsR0FBR2dDLGNBQWNtQyxRQUFRLEVBQUUsQ0FBQyxHQUFHbkMsY0FBY1MsS0FBSyxFQUFFO0lBQUUsSUFBR1QsY0FBY00sTUFBTTtJQUFNLElBQUdOLGNBQWNZLE1BQU07Q0FBSTtBQUN6STVDLDBCQUEwQixHQUFHLENBQUMsR0FBR2dDLGNBQWNvQyxNQUFNLEVBQUU7SUFDbkRDLE1BQU0sQ0FBQyxHQUFHckMsY0FBY3NDLE9BQU87SUFDL0JDLFNBQVMsQ0FBQyxHQUFHdkMsY0FBY1ksTUFBTTtJQUNqQzRCLE1BQU0sQ0FBQyxHQUFHeEMsY0FBY3lDLFFBQVEsRUFBRXpFLFFBQVE4QixVQUFVO0lBQ3BENEMsT0FBTyxDQUFDLEdBQUcxQyxjQUFjeUMsUUFBUSxFQUFFLENBQUMsR0FBR3pDLGNBQWNZLE1BQU07QUFDL0Q7QUFDQTVDLDJCQUEyQixHQUFHLENBQUMsR0FBR2dDLGNBQWN5QyxRQUFRLEVBQUUsQ0FBQyxHQUFHekMsY0FBY1MsS0FBSyxFQUFFO0lBQUUsSUFBR1QsY0FBY2UsTUFBTSxFQUFFLENBQUMsR0FBR2YsY0FBY1ksTUFBTSxLQUFLNUMsUUFBUThCLFVBQVU7SUFBSSxJQUFHRSxjQUFjYSxLQUFLLEVBQUU3QyxRQUFROEIsVUFBVTtDQUFFO0FBQzdNOUIsNEJBQTRCLEdBQUcsQ0FBQyxHQUFHZ0MsY0FBY29DLE1BQU0sRUFBRTtJQUNyRE8sSUFBSTNFLFFBQVF5QixlQUFlO0lBQzNCbUQsU0FBUzVFLFFBQVEwQixvQkFBb0I7SUFDckNtRCxRQUFRLENBQUMsR0FBRzdDLGNBQWNZLE1BQU07SUFDaENrQyxRQUFROUUsUUFBUXVCLG1CQUFtQjtBQUN2QztBQUNBdkIsaUNBQWlDLEdBQUcsQ0FBQyxHQUFHZ0MsY0FBYytDLElBQUksRUFBRS9FLFFBQVFzQixvQkFBb0IsRUFBRTtJQUFDO0NBQUs7QUFDaEc7Ozs7OztDQU1DLEdBQ0QsU0FBU0Ysc0JBQXNCbkIsS0FBSztJQUNoQyxPQUFPLENBQUMsR0FBRytCLGNBQWNLLEVBQUUsRUFBRXBDLE9BQU9ELFFBQVFxQix5QkFBeUI7QUFDekU7QUFDQXJCLDZCQUE2QixHQUFHb0I7QUFDaEM7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNELDRCQUE0QmxCLEtBQUssRUFDMUMsZ0VBQWdFO0FBQ2hFK0UsWUFBWTtJQUNQLElBQUc5QyxTQUFTNEIsWUFBWSxFQUFFN0QsT0FBT0QsUUFBUXFCLHlCQUF5QixFQUFFLGlDQUFpQzJEO0FBQzFHO0FBQ0FoRixtQ0FBbUMsR0FBR21CO0FBQ3RDOzs7OztDQUtDLEdBQ0QsU0FBU0QsaUJBQWlCakIsS0FBSztJQUMzQixPQUFPLENBQUMsR0FBRytCLGNBQWNLLEVBQUUsRUFBRXBDLE9BQU9ELFFBQVFzQixvQkFBb0I7QUFDcEU7QUFDQXRCLHdCQUF3QixHQUFHa0I7QUFDM0I7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNELHVCQUF1QmhCLEtBQUssRUFDckMsZ0VBQWdFO0FBQ2hFK0UsWUFBWTtJQUNQLElBQUc5QyxTQUFTNEIsWUFBWSxFQUFFN0QsT0FBT0QsUUFBUXNCLG9CQUFvQixFQUFFLDRCQUE0QjBEO0FBQ2hHO0FBQ0FoRiw4QkFBOEIsR0FBR2lCO0FBQ2pDakIsb0NBQW9DLEdBQUcsQ0FBQyxHQUFHZ0MsY0FBY29DLE1BQU0sRUFBRTtJQUM3RE8sSUFBSTNFLFFBQVF5QixlQUFlO0lBQzNCbUQsU0FBUzVFLFFBQVEwQixvQkFBb0I7SUFDckN1RCxRQUFRLENBQUMsR0FBR2pELGNBQWN5QyxRQUFRLEVBQUUsQ0FBQyxHQUFHekMsY0FBY2tELE9BQU87SUFDN0R0QixPQUFPLENBQUMsR0FBRzVCLGNBQWN5QyxRQUFRLEVBQUV6RSxRQUFRd0Isa0JBQWtCO0FBQ2pFO0FBQ0F4Qiw0QkFBNEIsR0FBRyxDQUFDLEdBQUdnQyxjQUFjb0MsTUFBTSxFQUFFO0lBQ3JETyxJQUFJM0UsUUFBUXlCLGVBQWU7SUFDM0JtRCxTQUFTNUUsUUFBUTBCLG9CQUFvQjtJQUNyQ3VELFFBQVFqRixRQUFROEIsVUFBVTtBQUM5QjtBQUNBOUIsNEJBQTRCLEdBQUcsQ0FBQyxHQUFHZ0MsY0FBY29DLE1BQU0sRUFBRTtJQUNyRE8sSUFBSTNFLFFBQVF5QixlQUFlO0lBQzNCbUQsU0FBUzVFLFFBQVEwQixvQkFBb0I7SUFDckNrQyxPQUFPNUQsUUFBUXdCLGtCQUFrQjtBQUNyQztBQUNBeEIsNkJBQTZCLEdBQUcsQ0FBQyxHQUFHZ0MsY0FBY1MsS0FBSyxFQUFFO0lBQ3JEekMsUUFBUWUsb0JBQW9CO0lBQzVCZixRQUFRYyxvQkFBb0I7Q0FDL0I7QUFDRDs7Ozs7O0NBTUMsR0FDRCxTQUFTRix5QkFBeUJ1RSxRQUFRO0lBQ3RDLE9BQU8sQ0FBQyxHQUFHbkQsY0FBY0ssRUFBRSxFQUFFOEMsVUFBVW5GLFFBQVFnQiw0QkFBNEI7QUFDL0U7QUFDQWhCLGdDQUFnQyxHQUFHWTtBQUNuQzs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVNELCtCQUErQndFLFFBQVEsRUFDaEQsZ0VBQWdFO0FBQ2hFSCxZQUFZO0lBQ1AsSUFBRzlDLFNBQVM0QixZQUFZLEVBQUVxQixVQUFVbkYsUUFBUWdCLDRCQUE0QixFQUFFLHFDQUFxQ2dFO0FBQ3BIO0FBQ0FoRixzQ0FBc0MsR0FBR1c7QUFDekM7Ozs7O0NBS0MsR0FDRCxTQUFTRCxrQkFBa0J5RSxRQUFRO0lBQy9CLE9BQU8sQ0FBQyxHQUFHbkQsY0FBY0ssRUFBRSxFQUFFOEMsVUFBVW5GLFFBQVFhLHFCQUFxQjtBQUN4RTtBQUNBYix5QkFBeUIsR0FBR1U7QUFDNUI7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNELHdCQUF3QlIsS0FBSyxFQUN0QyxnRUFBZ0U7QUFDaEUrRSxZQUFZO0lBQ1AsSUFBRzlDLFNBQVM0QixZQUFZLEVBQUU3RCxPQUFPRCxRQUFRYSxxQkFBcUIsRUFBRSw2QkFBNkJtRTtBQUNsRztBQUNBaEYsK0JBQStCLEdBQUdTO0FBQ2xDOzs7OztDQUtDLEdBQ0QsU0FBU0QsaUJBQWlCUCxLQUFLO0lBQzNCLE9BQU8sQ0FBQyxHQUFHK0IsY0FBY0ssRUFBRSxFQUFFcEMsT0FBT0QsUUFBUWUsb0JBQW9CO0FBQ3BFO0FBQ0FmLHdCQUF3QixHQUFHUTtBQUMzQjs7Ozs7OztDQU9DLEdBQ0QsU0FBU0QsdUJBQXVCTixLQUFLLEVBQ3JDLGdFQUFnRTtBQUNoRStFLFlBQVk7SUFDUCxJQUFHOUMsU0FBUzRCLFlBQVksRUFBRTdELE9BQU9ELFFBQVFlLG9CQUFvQixFQUFFLHFDQUFxQ2lFO0FBQ3pHO0FBQ0FoRiw4QkFBOEIsR0FBR087QUFDakM7Ozs7O0NBS0MsR0FDRCxTQUFTRCxpQkFBaUJMLEtBQUs7SUFDM0IsT0FBTyxDQUFDLEdBQUcrQixjQUFjSyxFQUFFLEVBQUVwQyxPQUFPRCxRQUFRYyxvQkFBb0I7QUFDcEU7QUFDQWQsd0JBQXdCLEdBQUdNO0FBQzNCOzs7Ozs7O0NBT0MsR0FDRCxTQUFTRCx1QkFBdUJKLEtBQUssRUFDckMsZ0VBQWdFO0FBQ2hFK0UsWUFBWTtJQUNQLElBQUc5QyxTQUFTNEIsWUFBWSxFQUFFN0QsT0FBT0QsUUFBUWMsb0JBQW9CLEVBQUUscUNBQXFDa0U7QUFDekc7QUFDQWhGLDhCQUE4QixHQUFHSztBQUNqQzs7Ozs7Q0FLQyxHQUNELFNBQVNELGVBQWVILEtBQUs7SUFDekIsT0FBTyxDQUFDLEdBQUcrQixjQUFjSyxFQUFFLEVBQUVwQyxPQUFPRCxRQUFRd0Isa0JBQWtCO0FBQ2xFO0FBQ0F4QixzQkFBc0IsR0FBR0k7QUFDekI7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNELHFCQUFxQkYsS0FBSyxFQUNuQyxnRUFBZ0U7QUFDaEUrRSxZQUFZO0lBQ1AsSUFBRzlDLFNBQVM0QixZQUFZLEVBQUU3RCxPQUFPRCxRQUFRd0Isa0JBQWtCLEVBQUUsMEJBQTBCd0Q7QUFDNUY7QUFDQWhGLDRCQUE0QixHQUFHRztBQUMvQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXNCQyxHQUNELFNBQVNELHNCQUFzQmtGLE9BQU87SUFDbEMsTUFBTSxFQUFFQyxpQkFBaUIsRUFBRUMsZUFBZSxFQUFFQyxVQUFVLEVBQUUsR0FBR3pGLE9BQU8wRixNQUFNLENBQUM7UUFBRUgsbUJBQW1CO1FBQU1DLGlCQUFpQjtRQUFPQyxZQUFZO0lBQUssR0FBR0g7SUFDaEo7Ozs7OztLQU1DLEdBQ0QsTUFBTUssbUJBQW1CLENBQUNkO1FBQ3RCLE9BQU9lLFFBQVEsT0FBUWYsT0FBTyxZQUFhVyxDQUFBQSxtQkFBbUIvQyxPQUFPb0QsU0FBUyxDQUFDaEIsR0FBRSxLQUM1RSxPQUFPQSxPQUFPLFlBQWFVLENBQUFBLHFCQUFxQlYsR0FBR3BCLE1BQU0sR0FBRyxNQUM1RGdDLGNBQWNaLE9BQU87SUFDOUI7SUFDQSxPQUFPYztBQUNYO0FBQ0F6Riw2QkFBNkIsR0FBR0UsdUJBQ2hDLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL3N0YWJsZS1yb3V0ZXItd2ViLy4vbm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9qc29uLmpzP2I3M2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEpzb25ScGNJZFZhbGlkYXRvciA9IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjRXJyb3IgPSBleHBvcnRzLmlzSnNvblJwY0Vycm9yID0gZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNGYWlsdXJlID0gZXhwb3J0cy5pc0pzb25ScGNGYWlsdXJlID0gZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNTdWNjZXNzID0gZXhwb3J0cy5pc0pzb25ScGNTdWNjZXNzID0gZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNSZXNwb25zZSA9IGV4cG9ydHMuaXNKc29uUnBjUmVzcG9uc2UgPSBleHBvcnRzLmFzc2VydElzUGVuZGluZ0pzb25ScGNSZXNwb25zZSA9IGV4cG9ydHMuaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlID0gZXhwb3J0cy5Kc29uUnBjUmVzcG9uc2VTdHJ1Y3QgPSBleHBvcnRzLkpzb25ScGNGYWlsdXJlU3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjU3VjY2Vzc1N0cnVjdCA9IGV4cG9ydHMuUGVuZGluZ0pzb25ScGNSZXNwb25zZVN0cnVjdCA9IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjUmVxdWVzdCA9IGV4cG9ydHMuaXNKc29uUnBjUmVxdWVzdCA9IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjTm90aWZpY2F0aW9uID0gZXhwb3J0cy5pc0pzb25ScGNOb3RpZmljYXRpb24gPSBleHBvcnRzLkpzb25ScGNOb3RpZmljYXRpb25TdHJ1Y3QgPSBleHBvcnRzLkpzb25ScGNSZXF1ZXN0U3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjUGFyYW1zU3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjRXJyb3JTdHJ1Y3QgPSBleHBvcnRzLkpzb25ScGNJZFN0cnVjdCA9IGV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QgPSBleHBvcnRzLmpzb25ycGMyID0gZXhwb3J0cy5nZXRKc29uU2l6ZSA9IGV4cG9ydHMuaXNWYWxpZEpzb24gPSBleHBvcnRzLkpzb25TdHJ1Y3QgPSBleHBvcnRzLlVuc2FmZUpzb25TdHJ1Y3QgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcInN1cGVyc3RydWN0XCIpO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnRcIik7XG4vKipcbiAqIEEgc3RydWN0IHRvIGNoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBmaW5pdGUgbnVtYmVyLiBTdXBlcnN0cnVjdCdzXG4gKiBgbnVtYmVyKClgIHN0cnVjdCBkb2VzIG5vdCBjaGVjayBpZiB0aGUgdmFsdWUgaXMgZmluaXRlLlxuICpcbiAqIEByZXR1cm5zIEEgc3RydWN0IHRvIGNoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBmaW5pdGUgbnVtYmVyLlxuICovXG5jb25zdCBmaW5pdGVOdW1iZXIgPSAoKSA9PiAoMCwgc3VwZXJzdHJ1Y3RfMS5kZWZpbmUpKCdmaW5pdGUgbnVtYmVyJywgKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgKDAsIHN1cGVyc3RydWN0XzEubnVtYmVyKSgpKSAmJiBOdW1iZXIuaXNGaW5pdGUodmFsdWUpO1xufSk7XG4vKipcbiAqIEEgc3RydWN0IHRvIGNoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIEpTT04tc2VyaWFsaXphYmxlIHZhbHVlLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIHN0cnVjdCBpcyB1bnNhZmUuIEZvciBzYWZlIHZhbGlkYXRpb24sIHVzZSB7QGxpbmsgSnNvblN0cnVjdH0uXG4gKi9cbi8vIFdlIGNhbm5vdCBpbmZlciB0aGUgdHlwZSBvZiB0aGUgc3RydWN0LCBiZWNhdXNlIGl0IGlzIHJlY3Vyc2l2ZS5cbmV4cG9ydHMuVW5zYWZlSnNvblN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbXG4gICAgKDAsIHN1cGVyc3RydWN0XzEubGl0ZXJhbCkobnVsbCksXG4gICAgKDAsIHN1cGVyc3RydWN0XzEuYm9vbGVhbikoKSxcbiAgICBmaW5pdGVOdW1iZXIoKSxcbiAgICAoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksXG4gICAgKDAsIHN1cGVyc3RydWN0XzEuYXJyYXkpKCgwLCBzdXBlcnN0cnVjdF8xLmxhenkpKCgpID0+IGV4cG9ydHMuVW5zYWZlSnNvblN0cnVjdCkpLFxuICAgICgwLCBzdXBlcnN0cnVjdF8xLnJlY29yZCkoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCAoMCwgc3VwZXJzdHJ1Y3RfMS5sYXp5KSgoKSA9PiBleHBvcnRzLlVuc2FmZUpzb25TdHJ1Y3QpKSxcbl0pO1xuLyoqXG4gKiBBIHN0cnVjdCB0byBjaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCBKU09OLXNlcmlhbGl6YWJsZSB2YWx1ZS5cbiAqXG4gKiBUaGlzIHN0cnVjdCBzYW5pdGl6ZXMgdGhlIHZhbHVlIGJlZm9yZSB2YWxpZGF0aW5nIGl0LCBzbyB0aGF0IGl0IGlzIHNhZmUgdG9cbiAqIHVzZSB3aXRoIHVudHJ1c3RlZCBpbnB1dC5cbiAqL1xuZXhwb3J0cy5Kc29uU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEuZGVmaW5lKSgnSnNvbicsICh2YWx1ZSwgY29udGV4dCkgPT4ge1xuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IHJ1bnMgdGhlIGdpdmVuIHN0cnVjdCB2YWxpZGF0b3IgYW5kIHJldHVybnMgdGhlXG4gICAgICogdmFsaWRhdGlvbiBlcnJvcnMsIGlmIGFueS4gSWYgdGhlIHZhbHVlIGlzIHZhbGlkLCBpdCByZXR1cm5zIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbm5lclZhbHVlIC0gVGhlIHZhbHVlIHRvIHZhbGlkYXRlLlxuICAgICAqIEBwYXJhbSBzdHJ1Y3QgLSBUaGUgc3RydWN0IHRvIHVzZSBmb3IgdmFsaWRhdGlvbi5cbiAgICAgKiBAcmV0dXJucyBUaGUgdmFsaWRhdGlvbiBlcnJvcnMsIG9yIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgdmFsaWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hlY2tTdHJ1Y3QoaW5uZXJWYWx1ZSwgc3RydWN0KSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gc3RydWN0LnZhbGlkYXRvcihpbm5lclZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgY29uc3QgZXJyb3JzID0gWy4uLml0ZXJhdG9yXTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyBUaGUgcGxhaW4gdmFsdWUgbXVzdCBiZSBhIHZhbGlkIEpTT04gdmFsdWUsIGJ1dCBpdCBtYXkgYmUgYWx0ZXJlZCBpbiB0aGVcbiAgICAgICAgLy8gcHJvY2VzcyBvZiBKU09OIHNlcmlhbGl6YXRpb24sIHNvIHdlIG5lZWQgdG8gdmFsaWRhdGUgaXQgYWdhaW4gYWZ0ZXJcbiAgICAgICAgLy8gc2VyaWFsaXphdGlvbi4gVGhpcyBoYXMgdGhlIGFkZGVkIGJlbmVmaXQgdGhhdCB0aGUgcmV0dXJuZWQgZXJyb3IgbWVzc2FnZXNcbiAgICAgICAgLy8gd2lsbCBiZSBtb3JlIGhlbHBmdWwsIGFzIHRoZXkgd2lsbCBwb2ludCB0byB0aGUgZXhhY3QgbG9jYXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGludmFsaWQgdmFsdWUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoaXMgc2VlbXMgb3ZlcmNvbXBsaWNhdGVkLCBidXQgd2l0aG91dCBjaGVja2luZyB0aGUgcGxhaW4gdmFsdWUgZmlyc3QsXG4gICAgICAgIC8vIHRoZXJlIGFyZSBzb21lIGNhc2VzIHdoZXJlIHRoZSB2YWxpZGF0aW9uIHBhc3NlcywgZXZlbiB0aG91Z2ggdGhlIHZhbHVlIGlzXG4gICAgICAgIC8vIG5vdCB2YWxpZCBKU09OLiBGb3IgZXhhbXBsZSwgYHVuZGVmaW5lZGAgaXMgbm90IHZhbGlkIEpTT04sIGJ1dCBzZXJpYWxpemluZ1xuICAgICAgICAvLyBpdCB3aWxsIHJlbW92ZSBpdCBmcm9tIHRoZSBvYmplY3QsIHNvIHRoZSB2YWxpZGF0aW9uIHdpbGwgcGFzcy5cbiAgICAgICAgY29uc3QgdW5zYWZlUmVzdWx0ID0gY2hlY2tTdHJ1Y3QodmFsdWUsIGV4cG9ydHMuVW5zYWZlSnNvblN0cnVjdCk7XG4gICAgICAgIGlmICh1bnNhZmVSZXN1bHQgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB1bnNhZmVSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSmF2YVNjcmlwdCBlbmdpbmVzIGFyZSBoaWdobHkgb3B0aW1pemVkIGZvciB0aGlzIHNwZWNpZmljIHVzZSBjYXNlIG9mXG4gICAgICAgIC8vIEpTT04gcGFyc2luZyBhbmQgc3RyaW5naWZ5aW5nLCBzbyB0aGVyZSBzaG91bGQgYmUgbm8gcGVyZm9ybWFuY2UgaW1wYWN0LlxuICAgICAgICByZXR1cm4gY2hlY2tTdHJ1Y3QoSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpLCBleHBvcnRzLlVuc2FmZUpzb25TdHJ1Y3QpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgUmFuZ2VFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuICdDaXJjdWxhciByZWZlcmVuY2UgZGV0ZWN0ZWQnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59KTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb259IHZhbHVlLCBpLmUuLCBhIHZhbHVlIHRoYXQgaXNcbiAqIHNlcmlhbGl6YWJsZSB0byBKU09OLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb259IHZhbHVlLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkSnNvbih2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuSnNvblN0cnVjdCk7XG59XG5leHBvcnRzLmlzVmFsaWRKc29uID0gaXNWYWxpZEpzb247XG4vKipcbiAqIEdldCB0aGUgc2l6ZSBvZiBhIEpTT04gdmFsdWUgaW4gYnl0ZXMuIFRoaXMgYWxzbyB2YWxpZGF0ZXMgdGhlIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBKU09OIHZhbHVlIHRvIGdldCB0aGUgc2l6ZSBvZi5cbiAqIEByZXR1cm5zIFRoZSBzaXplIG9mIHRoZSBKU09OIHZhbHVlIGluIGJ5dGVzLlxuICovXG5mdW5jdGlvbiBnZXRKc29uU2l6ZSh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZhbHVlLCBleHBvcnRzLkpzb25TdHJ1Y3QsICdJbnZhbGlkIEpTT04gdmFsdWUnKTtcbiAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoanNvbikuYnl0ZUxlbmd0aDtcbn1cbmV4cG9ydHMuZ2V0SnNvblNpemUgPSBnZXRKc29uU2l6ZTtcbi8qKlxuICogVGhlIHN0cmluZyAnMi4wJy5cbiAqL1xuZXhwb3J0cy5qc29ucnBjMiA9ICcyLjAnO1xuZXhwb3J0cy5Kc29uUnBjVmVyc2lvblN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLmxpdGVyYWwpKGV4cG9ydHMuanNvbnJwYzIpO1xuZXhwb3J0cy5Kc29uUnBjSWRTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5udWxsYWJsZSkoKDAsIHN1cGVyc3RydWN0XzEudW5pb24pKFsoMCwgc3VwZXJzdHJ1Y3RfMS5udW1iZXIpKCksICgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKV0pKTtcbmV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEub2JqZWN0KSh7XG4gICAgY29kZTogKDAsIHN1cGVyc3RydWN0XzEuaW50ZWdlcikoKSxcbiAgICBtZXNzYWdlOiAoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksXG4gICAgZGF0YTogKDAsIHN1cGVyc3RydWN0XzEub3B0aW9uYWwpKGV4cG9ydHMuSnNvblN0cnVjdCksXG4gICAgc3RhY2s6ICgwLCBzdXBlcnN0cnVjdF8xLm9wdGlvbmFsKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCkpLFxufSk7XG5leHBvcnRzLkpzb25ScGNQYXJhbXNTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5vcHRpb25hbCkoKDAsIHN1cGVyc3RydWN0XzEudW5pb24pKFsoMCwgc3VwZXJzdHJ1Y3RfMS5yZWNvcmQpKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgZXhwb3J0cy5Kc29uU3RydWN0KSwgKDAsIHN1cGVyc3RydWN0XzEuYXJyYXkpKGV4cG9ydHMuSnNvblN0cnVjdCldKSk7XG5leHBvcnRzLkpzb25ScGNSZXF1ZXN0U3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEub2JqZWN0KSh7XG4gICAgaWQ6IGV4cG9ydHMuSnNvblJwY0lkU3RydWN0LFxuICAgIGpzb25ycGM6IGV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gICAgbWV0aG9kOiAoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksXG4gICAgcGFyYW1zOiBleHBvcnRzLkpzb25ScGNQYXJhbXNTdHJ1Y3QsXG59KTtcbmV4cG9ydHMuSnNvblJwY05vdGlmaWNhdGlvblN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLm9taXQpKGV4cG9ydHMuSnNvblJwY1JlcXVlc3RTdHJ1Y3QsIFsnaWQnXSk7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjTm90aWZpY2F0aW9ufSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY05vdGlmaWNhdGlvbn1cbiAqIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNKc29uUnBjTm90aWZpY2F0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjTm90aWZpY2F0aW9uU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjTm90aWZpY2F0aW9uID0gaXNKc29uUnBjTm90aWZpY2F0aW9uO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY05vdGlmaWNhdGlvbn0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY05vdGlmaWNhdGlvbn0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0pzb25ScGNOb3RpZmljYXRpb24odmFsdWUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmFsdWUsIGV4cG9ydHMuSnNvblJwY05vdGlmaWNhdGlvblN0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgbm90aWZpY2F0aW9uJywgRXJyb3JXcmFwcGVyKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjTm90aWZpY2F0aW9uID0gYXNzZXJ0SXNKc29uUnBjTm90aWZpY2F0aW9uO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1JlcXVlc3R9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVxdWVzdH0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNSZXF1ZXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjUmVxdWVzdFN0cnVjdCk7XG59XG5leHBvcnRzLmlzSnNvblJwY1JlcXVlc3QgPSBpc0pzb25ScGNSZXF1ZXN0O1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1JlcXVlc3R9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgSlNPTi1SUEMgcmVxdWVzdCBvciBub3RpZmljYXRpb24gdG8gY2hlY2suXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQge0BsaW5rIEpzb25ScGNSZXF1ZXN0fSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY1JlcXVlc3QodmFsdWUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmFsdWUsIGV4cG9ydHMuSnNvblJwY1JlcXVlc3RTdHJ1Y3QsICdJbnZhbGlkIEpTT04tUlBDIHJlcXVlc3QnLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNSZXF1ZXN0ID0gYXNzZXJ0SXNKc29uUnBjUmVxdWVzdDtcbmV4cG9ydHMuUGVuZGluZ0pzb25ScGNSZXNwb25zZVN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLm9iamVjdCkoe1xuICAgIGlkOiBleHBvcnRzLkpzb25ScGNJZFN0cnVjdCxcbiAgICBqc29ucnBjOiBleHBvcnRzLkpzb25ScGNWZXJzaW9uU3RydWN0LFxuICAgIHJlc3VsdDogKDAsIHN1cGVyc3RydWN0XzEub3B0aW9uYWwpKCgwLCBzdXBlcnN0cnVjdF8xLnVua25vd24pKCkpLFxuICAgIGVycm9yOiAoMCwgc3VwZXJzdHJ1Y3RfMS5vcHRpb25hbCkoZXhwb3J0cy5Kc29uUnBjRXJyb3JTdHJ1Y3QpLFxufSk7XG5leHBvcnRzLkpzb25ScGNTdWNjZXNzU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEub2JqZWN0KSh7XG4gICAgaWQ6IGV4cG9ydHMuSnNvblJwY0lkU3RydWN0LFxuICAgIGpzb25ycGM6IGV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gICAgcmVzdWx0OiBleHBvcnRzLkpzb25TdHJ1Y3QsXG59KTtcbmV4cG9ydHMuSnNvblJwY0ZhaWx1cmVTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5vYmplY3QpKHtcbiAgICBpZDogZXhwb3J0cy5Kc29uUnBjSWRTdHJ1Y3QsXG4gICAganNvbnJwYzogZXhwb3J0cy5Kc29uUnBjVmVyc2lvblN0cnVjdCxcbiAgICBlcnJvcjogZXhwb3J0cy5Kc29uUnBjRXJyb3JTdHJ1Y3QsXG59KTtcbmV4cG9ydHMuSnNvblJwY1Jlc3BvbnNlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEudW5pb24pKFtcbiAgICBleHBvcnRzLkpzb25ScGNTdWNjZXNzU3RydWN0LFxuICAgIGV4cG9ydHMuSnNvblJwY0ZhaWx1cmVTdHJ1Y3QsXG5dKTtcbi8qKlxuICogVHlwZSBndWFyZCB0byBjaGVjayB3aGV0aGVyIHNwZWNpZmllZCBKU09OLVJQQyByZXNwb25zZSBpcyBhXG4gKiB7QGxpbmsgUGVuZGluZ0pzb25ScGNSZXNwb25zZX0uXG4gKlxuICogQHBhcmFtIHJlc3BvbnNlIC0gVGhlIEpTT04tUlBDIHJlc3BvbnNlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgc3BlY2lmaWVkIEpTT04tUlBDIHJlc3BvbnNlIGlzIHBlbmRpbmcuXG4gKi9cbmZ1bmN0aW9uIGlzUGVuZGluZ0pzb25ScGNSZXNwb25zZShyZXNwb25zZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykocmVzcG9uc2UsIGV4cG9ydHMuUGVuZGluZ0pzb25ScGNSZXNwb25zZVN0cnVjdCk7XG59XG5leHBvcnRzLmlzUGVuZGluZ0pzb25ScGNSZXNwb25zZSA9IGlzUGVuZGluZ0pzb25ScGNSZXNwb25zZTtcbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIFBlbmRpbmdKc29uUnBjUmVzcG9uc2V9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gcmVzcG9uc2UgLSBUaGUgSlNPTi1SUEMgcmVzcG9uc2UgdG8gY2hlY2suXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQge0BsaW5rIFBlbmRpbmdKc29uUnBjUmVzcG9uc2V9XG4gKiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzUGVuZGluZ0pzb25ScGNSZXNwb25zZShyZXNwb25zZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KShyZXNwb25zZSwgZXhwb3J0cy5QZW5kaW5nSnNvblJwY1Jlc3BvbnNlU3RydWN0LCAnSW52YWxpZCBwZW5kaW5nIEpTT04tUlBDIHJlc3BvbnNlJywgRXJyb3JXcmFwcGVyKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlID0gYXNzZXJ0SXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlO1xuLyoqXG4gKiBUeXBlIGd1YXJkIHRvIGNoZWNrIGlmIGEgdmFsdWUgaXMgYSB7QGxpbmsgSnNvblJwY1Jlc3BvbnNlfS5cbiAqXG4gKiBAcGFyYW0gcmVzcG9uc2UgLSBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgb2JqZWN0IGlzIGEgSnNvblJwY1Jlc3BvbnNlLlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNSZXNwb25zZShyZXNwb25zZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykocmVzcG9uc2UsIGV4cG9ydHMuSnNvblJwY1Jlc3BvbnNlU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjUmVzcG9uc2UgPSBpc0pzb25ScGNSZXNwb25zZTtcbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNSZXNwb25zZX0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1Jlc3BvbnNlfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY1Jlc3BvbnNlKHZhbHVlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNSZXNwb25zZVN0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgcmVzcG9uc2UnLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNSZXNwb25zZSA9IGFzc2VydElzSnNvblJwY1Jlc3BvbnNlO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1N1Y2Nlc3N9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjU3VjY2Vzc30gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNTdWNjZXNzKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjU3VjY2Vzc1N0cnVjdCk7XG59XG5leHBvcnRzLmlzSnNvblJwY1N1Y2Nlc3MgPSBpc0pzb25ScGNTdWNjZXNzO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1N1Y2Nlc3N9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQge0BsaW5rIEpzb25ScGNTdWNjZXNzfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY1N1Y2Nlc3ModmFsdWUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmFsdWUsIGV4cG9ydHMuSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QsICdJbnZhbGlkIEpTT04tUlBDIHN1Y2Nlc3MgcmVzcG9uc2UnLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNTdWNjZXNzID0gYXNzZXJ0SXNKc29uUnBjU3VjY2Vzcztcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNGYWlsdXJlfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0ZhaWx1cmV9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNKc29uUnBjRmFpbHVyZSh2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuSnNvblJwY0ZhaWx1cmVTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0pzb25ScGNGYWlsdXJlID0gaXNKc29uUnBjRmFpbHVyZTtcbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNGYWlsdXJlfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBKc29uUnBjRmFpbHVyZX0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0pzb25ScGNGYWlsdXJlKHZhbHVlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNGYWlsdXJlU3RydWN0LCAnSW52YWxpZCBKU09OLVJQQyBmYWlsdXJlIHJlc3BvbnNlJywgRXJyb3JXcmFwcGVyKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjRmFpbHVyZSA9IGFzc2VydElzSnNvblJwY0ZhaWx1cmU7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjRXJyb3J9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjRXJyb3J9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNKc29uUnBjRXJyb3IodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCk7XG59XG5leHBvcnRzLmlzSnNvblJwY0Vycm9yID0gaXNKc29uUnBjRXJyb3I7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjRXJyb3J9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQge0BsaW5rIEpzb25ScGNFcnJvcn0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0pzb25ScGNFcnJvcih2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjRXJyb3JTdHJ1Y3QsICdJbnZhbGlkIEpTT04tUlBDIGVycm9yJywgRXJyb3JXcmFwcGVyKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjRXJyb3IgPSBhc3NlcnRJc0pzb25ScGNFcnJvcjtcbi8qKlxuICogR2V0cyBhIGZ1bmN0aW9uIGZvciB2YWxpZGF0aW5nIEpTT04tUlBDIHJlcXVlc3QgLyByZXNwb25zZSBgaWRgIHZhbHVlcy5cbiAqXG4gKiBCeSBtYW5pcHVsYXRpbmcgdGhlIG9wdGlvbnMgb2YgdGhpcyBmYWN0b3J5LCB5b3UgY2FuIGNvbnRyb2wgdGhlIGJlaGF2aW9yXG4gKiBvZiB0aGUgcmVzdWx0aW5nIHZhbGlkYXRvciBmb3Igc29tZSBlZGdlIGNhc2VzLiBUaGlzIGlzIHVzZWZ1bCBiZWNhdXNlIGUuZy5cbiAqIGBudWxsYCBzaG91bGQgc29tZXRpbWVzIGJ1dCBub3QgYWx3YXlzIGJlIHBlcm1pdHRlZC5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIGVtcHR5IHN0cmluZyAoYCcnYCkgaXMgYWx3YXlzIHBlcm1pdHRlZCBieSB0aGUgSlNPTi1SUENcbiAqIHNwZWNpZmljYXRpb24sIGJ1dCB0aGF0IGtpbmQgb2Ygc3Vja3MgYW5kIHlvdSBtYXkgd2FudCB0byBmb3JiaWQgaXQgaW4gc29tZVxuICogaW5zdGFuY2VzIGFueXdheS5cbiAqXG4gKiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgdGhlXG4gKiBbSlNPTi1SUEMgU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly93d3cuanNvbnJwYy5vcmcvc3BlY2lmaWNhdGlvbikuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSBvcHRpb25zLnBlcm1pdEVtcHR5U3RyaW5nIC0gV2hldGhlciB0aGUgZW1wdHkgc3RyaW5nIChpLmUuIGAnJ2ApXG4gKiBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIHZhbGlkIElELiBEZWZhdWx0OiBgdHJ1ZWBcbiAqIEBwYXJhbSBvcHRpb25zLnBlcm1pdEZyYWN0aW9ucyAtIFdoZXRoZXIgZnJhY3Rpb25hbCBudW1iZXJzIChlLmcuIGAxLjJgKVxuICogc2hvdWxkIGJlIHRyZWF0ZWQgYXMgdmFsaWQgSURzLiBEZWZhdWx0OiBgZmFsc2VgXG4gKiBAcGFyYW0gb3B0aW9ucy5wZXJtaXROdWxsIC0gV2hldGhlciBgbnVsbGAgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSB2YWxpZCBJRC5cbiAqIERlZmF1bHQ6IGB0cnVlYFxuICogQHJldHVybnMgVGhlIEpTT04tUlBDIElEIHZhbGlkYXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0SnNvblJwY0lkVmFsaWRhdG9yKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHBlcm1pdEVtcHR5U3RyaW5nLCBwZXJtaXRGcmFjdGlvbnMsIHBlcm1pdE51bGwgfSA9IE9iamVjdC5hc3NpZ24oeyBwZXJtaXRFbXB0eVN0cmluZzogdHJ1ZSwgcGVybWl0RnJhY3Rpb25zOiBmYWxzZSwgcGVybWl0TnVsbDogdHJ1ZSB9LCBvcHRpb25zKTtcbiAgICAvKipcbiAgICAgKiBUeXBlIGd1YXJkIGZvciB7QGxpbmsgSnNvblJwY0lkfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBKU09OLVJQQyBJRCB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnaXZlbiBJRCBpcyB2YWxpZCBwZXIgdGhlIG9wdGlvbnMgZ2l2ZW4gdG8gdGhlXG4gICAgICogZmFjdG9yeS5cbiAgICAgKi9cbiAgICBjb25zdCBpc1ZhbGlkSnNvblJwY0lkID0gKGlkKSA9PiB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKCh0eXBlb2YgaWQgPT09ICdudW1iZXInICYmIChwZXJtaXRGcmFjdGlvbnMgfHwgTnVtYmVyLmlzSW50ZWdlcihpZCkpKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycgJiYgKHBlcm1pdEVtcHR5U3RyaW5nIHx8IGlkLmxlbmd0aCA+IDApKSB8fFxuICAgICAgICAgICAgKHBlcm1pdE51bGwgJiYgaWQgPT09IG51bGwpKTtcbiAgICB9O1xuICAgIHJldHVybiBpc1ZhbGlkSnNvblJwY0lkO1xufVxuZXhwb3J0cy5nZXRKc29uUnBjSWRWYWxpZGF0b3IgPSBnZXRKc29uUnBjSWRWYWxpZGF0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc29uLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldEpzb25ScGNJZFZhbGlkYXRvciIsImFzc2VydElzSnNvblJwY0Vycm9yIiwiaXNKc29uUnBjRXJyb3IiLCJhc3NlcnRJc0pzb25ScGNGYWlsdXJlIiwiaXNKc29uUnBjRmFpbHVyZSIsImFzc2VydElzSnNvblJwY1N1Y2Nlc3MiLCJpc0pzb25ScGNTdWNjZXNzIiwiYXNzZXJ0SXNKc29uUnBjUmVzcG9uc2UiLCJpc0pzb25ScGNSZXNwb25zZSIsImFzc2VydElzUGVuZGluZ0pzb25ScGNSZXNwb25zZSIsImlzUGVuZGluZ0pzb25ScGNSZXNwb25zZSIsIkpzb25ScGNSZXNwb25zZVN0cnVjdCIsIkpzb25ScGNGYWlsdXJlU3RydWN0IiwiSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QiLCJQZW5kaW5nSnNvblJwY1Jlc3BvbnNlU3RydWN0IiwiYXNzZXJ0SXNKc29uUnBjUmVxdWVzdCIsImlzSnNvblJwY1JlcXVlc3QiLCJhc3NlcnRJc0pzb25ScGNOb3RpZmljYXRpb24iLCJpc0pzb25ScGNOb3RpZmljYXRpb24iLCJKc29uUnBjTm90aWZpY2F0aW9uU3RydWN0IiwiSnNvblJwY1JlcXVlc3RTdHJ1Y3QiLCJKc29uUnBjUGFyYW1zU3RydWN0IiwiSnNvblJwY0Vycm9yU3RydWN0IiwiSnNvblJwY0lkU3RydWN0IiwiSnNvblJwY1ZlcnNpb25TdHJ1Y3QiLCJqc29ucnBjMiIsImdldEpzb25TaXplIiwiaXNWYWxpZEpzb24iLCJKc29uU3RydWN0IiwiVW5zYWZlSnNvblN0cnVjdCIsInN1cGVyc3RydWN0XzEiLCJyZXF1aXJlIiwiYXNzZXJ0XzEiLCJmaW5pdGVOdW1iZXIiLCJkZWZpbmUiLCJpcyIsIm51bWJlciIsIk51bWJlciIsImlzRmluaXRlIiwidW5pb24iLCJsaXRlcmFsIiwiYm9vbGVhbiIsInN0cmluZyIsImFycmF5IiwibGF6eSIsInJlY29yZCIsImNvbnRleHQiLCJjaGVja1N0cnVjdCIsImlubmVyVmFsdWUiLCJzdHJ1Y3QiLCJpdGVyYXRvciIsInZhbGlkYXRvciIsImVycm9ycyIsImxlbmd0aCIsInVuc2FmZVJlc3VsdCIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsImVycm9yIiwiUmFuZ2VFcnJvciIsImFzc2VydFN0cnVjdCIsImpzb24iLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImJ5dGVMZW5ndGgiLCJudWxsYWJsZSIsIm9iamVjdCIsImNvZGUiLCJpbnRlZ2VyIiwibWVzc2FnZSIsImRhdGEiLCJvcHRpb25hbCIsInN0YWNrIiwiaWQiLCJqc29ucnBjIiwibWV0aG9kIiwicGFyYW1zIiwib21pdCIsIkVycm9yV3JhcHBlciIsInJlc3VsdCIsInVua25vd24iLCJyZXNwb25zZSIsIm9wdGlvbnMiLCJwZXJtaXRFbXB0eVN0cmluZyIsInBlcm1pdEZyYWN0aW9ucyIsInBlcm1pdE51bGwiLCJhc3NpZ24iLCJpc1ZhbGlkSnNvblJwY0lkIiwiQm9vbGVhbiIsImlzSW50ZWdlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/json.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/keyring.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/keyring.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n})); //# sourceMappingURL=keyring.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2tleXJpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUMsRUFDN0QsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RhYmxlLXJvdXRlci13ZWIvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2tleXJpbmcuanM/YWIwNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtleXJpbmcuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/keyring.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/logging.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/logging.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createModuleLogger = exports.createProjectLogger = void 0;\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\"));\nconst globalLogger = (0, debug_1.default)(\"metamask\");\n/**\n * Creates a logger via the `debug` library whose log messages will be tagged\n * using the name of your project. By default, such messages will be\n * suppressed, but you can reveal them by setting the `DEBUG` environment\n * variable to `metamask:<projectName>`. You can also set this variable to\n * `metamask:*` if you want to see log messages from all MetaMask projects that\n * are also using this function to create their loggers.\n *\n * @param projectName - The name of your project. This should be the name of\n * your NPM package if you're developing one.\n * @returns An instance of `debug`.\n */ function createProjectLogger(projectName) {\n    return globalLogger.extend(projectName);\n}\nexports.createProjectLogger = createProjectLogger;\n/**\n * Creates a logger via the `debug` library which is derived from the logger for\n * the whole project whose log messages will be tagged using the name of your\n * module. By default, such messages will be suppressed, but you can reveal them\n * by setting the `DEBUG` environment variable to\n * `metamask:<projectName>:<moduleName>`. You can also set this variable to\n * `metamask:<projectName>:*` if you want to see log messages from the project,\n * or `metamask:*` if you want to see log messages from all MetaMask projects.\n *\n * @param projectLogger - The logger created via {@link createProjectLogger}.\n * @param moduleName - The name of your module. You could use the name of the\n * file where you're using this logger or some other name.\n * @returns An instance of `debug`.\n */ function createModuleLogger(projectLogger, moduleName) {\n    return projectLogger.extend(moduleName);\n}\nexports.createModuleLogger = createModuleLogger; //# sourceMappingURL=logging.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2xvZ2dpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsSUFBSyxJQUFJLElBQUksQ0FBQ0EsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FFLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwwQkFBMEIsR0FBR0EsMkJBQTJCLEdBQUcsS0FBSztBQUNoRSxNQUFNSSxVQUFVVCxnQkFBZ0JVLG1CQUFPQSxDQUFDLHNEQUFPO0FBQy9DLE1BQU1DLGVBQWUsQ0FBQyxHQUFHRixRQUFRRyxPQUFPLEVBQUU7QUFDMUM7Ozs7Ozs7Ozs7O0NBV0MsR0FDRCxTQUFTSixvQkFBb0JLLFdBQVc7SUFDcEMsT0FBT0YsYUFBYUcsTUFBTSxDQUFDRDtBQUMvQjtBQUNBUiwyQkFBMkIsR0FBR0c7QUFDOUI7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNELFNBQVNELG1CQUFtQlEsYUFBYSxFQUFFQyxVQUFVO0lBQ2pELE9BQU9ELGNBQWNELE1BQU0sQ0FBQ0U7QUFDaEM7QUFDQVgsMEJBQTBCLEdBQUdFLG9CQUM3QixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGFibGUtcm91dGVyLXdlYi8uL25vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvbG9nZ2luZy5qcz9kYTBhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVNb2R1bGVMb2dnZXIgPSBleHBvcnRzLmNyZWF0ZVByb2plY3RMb2dnZXIgPSB2b2lkIDA7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBnbG9iYWxMb2dnZXIgPSAoMCwgZGVidWdfMS5kZWZhdWx0KSgnbWV0YW1hc2snKTtcbi8qKlxuICogQ3JlYXRlcyBhIGxvZ2dlciB2aWEgdGhlIGBkZWJ1Z2AgbGlicmFyeSB3aG9zZSBsb2cgbWVzc2FnZXMgd2lsbCBiZSB0YWdnZWRcbiAqIHVzaW5nIHRoZSBuYW1lIG9mIHlvdXIgcHJvamVjdC4gQnkgZGVmYXVsdCwgc3VjaCBtZXNzYWdlcyB3aWxsIGJlXG4gKiBzdXBwcmVzc2VkLCBidXQgeW91IGNhbiByZXZlYWwgdGhlbSBieSBzZXR0aW5nIHRoZSBgREVCVUdgIGVudmlyb25tZW50XG4gKiB2YXJpYWJsZSB0byBgbWV0YW1hc2s6PHByb2plY3ROYW1lPmAuIFlvdSBjYW4gYWxzbyBzZXQgdGhpcyB2YXJpYWJsZSB0b1xuICogYG1ldGFtYXNrOipgIGlmIHlvdSB3YW50IHRvIHNlZSBsb2cgbWVzc2FnZXMgZnJvbSBhbGwgTWV0YU1hc2sgcHJvamVjdHMgdGhhdFxuICogYXJlIGFsc28gdXNpbmcgdGhpcyBmdW5jdGlvbiB0byBjcmVhdGUgdGhlaXIgbG9nZ2Vycy5cbiAqXG4gKiBAcGFyYW0gcHJvamVjdE5hbWUgLSBUaGUgbmFtZSBvZiB5b3VyIHByb2plY3QuIFRoaXMgc2hvdWxkIGJlIHRoZSBuYW1lIG9mXG4gKiB5b3VyIE5QTSBwYWNrYWdlIGlmIHlvdSdyZSBkZXZlbG9waW5nIG9uZS5cbiAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIGBkZWJ1Z2AuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVByb2plY3RMb2dnZXIocHJvamVjdE5hbWUpIHtcbiAgICByZXR1cm4gZ2xvYmFsTG9nZ2VyLmV4dGVuZChwcm9qZWN0TmFtZSk7XG59XG5leHBvcnRzLmNyZWF0ZVByb2plY3RMb2dnZXIgPSBjcmVhdGVQcm9qZWN0TG9nZ2VyO1xuLyoqXG4gKiBDcmVhdGVzIGEgbG9nZ2VyIHZpYSB0aGUgYGRlYnVnYCBsaWJyYXJ5IHdoaWNoIGlzIGRlcml2ZWQgZnJvbSB0aGUgbG9nZ2VyIGZvclxuICogdGhlIHdob2xlIHByb2plY3Qgd2hvc2UgbG9nIG1lc3NhZ2VzIHdpbGwgYmUgdGFnZ2VkIHVzaW5nIHRoZSBuYW1lIG9mIHlvdXJcbiAqIG1vZHVsZS4gQnkgZGVmYXVsdCwgc3VjaCBtZXNzYWdlcyB3aWxsIGJlIHN1cHByZXNzZWQsIGJ1dCB5b3UgY2FuIHJldmVhbCB0aGVtXG4gKiBieSBzZXR0aW5nIHRoZSBgREVCVUdgIGVudmlyb25tZW50IHZhcmlhYmxlIHRvXG4gKiBgbWV0YW1hc2s6PHByb2plY3ROYW1lPjo8bW9kdWxlTmFtZT5gLiBZb3UgY2FuIGFsc28gc2V0IHRoaXMgdmFyaWFibGUgdG9cbiAqIGBtZXRhbWFzazo8cHJvamVjdE5hbWU+OipgIGlmIHlvdSB3YW50IHRvIHNlZSBsb2cgbWVzc2FnZXMgZnJvbSB0aGUgcHJvamVjdCxcbiAqIG9yIGBtZXRhbWFzazoqYCBpZiB5b3Ugd2FudCB0byBzZWUgbG9nIG1lc3NhZ2VzIGZyb20gYWxsIE1ldGFNYXNrIHByb2plY3RzLlxuICpcbiAqIEBwYXJhbSBwcm9qZWN0TG9nZ2VyIC0gVGhlIGxvZ2dlciBjcmVhdGVkIHZpYSB7QGxpbmsgY3JlYXRlUHJvamVjdExvZ2dlcn0uXG4gKiBAcGFyYW0gbW9kdWxlTmFtZSAtIFRoZSBuYW1lIG9mIHlvdXIgbW9kdWxlLiBZb3UgY291bGQgdXNlIHRoZSBuYW1lIG9mIHRoZVxuICogZmlsZSB3aGVyZSB5b3UncmUgdXNpbmcgdGhpcyBsb2dnZXIgb3Igc29tZSBvdGhlciBuYW1lLlxuICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgYGRlYnVnYC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTW9kdWxlTG9nZ2VyKHByb2plY3RMb2dnZXIsIG1vZHVsZU5hbWUpIHtcbiAgICByZXR1cm4gcHJvamVjdExvZ2dlci5leHRlbmQobW9kdWxlTmFtZSk7XG59XG5leHBvcnRzLmNyZWF0ZU1vZHVsZUxvZ2dlciA9IGNyZWF0ZU1vZHVsZUxvZ2dlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ2dpbmcuanMubWFwIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNyZWF0ZU1vZHVsZUxvZ2dlciIsImNyZWF0ZVByb2plY3RMb2dnZXIiLCJkZWJ1Z18xIiwicmVxdWlyZSIsImdsb2JhbExvZ2dlciIsImRlZmF1bHQiLCJwcm9qZWN0TmFtZSIsImV4dGVuZCIsInByb2plY3RMb2dnZXIiLCJtb2R1bGVOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/logging.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/misc.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/misc.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n//\n// Types\n//\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.calculateNumberSize = exports.calculateStringSize = exports.isASCII = exports.isPlainObject = exports.ESCAPE_CHARACTERS_REGEXP = exports.JsonSize = exports.hasProperty = exports.isObject = exports.isNullOrUndefined = exports.isNonEmptyArray = void 0;\n//\n// Type Guards\n//\n/**\n * A {@link NonEmptyArray} type guard.\n *\n * @template Element - The non-empty array member type.\n * @param value - The value to check.\n * @returns Whether the value is a non-empty array.\n */ function isNonEmptyArray(value) {\n    return Array.isArray(value) && value.length > 0;\n}\nexports.isNonEmptyArray = isNonEmptyArray;\n/**\n * Type guard for \"nullishness\".\n *\n * @param value - Any value.\n * @returns `true` if the value is null or undefined, `false` otherwise.\n */ function isNullOrUndefined(value) {\n    return value === null || value === undefined;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n/**\n * A type guard for {@link RuntimeObject}.\n *\n * @param value - The value to check.\n * @returns Whether the specified value has a runtime type of `object` and is\n * neither `null` nor an `Array`.\n */ function isObject(value) {\n    return Boolean(value) && typeof value === \"object\" && !Array.isArray(value);\n}\nexports.isObject = isObject;\n//\n// Other utility functions\n//\n/**\n * A type guard for ensuring an object has a property.\n *\n * @param objectToCheck - The object to check.\n * @param name - The property name to check for.\n * @returns Whether the specified object has an own property with the specified\n * name, regardless of whether it is enumerable or not.\n */ const hasProperty = (objectToCheck, name)=>Object.hasOwnProperty.call(objectToCheck, name);\nexports.hasProperty = hasProperty;\n/**\n * Predefined sizes (in Bytes) of specific parts of JSON structure.\n */ var JsonSize;\n(function(JsonSize) {\n    JsonSize[JsonSize[\"Null\"] = 4] = \"Null\";\n    JsonSize[JsonSize[\"Comma\"] = 1] = \"Comma\";\n    JsonSize[JsonSize[\"Wrapper\"] = 1] = \"Wrapper\";\n    JsonSize[JsonSize[\"True\"] = 4] = \"True\";\n    JsonSize[JsonSize[\"False\"] = 5] = \"False\";\n    JsonSize[JsonSize[\"Quote\"] = 1] = \"Quote\";\n    JsonSize[JsonSize[\"Colon\"] = 1] = \"Colon\";\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    JsonSize[JsonSize[\"Date\"] = 24] = \"Date\";\n})(JsonSize = exports.JsonSize || (exports.JsonSize = {}));\n/**\n * Regular expression with pattern matching for (special) escaped characters.\n */ exports.ESCAPE_CHARACTERS_REGEXP = /\"|\\\\|\\n|\\r|\\t/gu;\n/**\n * Check if the value is plain object.\n *\n * @param value - Value to be checked.\n * @returns True if an object is the plain JavaScript object,\n * false if the object is not plain (e.g. function).\n */ function isPlainObject(value) {\n    if (typeof value !== \"object\" || value === null) {\n        return false;\n    }\n    try {\n        let proto = value;\n        while(Object.getPrototypeOf(proto) !== null){\n            proto = Object.getPrototypeOf(proto);\n        }\n        return Object.getPrototypeOf(value) === proto;\n    } catch (_) {\n        return false;\n    }\n}\nexports.isPlainObject = isPlainObject;\n/**\n * Check if character is ASCII.\n *\n * @param character - Character.\n * @returns True if a character code is ASCII, false if not.\n */ function isASCII(character) {\n    return character.charCodeAt(0) <= 127;\n}\nexports.isASCII = isASCII;\n/**\n * Calculate string size.\n *\n * @param value - String value to calculate size.\n * @returns Number of bytes used to store whole string value.\n */ function calculateStringSize(value) {\n    var _a;\n    const size = value.split(\"\").reduce((total, character)=>{\n        if (isASCII(character)) {\n            return total + 1;\n        }\n        return total + 2;\n    }, 0);\n    // Also detect characters that need backslash escape\n    return size + ((_a = value.match(exports.ESCAPE_CHARACTERS_REGEXP)) !== null && _a !== void 0 ? _a : []).length;\n}\nexports.calculateStringSize = calculateStringSize;\n/**\n * Calculate size of a number ofter JSON serialization.\n *\n * @param value - Number value to calculate size.\n * @returns Number of bytes used to store whole number in JSON.\n */ function calculateNumberSize(value) {\n    return value.toString().length;\n}\nexports.calculateNumberSize = calculateNumberSize; //# sourceMappingURL=misc.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L21pc2MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixFQUFFO0FBQ0YsUUFBUTtBQUNSLEVBQUU7QUFDRkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDJCQUEyQixHQUFHQSwyQkFBMkIsR0FBR0EsZUFBZSxHQUFHQSxxQkFBcUIsR0FBR0EsZ0NBQWdDLEdBQUdBLGdCQUFnQixHQUFHQSxtQkFBbUIsR0FBR0EsZ0JBQWdCLEdBQUdBLHlCQUF5QixHQUFHQSx1QkFBdUIsR0FBRyxLQUFLO0FBQ2hRLEVBQUU7QUFDRixjQUFjO0FBQ2QsRUFBRTtBQUNGOzs7Ozs7Q0FNQyxHQUNELFNBQVNXLGdCQUFnQlYsS0FBSztJQUMxQixPQUFPVyxNQUFNQyxPQUFPLENBQUNaLFVBQVVBLE1BQU1hLE1BQU0sR0FBRztBQUNsRDtBQUNBZCx1QkFBdUIsR0FBR1c7QUFDMUI7Ozs7O0NBS0MsR0FDRCxTQUFTRCxrQkFBa0JULEtBQUs7SUFDNUIsT0FBT0EsVUFBVSxRQUFRQSxVQUFVYztBQUN2QztBQUNBZix5QkFBeUIsR0FBR1U7QUFDNUI7Ozs7OztDQU1DLEdBQ0QsU0FBU0QsU0FBU1IsS0FBSztJQUNuQixPQUFPZSxRQUFRZixVQUFVLE9BQU9BLFVBQVUsWUFBWSxDQUFDVyxNQUFNQyxPQUFPLENBQUNaO0FBQ3pFO0FBQ0FELGdCQUFnQixHQUFHUztBQUNuQixFQUFFO0FBQ0YsMEJBQTBCO0FBQzFCLEVBQUU7QUFDRjs7Ozs7OztDQU9DLEdBQ0QsTUFBTUQsY0FBYyxDQUFDUyxlQUFlQyxPQUFTcEIsT0FBT3FCLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSCxlQUFlQztBQUN2RmxCLG1CQUFtQixHQUFHUTtBQUN0Qjs7Q0FFQyxHQUNELElBQUlEO0FBQ0gsVUFBVUEsUUFBUTtJQUNmQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxPQUFPLEdBQUcsRUFBRSxHQUFHO0lBQ2pDQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQ2xDQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQ3BDQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxPQUFPLEdBQUcsRUFBRSxHQUFHO0lBQ2pDQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQ2xDQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQ2xDQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQ2xDLHdEQUF3RDtJQUN4REEsUUFBUSxDQUFDQSxRQUFRLENBQUMsT0FBTyxHQUFHLEdBQUcsR0FBRztBQUN0QyxHQUFHQSxXQUFXUCxRQUFRTyxRQUFRLElBQUtQLENBQUFBLGdCQUFnQixHQUFHLENBQUM7QUFDdkQ7O0NBRUMsR0FDREEsZ0NBQWdDLEdBQUc7QUFDbkM7Ozs7OztDQU1DLEdBQ0QsU0FBU0ssY0FBY0osS0FBSztJQUN4QixJQUFJLE9BQU9BLFVBQVUsWUFBWUEsVUFBVSxNQUFNO1FBQzdDLE9BQU87SUFDWDtJQUNBLElBQUk7UUFDQSxJQUFJb0IsUUFBUXBCO1FBQ1osTUFBT0gsT0FBT3dCLGNBQWMsQ0FBQ0QsV0FBVyxLQUFNO1lBQzFDQSxRQUFRdkIsT0FBT3dCLGNBQWMsQ0FBQ0Q7UUFDbEM7UUFDQSxPQUFPdkIsT0FBT3dCLGNBQWMsQ0FBQ3JCLFdBQVdvQjtJQUM1QyxFQUNBLE9BQU9FLEdBQUc7UUFDTixPQUFPO0lBQ1g7QUFDSjtBQUNBdkIscUJBQXFCLEdBQUdLO0FBQ3hCOzs7OztDQUtDLEdBQ0QsU0FBU0QsUUFBUW9CLFNBQVM7SUFDdEIsT0FBT0EsVUFBVUMsVUFBVSxDQUFDLE1BQU07QUFDdEM7QUFDQXpCLGVBQWUsR0FBR0k7QUFDbEI7Ozs7O0NBS0MsR0FDRCxTQUFTRCxvQkFBb0JGLEtBQUs7SUFDOUIsSUFBSXlCO0lBQ0osTUFBTUMsT0FBTzFCLE1BQU0yQixLQUFLLENBQUMsSUFBSUMsTUFBTSxDQUFDLENBQUNDLE9BQU9OO1FBQ3hDLElBQUlwQixRQUFRb0IsWUFBWTtZQUNwQixPQUFPTSxRQUFRO1FBQ25CO1FBQ0EsT0FBT0EsUUFBUTtJQUNuQixHQUFHO0lBQ0gsb0RBQW9EO0lBQ3BELE9BQU9ILE9BQU8sQ0FBQyxDQUFDRCxLQUFLekIsTUFBTThCLEtBQUssQ0FBQy9CLFFBQVFNLHdCQUF3QixPQUFPLFFBQVFvQixPQUFPLEtBQUssSUFBSUEsS0FBSyxFQUFFLEVBQUVaLE1BQU07QUFDbkg7QUFDQWQsMkJBQTJCLEdBQUdHO0FBQzlCOzs7OztDQUtDLEdBQ0QsU0FBU0Qsb0JBQW9CRCxLQUFLO0lBQzlCLE9BQU9BLE1BQU0rQixRQUFRLEdBQUdsQixNQUFNO0FBQ2xDO0FBQ0FkLDJCQUEyQixHQUFHRSxxQkFDOUIsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RhYmxlLXJvdXRlci13ZWIvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L21pc2MuanM/ZDI1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vXG4vLyBUeXBlc1xuLy9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2FsY3VsYXRlTnVtYmVyU2l6ZSA9IGV4cG9ydHMuY2FsY3VsYXRlU3RyaW5nU2l6ZSA9IGV4cG9ydHMuaXNBU0NJSSA9IGV4cG9ydHMuaXNQbGFpbk9iamVjdCA9IGV4cG9ydHMuRVNDQVBFX0NIQVJBQ1RFUlNfUkVHRVhQID0gZXhwb3J0cy5Kc29uU2l6ZSA9IGV4cG9ydHMuaGFzUHJvcGVydHkgPSBleHBvcnRzLmlzT2JqZWN0ID0gZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGV4cG9ydHMuaXNOb25FbXB0eUFycmF5ID0gdm9pZCAwO1xuLy9cbi8vIFR5cGUgR3VhcmRzXG4vL1xuLyoqXG4gKiBBIHtAbGluayBOb25FbXB0eUFycmF5fSB0eXBlIGd1YXJkLlxuICpcbiAqIEB0ZW1wbGF0ZSBFbGVtZW50IC0gVGhlIG5vbi1lbXB0eSBhcnJheSBtZW1iZXIgdHlwZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgbm9uLWVtcHR5IGFycmF5LlxuICovXG5mdW5jdGlvbiBpc05vbkVtcHR5QXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID4gMDtcbn1cbmV4cG9ydHMuaXNOb25FbXB0eUFycmF5ID0gaXNOb25FbXB0eUFycmF5O1xuLyoqXG4gKiBUeXBlIGd1YXJkIGZvciBcIm51bGxpc2huZXNzXCIuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gQW55IHZhbHVlLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBudWxsIG9yIHVuZGVmaW5lZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG4vKipcbiAqIEEgdHlwZSBndWFyZCBmb3Ige0BsaW5rIFJ1bnRpbWVPYmplY3R9LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHNwZWNpZmllZCB2YWx1ZSBoYXMgYSBydW50aW1lIHR5cGUgb2YgYG9iamVjdGAgYW5kIGlzXG4gKiBuZWl0aGVyIGBudWxsYCBub3IgYW4gYEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gQm9vbGVhbih2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4vL1xuLy8gT3RoZXIgdXRpbGl0eSBmdW5jdGlvbnNcbi8vXG4vKipcbiAqIEEgdHlwZSBndWFyZCBmb3IgZW5zdXJpbmcgYW4gb2JqZWN0IGhhcyBhIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSBvYmplY3RUb0NoZWNrIC0gVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEBwYXJhbSBuYW1lIC0gVGhlIHByb3BlcnR5IG5hbWUgdG8gY2hlY2sgZm9yLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgc3BlY2lmaWVkIG9iamVjdCBoYXMgYW4gb3duIHByb3BlcnR5IHdpdGggdGhlIHNwZWNpZmllZFxuICogbmFtZSwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIGl0IGlzIGVudW1lcmFibGUgb3Igbm90LlxuICovXG5jb25zdCBoYXNQcm9wZXJ0eSA9IChvYmplY3RUb0NoZWNrLCBuYW1lKSA9PiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3RUb0NoZWNrLCBuYW1lKTtcbmV4cG9ydHMuaGFzUHJvcGVydHkgPSBoYXNQcm9wZXJ0eTtcbi8qKlxuICogUHJlZGVmaW5lZCBzaXplcyAoaW4gQnl0ZXMpIG9mIHNwZWNpZmljIHBhcnRzIG9mIEpTT04gc3RydWN0dXJlLlxuICovXG52YXIgSnNvblNpemU7XG4oZnVuY3Rpb24gKEpzb25TaXplKSB7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJOdWxsXCJdID0gNF0gPSBcIk51bGxcIjtcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIkNvbW1hXCJdID0gMV0gPSBcIkNvbW1hXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJXcmFwcGVyXCJdID0gMV0gPSBcIldyYXBwZXJcIjtcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIlRydWVcIl0gPSA0XSA9IFwiVHJ1ZVwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiRmFsc2VcIl0gPSA1XSA9IFwiRmFsc2VcIjtcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIlF1b3RlXCJdID0gMV0gPSBcIlF1b3RlXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJDb2xvblwiXSA9IDFdID0gXCJDb2xvblwiO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tc2hhZG93XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJEYXRlXCJdID0gMjRdID0gXCJEYXRlXCI7XG59KShKc29uU2l6ZSA9IGV4cG9ydHMuSnNvblNpemUgfHwgKGV4cG9ydHMuSnNvblNpemUgPSB7fSkpO1xuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gd2l0aCBwYXR0ZXJuIG1hdGNoaW5nIGZvciAoc3BlY2lhbCkgZXNjYXBlZCBjaGFyYWN0ZXJzLlxuICovXG5leHBvcnRzLkVTQ0FQRV9DSEFSQUNURVJTX1JFR0VYUCA9IC9cInxcXFxcfFxcbnxcXHJ8XFx0L2d1O1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgdmFsdWUgaXMgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyBUcnVlIGlmIGFuIG9iamVjdCBpcyB0aGUgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3QsXG4gKiBmYWxzZSBpZiB0aGUgb2JqZWN0IGlzIG5vdCBwbGFpbiAoZS5nLiBmdW5jdGlvbikuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGxldCBwcm90byA9IHZhbHVlO1xuICAgICAgICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBwcm90bztcbiAgICB9XG4gICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuaXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3Q7XG4vKipcbiAqIENoZWNrIGlmIGNoYXJhY3RlciBpcyBBU0NJSS5cbiAqXG4gKiBAcGFyYW0gY2hhcmFjdGVyIC0gQ2hhcmFjdGVyLlxuICogQHJldHVybnMgVHJ1ZSBpZiBhIGNoYXJhY3RlciBjb2RlIGlzIEFTQ0lJLCBmYWxzZSBpZiBub3QuXG4gKi9cbmZ1bmN0aW9uIGlzQVNDSUkoY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuIGNoYXJhY3Rlci5jaGFyQ29kZUF0KDApIDw9IDEyNztcbn1cbmV4cG9ydHMuaXNBU0NJSSA9IGlzQVNDSUk7XG4vKipcbiAqIENhbGN1bGF0ZSBzdHJpbmcgc2l6ZS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBTdHJpbmcgdmFsdWUgdG8gY2FsY3VsYXRlIHNpemUuXG4gKiBAcmV0dXJucyBOdW1iZXIgb2YgYnl0ZXMgdXNlZCB0byBzdG9yZSB3aG9sZSBzdHJpbmcgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZVN0cmluZ1NpemUodmFsdWUpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgc2l6ZSA9IHZhbHVlLnNwbGl0KCcnKS5yZWR1Y2UoKHRvdGFsLCBjaGFyYWN0ZXIpID0+IHtcbiAgICAgICAgaWYgKGlzQVNDSUkoY2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRvdGFsICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWwgKyAyO1xuICAgIH0sIDApO1xuICAgIC8vIEFsc28gZGV0ZWN0IGNoYXJhY3RlcnMgdGhhdCBuZWVkIGJhY2tzbGFzaCBlc2NhcGVcbiAgICByZXR1cm4gc2l6ZSArICgoX2EgPSB2YWx1ZS5tYXRjaChleHBvcnRzLkVTQ0FQRV9DSEFSQUNURVJTX1JFR0VYUCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKS5sZW5ndGg7XG59XG5leHBvcnRzLmNhbGN1bGF0ZVN0cmluZ1NpemUgPSBjYWxjdWxhdGVTdHJpbmdTaXplO1xuLyoqXG4gKiBDYWxjdWxhdGUgc2l6ZSBvZiBhIG51bWJlciBvZnRlciBKU09OIHNlcmlhbGl6YXRpb24uXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gTnVtYmVyIHZhbHVlIHRvIGNhbGN1bGF0ZSBzaXplLlxuICogQHJldHVybnMgTnVtYmVyIG9mIGJ5dGVzIHVzZWQgdG8gc3RvcmUgd2hvbGUgbnVtYmVyIGluIEpTT04uXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZU51bWJlclNpemUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKS5sZW5ndGg7XG59XG5leHBvcnRzLmNhbGN1bGF0ZU51bWJlclNpemUgPSBjYWxjdWxhdGVOdW1iZXJTaXplO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWlzYy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjYWxjdWxhdGVOdW1iZXJTaXplIiwiY2FsY3VsYXRlU3RyaW5nU2l6ZSIsImlzQVNDSUkiLCJpc1BsYWluT2JqZWN0IiwiRVNDQVBFX0NIQVJBQ1RFUlNfUkVHRVhQIiwiSnNvblNpemUiLCJoYXNQcm9wZXJ0eSIsImlzT2JqZWN0IiwiaXNOdWxsT3JVbmRlZmluZWQiLCJpc05vbkVtcHR5QXJyYXkiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJCb29sZWFuIiwib2JqZWN0VG9DaGVjayIsIm5hbWUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJwcm90byIsImdldFByb3RvdHlwZU9mIiwiXyIsImNoYXJhY3RlciIsImNoYXJDb2RlQXQiLCJfYSIsInNpemUiLCJzcGxpdCIsInJlZHVjZSIsInRvdGFsIiwibWF0Y2giLCJ0b1N0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/misc.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/number.js":
/*!************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/number.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.hexToBigInt = exports.hexToNumber = exports.bigIntToHex = exports.numberToHex = void 0;\nconst assert_1 = __webpack_require__(/*! ./assert */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/assert.js\");\nconst hex_1 = __webpack_require__(/*! ./hex */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/hex.js\");\n/**\n * Convert a number to a hexadecimal string. This verifies that the number is a\n * non-negative safe integer.\n *\n * To convert a `bigint` to a hexadecimal string instead, use\n * {@link bigIntToHex}.\n *\n * @example\n * ```typescript\n * numberToHex(0); // '0x0'\n * numberToHex(1); // '0x1'\n * numberToHex(16); // '0x10'\n * ```\n * @param value - The number to convert to a hexadecimal string.\n * @returns The hexadecimal string, with the \"0x\"-prefix.\n * @throws If the number is not a non-negative safe integer.\n */ const numberToHex = (value)=>{\n    (0, assert_1.assert)(typeof value === \"number\", \"Value must be a number.\");\n    (0, assert_1.assert)(value >= 0, \"Value must be a non-negative number.\");\n    (0, assert_1.assert)(Number.isSafeInteger(value), \"Value is not a safe integer. Use `bigIntToHex` instead.\");\n    return (0, hex_1.add0x)(value.toString(16));\n};\nexports.numberToHex = numberToHex;\n/**\n * Convert a `bigint` to a hexadecimal string. This verifies that the `bigint`\n * is a non-negative integer.\n *\n * To convert a number to a hexadecimal string instead, use {@link numberToHex}.\n *\n * @example\n * ```typescript\n * bigIntToHex(0n); // '0x0'\n * bigIntToHex(1n); // '0x1'\n * bigIntToHex(16n); // '0x10'\n * ```\n * @param value - The `bigint` to convert to a hexadecimal string.\n * @returns The hexadecimal string, with the \"0x\"-prefix.\n * @throws If the `bigint` is not a non-negative integer.\n */ const bigIntToHex = (value)=>{\n    (0, assert_1.assert)(typeof value === \"bigint\", \"Value must be a bigint.\");\n    (0, assert_1.assert)(value >= 0, \"Value must be a non-negative bigint.\");\n    return (0, hex_1.add0x)(value.toString(16));\n};\nexports.bigIntToHex = bigIntToHex;\n/**\n * Convert a hexadecimal string to a number. This verifies that the string is a\n * valid hex string, and that the resulting number is a safe integer. Both\n * \"0x\"-prefixed and unprefixed strings are supported.\n *\n * To convert a hexadecimal string to a `bigint` instead, use\n * {@link hexToBigInt}.\n *\n * @example\n * ```typescript\n * hexToNumber('0x0'); // 0\n * hexToNumber('0x1'); // 1\n * hexToNumber('0x10'); // 16\n * ```\n * @param value - The hexadecimal string to convert to a number.\n * @returns The number.\n * @throws If the value is not a valid hexadecimal string, or if the resulting\n * number is not a safe integer.\n */ const hexToNumber = (value)=>{\n    (0, hex_1.assertIsHexString)(value);\n    // `parseInt` accepts values without the \"0x\"-prefix, whereas `Number` does\n    // not. Using this is slightly faster than `Number(add0x(value))`.\n    const numberValue = parseInt(value, 16);\n    (0, assert_1.assert)(Number.isSafeInteger(numberValue), \"Value is not a safe integer. Use `hexToBigInt` instead.\");\n    return numberValue;\n};\nexports.hexToNumber = hexToNumber;\n/**\n * Convert a hexadecimal string to a `bigint`. This verifies that the string is\n * a valid hex string. Both \"0x\"-prefixed and unprefixed strings are supported.\n *\n * To convert a hexadecimal string to a number instead, use {@link hexToNumber}.\n *\n * @example\n * ```typescript\n * hexToBigInt('0x0'); // 0n\n * hexToBigInt('0x1'); // 1n\n * hexToBigInt('0x10'); // 16n\n * ```\n * @param value - The hexadecimal string to convert to a `bigint`.\n * @returns The `bigint`.\n * @throws If the value is not a valid hexadecimal string.\n */ const hexToBigInt = (value)=>{\n    (0, hex_1.assertIsHexString)(value);\n    // The `BigInt` constructor requires the \"0x\"-prefix to parse a hex string.\n    return BigInt((0, hex_1.add0x)(value));\n};\nexports.hexToBigInt = hexToBigInt; //# sourceMappingURL=number.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L251bWJlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUJBQW1CLEdBQUdBLG1CQUFtQixHQUFHQSxtQkFBbUIsR0FBR0EsbUJBQW1CLEdBQUcsS0FBSztBQUM3RixNQUFNTSxXQUFXQyxtQkFBT0EsQ0FBQyxvR0FBVTtBQUNuQyxNQUFNQyxRQUFRRCxtQkFBT0EsQ0FBQyw4RkFBTztBQUM3Qjs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUNELE1BQU1GLGNBQWMsQ0FBQ0o7SUFDaEIsSUFBR0ssU0FBU0csTUFBTSxFQUFFLE9BQU9SLFVBQVUsVUFBVTtJQUMvQyxJQUFHSyxTQUFTRyxNQUFNLEVBQUVSLFNBQVMsR0FBRztJQUNoQyxJQUFHSyxTQUFTRyxNQUFNLEVBQUVDLE9BQU9DLGFBQWEsQ0FBQ1YsUUFBUTtJQUNsRCxPQUFPLENBQUMsR0FBR08sTUFBTUksS0FBSyxFQUFFWCxNQUFNWSxRQUFRLENBQUM7QUFDM0M7QUFDQWIsbUJBQW1CLEdBQUdLO0FBQ3RCOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNELE1BQU1ELGNBQWMsQ0FBQ0g7SUFDaEIsSUFBR0ssU0FBU0csTUFBTSxFQUFFLE9BQU9SLFVBQVUsVUFBVTtJQUMvQyxJQUFHSyxTQUFTRyxNQUFNLEVBQUVSLFNBQVMsR0FBRztJQUNqQyxPQUFPLENBQUMsR0FBR08sTUFBTUksS0FBSyxFQUFFWCxNQUFNWSxRQUFRLENBQUM7QUFDM0M7QUFDQWIsbUJBQW1CLEdBQUdJO0FBQ3RCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkMsR0FDRCxNQUFNRCxjQUFjLENBQUNGO0lBQ2hCLElBQUdPLE1BQU1NLGlCQUFpQixFQUFFYjtJQUM3QiwyRUFBMkU7SUFDM0Usa0VBQWtFO0lBQ2xFLE1BQU1jLGNBQWNDLFNBQVNmLE9BQU87SUFDbkMsSUFBR0ssU0FBU0csTUFBTSxFQUFFQyxPQUFPQyxhQUFhLENBQUNJLGNBQWM7SUFDeEQsT0FBT0E7QUFDWDtBQUNBZixtQkFBbUIsR0FBR0c7QUFDdEI7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0QsTUFBTUQsY0FBYyxDQUFDRDtJQUNoQixJQUFHTyxNQUFNTSxpQkFBaUIsRUFBRWI7SUFDN0IsMkVBQTJFO0lBQzNFLE9BQU9nQixPQUFPLENBQUMsR0FBR1QsTUFBTUksS0FBSyxFQUFFWDtBQUNuQztBQUNBRCxtQkFBbUIsR0FBR0UsYUFDdEIsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RhYmxlLXJvdXRlci13ZWIvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L251bWJlci5qcz8zNjNhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oZXhUb0JpZ0ludCA9IGV4cG9ydHMuaGV4VG9OdW1iZXIgPSBleHBvcnRzLmJpZ0ludFRvSGV4ID0gZXhwb3J0cy5udW1iZXJUb0hleCA9IHZvaWQgMDtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcIi4vYXNzZXJ0XCIpO1xuY29uc3QgaGV4XzEgPSByZXF1aXJlKFwiLi9oZXhcIik7XG4vKipcbiAqIENvbnZlcnQgYSBudW1iZXIgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuIFRoaXMgdmVyaWZpZXMgdGhhdCB0aGUgbnVtYmVyIGlzIGFcbiAqIG5vbi1uZWdhdGl2ZSBzYWZlIGludGVnZXIuXG4gKlxuICogVG8gY29udmVydCBhIGBiaWdpbnRgIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nIGluc3RlYWQsIHVzZVxuICoge0BsaW5rIGJpZ0ludFRvSGV4fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogbnVtYmVyVG9IZXgoMCk7IC8vICcweDAnXG4gKiBudW1iZXJUb0hleCgxKTsgLy8gJzB4MSdcbiAqIG51bWJlclRvSGV4KDE2KTsgLy8gJzB4MTAnXG4gKiBgYGBcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBudW1iZXIgdG8gY29udmVydCB0byBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcsIHdpdGggdGhlIFwiMHhcIi1wcmVmaXguXG4gKiBAdGhyb3dzIElmIHRoZSBudW1iZXIgaXMgbm90IGEgbm9uLW5lZ2F0aXZlIHNhZmUgaW50ZWdlci5cbiAqL1xuY29uc3QgbnVtYmVyVG9IZXggPSAodmFsdWUpID0+IHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnVmFsdWUgbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh2YWx1ZSA+PSAwLCAnVmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoTnVtYmVyLmlzU2FmZUludGVnZXIodmFsdWUpLCAnVmFsdWUgaXMgbm90IGEgc2FmZSBpbnRlZ2VyLiBVc2UgYGJpZ0ludFRvSGV4YCBpbnN0ZWFkLicpO1xuICAgIHJldHVybiAoMCwgaGV4XzEuYWRkMHgpKHZhbHVlLnRvU3RyaW5nKDE2KSk7XG59O1xuZXhwb3J0cy5udW1iZXJUb0hleCA9IG51bWJlclRvSGV4O1xuLyoqXG4gKiBDb252ZXJ0IGEgYGJpZ2ludGAgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuIFRoaXMgdmVyaWZpZXMgdGhhdCB0aGUgYGJpZ2ludGBcbiAqIGlzIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIuXG4gKlxuICogVG8gY29udmVydCBhIG51bWJlciB0byBhIGhleGFkZWNpbWFsIHN0cmluZyBpbnN0ZWFkLCB1c2Uge0BsaW5rIG51bWJlclRvSGV4fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogYmlnSW50VG9IZXgoMG4pOyAvLyAnMHgwJ1xuICogYmlnSW50VG9IZXgoMW4pOyAvLyAnMHgxJ1xuICogYmlnSW50VG9IZXgoMTZuKTsgLy8gJzB4MTAnXG4gKiBgYGBcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBgYmlnaW50YCB0byBjb252ZXJ0IHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIGhleGFkZWNpbWFsIHN0cmluZywgd2l0aCB0aGUgXCIweFwiLXByZWZpeC5cbiAqIEB0aHJvd3MgSWYgdGhlIGBiaWdpbnRgIGlzIG5vdCBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLlxuICovXG5jb25zdCBiaWdJbnRUb0hleCA9ICh2YWx1ZSkgPT4ge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcsICdWYWx1ZSBtdXN0IGJlIGEgYmlnaW50LicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHZhbHVlID49IDAsICdWYWx1ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGJpZ2ludC4nKTtcbiAgICByZXR1cm4gKDAsIGhleF8xLmFkZDB4KSh2YWx1ZS50b1N0cmluZygxNikpO1xufTtcbmV4cG9ydHMuYmlnSW50VG9IZXggPSBiaWdJbnRUb0hleDtcbi8qKlxuICogQ29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBhIG51bWJlci4gVGhpcyB2ZXJpZmllcyB0aGF0IHRoZSBzdHJpbmcgaXMgYVxuICogdmFsaWQgaGV4IHN0cmluZywgYW5kIHRoYXQgdGhlIHJlc3VsdGluZyBudW1iZXIgaXMgYSBzYWZlIGludGVnZXIuIEJvdGhcbiAqIFwiMHhcIi1wcmVmaXhlZCBhbmQgdW5wcmVmaXhlZCBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQuXG4gKlxuICogVG8gY29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBhIGBiaWdpbnRgIGluc3RlYWQsIHVzZVxuICoge0BsaW5rIGhleFRvQmlnSW50fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaGV4VG9OdW1iZXIoJzB4MCcpOyAvLyAwXG4gKiBoZXhUb051bWJlcignMHgxJyk7IC8vIDFcbiAqIGhleFRvTnVtYmVyKCcweDEwJyk7IC8vIDE2XG4gKiBgYGBcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gY29udmVydCB0byBhIG51bWJlci5cbiAqIEByZXR1cm5zIFRoZSBudW1iZXIuXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBoZXhhZGVjaW1hbCBzdHJpbmcsIG9yIGlmIHRoZSByZXN1bHRpbmdcbiAqIG51bWJlciBpcyBub3QgYSBzYWZlIGludGVnZXIuXG4gKi9cbmNvbnN0IGhleFRvTnVtYmVyID0gKHZhbHVlKSA9PiB7XG4gICAgKDAsIGhleF8xLmFzc2VydElzSGV4U3RyaW5nKSh2YWx1ZSk7XG4gICAgLy8gYHBhcnNlSW50YCBhY2NlcHRzIHZhbHVlcyB3aXRob3V0IHRoZSBcIjB4XCItcHJlZml4LCB3aGVyZWFzIGBOdW1iZXJgIGRvZXNcbiAgICAvLyBub3QuIFVzaW5nIHRoaXMgaXMgc2xpZ2h0bHkgZmFzdGVyIHRoYW4gYE51bWJlcihhZGQweCh2YWx1ZSkpYC5cbiAgICBjb25zdCBudW1iZXJWYWx1ZSA9IHBhcnNlSW50KHZhbHVlLCAxNik7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoTnVtYmVyLmlzU2FmZUludGVnZXIobnVtYmVyVmFsdWUpLCAnVmFsdWUgaXMgbm90IGEgc2FmZSBpbnRlZ2VyLiBVc2UgYGhleFRvQmlnSW50YCBpbnN0ZWFkLicpO1xuICAgIHJldHVybiBudW1iZXJWYWx1ZTtcbn07XG5leHBvcnRzLmhleFRvTnVtYmVyID0gaGV4VG9OdW1iZXI7XG4vKipcbiAqIENvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBgYmlnaW50YC4gVGhpcyB2ZXJpZmllcyB0aGF0IHRoZSBzdHJpbmcgaXNcbiAqIGEgdmFsaWQgaGV4IHN0cmluZy4gQm90aCBcIjB4XCItcHJlZml4ZWQgYW5kIHVucHJlZml4ZWQgc3RyaW5ncyBhcmUgc3VwcG9ydGVkLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBudW1iZXIgaW5zdGVhZCwgdXNlIHtAbGluayBoZXhUb051bWJlcn0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGhleFRvQmlnSW50KCcweDAnKTsgLy8gMG5cbiAqIGhleFRvQmlnSW50KCcweDEnKTsgLy8gMW5cbiAqIGhleFRvQmlnSW50KCcweDEwJyk7IC8vIDE2blxuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGNvbnZlcnQgdG8gYSBgYmlnaW50YC5cbiAqIEByZXR1cm5zIFRoZSBgYmlnaW50YC5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xuY29uc3QgaGV4VG9CaWdJbnQgPSAodmFsdWUpID0+IHtcbiAgICAoMCwgaGV4XzEuYXNzZXJ0SXNIZXhTdHJpbmcpKHZhbHVlKTtcbiAgICAvLyBUaGUgYEJpZ0ludGAgY29uc3RydWN0b3IgcmVxdWlyZXMgdGhlIFwiMHhcIi1wcmVmaXggdG8gcGFyc2UgYSBoZXggc3RyaW5nLlxuICAgIHJldHVybiBCaWdJbnQoKDAsIGhleF8xLmFkZDB4KSh2YWx1ZSkpO1xufTtcbmV4cG9ydHMuaGV4VG9CaWdJbnQgPSBoZXhUb0JpZ0ludDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW51bWJlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJoZXhUb0JpZ0ludCIsImhleFRvTnVtYmVyIiwiYmlnSW50VG9IZXgiLCJudW1iZXJUb0hleCIsImFzc2VydF8xIiwicmVxdWlyZSIsImhleF8xIiwiYXNzZXJ0IiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsImFkZDB4IiwidG9TdHJpbmciLCJhc3NlcnRJc0hleFN0cmluZyIsIm51bWJlclZhbHVlIiwicGFyc2VJbnQiLCJCaWdJbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/number.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/opaque.js":
/*!************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/opaque.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n})); //# sourceMappingURL=opaque.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L29wYXF1ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQyxFQUM3RCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGFibGUtcm91dGVyLXdlYi8uL25vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3Qvb3BhcXVlLmpzPzRiYjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcGFxdWUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/opaque.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/time.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/time.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.timeSince = exports.inMilliseconds = exports.Duration = void 0;\n/**\n * Common duration constants, in milliseconds.\n */ var Duration;\n(function(Duration) {\n    /**\n     * A millisecond.\n     */ Duration[Duration[\"Millisecond\"] = 1] = \"Millisecond\";\n    /**\n     * A second, in milliseconds.\n     */ Duration[Duration[\"Second\"] = 1000] = \"Second\";\n    /**\n     * A minute, in milliseconds.\n     */ Duration[Duration[\"Minute\"] = 60000] = \"Minute\";\n    /**\n     * An hour, in milliseconds.\n     */ Duration[Duration[\"Hour\"] = 3600000] = \"Hour\";\n    /**\n     * A day, in milliseconds.\n     */ Duration[Duration[\"Day\"] = 86400000] = \"Day\";\n    /**\n     * A week, in milliseconds.\n     */ Duration[Duration[\"Week\"] = 604800000] = \"Week\";\n    /**\n     * A year, in milliseconds.\n     */ Duration[Duration[\"Year\"] = 31536000000] = \"Year\";\n})(Duration = exports.Duration || (exports.Duration = {}));\nconst isNonNegativeInteger = (number)=>Number.isInteger(number) && number >= 0;\nconst assertIsNonNegativeInteger = (number, name)=>{\n    if (!isNonNegativeInteger(number)) {\n        throw new Error(`\"${name}\" must be a non-negative integer. Received: \"${number}\".`);\n    }\n};\n/**\n * Calculates the millisecond value of the specified number of units of time.\n *\n * @param count - The number of units of time.\n * @param duration - The unit of time to count.\n * @returns The count multiplied by the specified duration.\n */ function inMilliseconds(count, duration) {\n    assertIsNonNegativeInteger(count, \"count\");\n    return count * duration;\n}\nexports.inMilliseconds = inMilliseconds;\n/**\n * Gets the milliseconds since a particular Unix epoch timestamp.\n *\n * @param timestamp - A Unix millisecond timestamp.\n * @returns The number of milliseconds elapsed since the specified timestamp.\n */ function timeSince(timestamp) {\n    assertIsNonNegativeInteger(timestamp, \"timestamp\");\n    return Date.now() - timestamp;\n}\nexports.timeSince = timeSince; //# sourceMappingURL=time.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3RpbWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGlCQUFpQixHQUFHQSxzQkFBc0IsR0FBR0EsZ0JBQWdCLEdBQUcsS0FBSztBQUNyRTs7Q0FFQyxHQUNELElBQUlJO0FBQ0gsVUFBVUEsUUFBUTtJQUNmOztLQUVDLEdBQ0RBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLGNBQWMsR0FBRyxFQUFFLEdBQUc7SUFDeEM7O0tBRUMsR0FDREEsUUFBUSxDQUFDQSxRQUFRLENBQUMsU0FBUyxHQUFHLEtBQUssR0FBRztJQUN0Qzs7S0FFQyxHQUNEQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxTQUFTLEdBQUcsTUFBTSxHQUFHO0lBQ3ZDOztLQUVDLEdBQ0RBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLE9BQU8sR0FBRyxRQUFRLEdBQUc7SUFDdkM7O0tBRUMsR0FDREEsUUFBUSxDQUFDQSxRQUFRLENBQUMsTUFBTSxHQUFHLFNBQVMsR0FBRztJQUN2Qzs7S0FFQyxHQUNEQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxPQUFPLEdBQUcsVUFBVSxHQUFHO0lBQ3pDOztLQUVDLEdBQ0RBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLE9BQU8sR0FBRyxZQUFZLEdBQUc7QUFDL0MsR0FBR0EsV0FBV0osUUFBUUksUUFBUSxJQUFLSixDQUFBQSxnQkFBZ0IsR0FBRyxDQUFDO0FBQ3ZELE1BQU1LLHVCQUF1QixDQUFDQyxTQUFXQyxPQUFPQyxTQUFTLENBQUNGLFdBQVdBLFVBQVU7QUFDL0UsTUFBTUcsNkJBQTZCLENBQUNILFFBQVFJO0lBQ3hDLElBQUksQ0FBQ0wscUJBQXFCQyxTQUFTO1FBQy9CLE1BQU0sSUFBSUssTUFBTSxDQUFDLENBQUMsRUFBRUQsS0FBSyw2Q0FBNkMsRUFBRUosT0FBTyxFQUFFLENBQUM7SUFDdEY7QUFDSjtBQUNBOzs7Ozs7Q0FNQyxHQUNELFNBQVNILGVBQWVTLEtBQUssRUFBRUMsUUFBUTtJQUNuQ0osMkJBQTJCRyxPQUFPO0lBQ2xDLE9BQU9BLFFBQVFDO0FBQ25CO0FBQ0FiLHNCQUFzQixHQUFHRztBQUN6Qjs7Ozs7Q0FLQyxHQUNELFNBQVNELFVBQVVZLFNBQVM7SUFDeEJMLDJCQUEyQkssV0FBVztJQUN0QyxPQUFPQyxLQUFLQyxHQUFHLEtBQUtGO0FBQ3hCO0FBQ0FkLGlCQUFpQixHQUFHRSxXQUNwQixnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGFibGUtcm91dGVyLXdlYi8uL25vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvdGltZS5qcz8wMWFlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50aW1lU2luY2UgPSBleHBvcnRzLmluTWlsbGlzZWNvbmRzID0gZXhwb3J0cy5EdXJhdGlvbiA9IHZvaWQgMDtcbi8qKlxuICogQ29tbW9uIGR1cmF0aW9uIGNvbnN0YW50cywgaW4gbWlsbGlzZWNvbmRzLlxuICovXG52YXIgRHVyYXRpb247XG4oZnVuY3Rpb24gKER1cmF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQSBtaWxsaXNlY29uZC5cbiAgICAgKi9cbiAgICBEdXJhdGlvbltEdXJhdGlvbltcIk1pbGxpc2Vjb25kXCJdID0gMV0gPSBcIk1pbGxpc2Vjb25kXCI7XG4gICAgLyoqXG4gICAgICogQSBzZWNvbmQsIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBEdXJhdGlvbltEdXJhdGlvbltcIlNlY29uZFwiXSA9IDEwMDBdID0gXCJTZWNvbmRcIjtcbiAgICAvKipcbiAgICAgKiBBIG1pbnV0ZSwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiTWludXRlXCJdID0gNjAwMDBdID0gXCJNaW51dGVcIjtcbiAgICAvKipcbiAgICAgKiBBbiBob3VyLCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgRHVyYXRpb25bRHVyYXRpb25bXCJIb3VyXCJdID0gMzYwMDAwMF0gPSBcIkhvdXJcIjtcbiAgICAvKipcbiAgICAgKiBBIGRheSwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiRGF5XCJdID0gODY0MDAwMDBdID0gXCJEYXlcIjtcbiAgICAvKipcbiAgICAgKiBBIHdlZWssIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBEdXJhdGlvbltEdXJhdGlvbltcIldlZWtcIl0gPSA2MDQ4MDAwMDBdID0gXCJXZWVrXCI7XG4gICAgLyoqXG4gICAgICogQSB5ZWFyLCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgRHVyYXRpb25bRHVyYXRpb25bXCJZZWFyXCJdID0gMzE1MzYwMDAwMDBdID0gXCJZZWFyXCI7XG59KShEdXJhdGlvbiA9IGV4cG9ydHMuRHVyYXRpb24gfHwgKGV4cG9ydHMuRHVyYXRpb24gPSB7fSkpO1xuY29uc3QgaXNOb25OZWdhdGl2ZUludGVnZXIgPSAobnVtYmVyKSA9PiBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcikgJiYgbnVtYmVyID49IDA7XG5jb25zdCBhc3NlcnRJc05vbk5lZ2F0aXZlSW50ZWdlciA9IChudW1iZXIsIG5hbWUpID0+IHtcbiAgICBpZiAoIWlzTm9uTmVnYXRpdmVJbnRlZ2VyKG51bWJlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7bmFtZX1cIiBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIuIFJlY2VpdmVkOiBcIiR7bnVtYmVyfVwiLmApO1xuICAgIH1cbn07XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIG1pbGxpc2Vjb25kIHZhbHVlIG9mIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHVuaXRzIG9mIHRpbWUuXG4gKlxuICogQHBhcmFtIGNvdW50IC0gVGhlIG51bWJlciBvZiB1bml0cyBvZiB0aW1lLlxuICogQHBhcmFtIGR1cmF0aW9uIC0gVGhlIHVuaXQgb2YgdGltZSB0byBjb3VudC5cbiAqIEByZXR1cm5zIFRoZSBjb3VudCBtdWx0aXBsaWVkIGJ5IHRoZSBzcGVjaWZpZWQgZHVyYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGluTWlsbGlzZWNvbmRzKGNvdW50LCBkdXJhdGlvbikge1xuICAgIGFzc2VydElzTm9uTmVnYXRpdmVJbnRlZ2VyKGNvdW50LCAnY291bnQnKTtcbiAgICByZXR1cm4gY291bnQgKiBkdXJhdGlvbjtcbn1cbmV4cG9ydHMuaW5NaWxsaXNlY29uZHMgPSBpbk1pbGxpc2Vjb25kcztcbi8qKlxuICogR2V0cyB0aGUgbWlsbGlzZWNvbmRzIHNpbmNlIGEgcGFydGljdWxhciBVbml4IGVwb2NoIHRpbWVzdGFtcC5cbiAqXG4gKiBAcGFyYW0gdGltZXN0YW1wIC0gQSBVbml4IG1pbGxpc2Vjb25kIHRpbWVzdGFtcC5cbiAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGVsYXBzZWQgc2luY2UgdGhlIHNwZWNpZmllZCB0aW1lc3RhbXAuXG4gKi9cbmZ1bmN0aW9uIHRpbWVTaW5jZSh0aW1lc3RhbXApIHtcbiAgICBhc3NlcnRJc05vbk5lZ2F0aXZlSW50ZWdlcih0aW1lc3RhbXAsICd0aW1lc3RhbXAnKTtcbiAgICByZXR1cm4gRGF0ZS5ub3coKSAtIHRpbWVzdGFtcDtcbn1cbmV4cG9ydHMudGltZVNpbmNlID0gdGltZVNpbmNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ0aW1lU2luY2UiLCJpbk1pbGxpc2Vjb25kcyIsIkR1cmF0aW9uIiwiaXNOb25OZWdhdGl2ZUludGVnZXIiLCJudW1iZXIiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJhc3NlcnRJc05vbk5lZ2F0aXZlSW50ZWdlciIsIm5hbWUiLCJFcnJvciIsImNvdW50IiwiZHVyYXRpb24iLCJ0aW1lc3RhbXAiLCJEYXRlIiwibm93Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/time.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/transaction-types.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/transaction-types.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n})); //# sourceMappingURL=transaction-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3RyYW5zYWN0aW9uLXR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDLEVBQzdELDZDQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovL3N0YWJsZS1yb3V0ZXItd2ViLy4vbm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC90cmFuc2FjdGlvbi10eXBlcy5qcz8yMjMyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNhY3Rpb24tdHlwZXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/transaction-types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/versions.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/versions.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.satisfiesVersionRange = exports.gtRange = exports.gtVersion = exports.assertIsSemVerRange = exports.assertIsSemVerVersion = exports.isValidSemVerRange = exports.isValidSemVerVersion = exports.VersionRangeStruct = exports.VersionStruct = void 0;\nconst semver_1 = __webpack_require__(/*! semver */ \"(ssr)/./node_modules/semver/index.js\");\nconst superstruct_1 = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\nconst assert_1 = __webpack_require__(/*! ./assert */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/assert.js\");\n/**\n * A struct for validating a version string.\n */ exports.VersionStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), \"Version\", (value)=>{\n    if ((0, semver_1.valid)(value) === null) {\n        return `Expected SemVer version, got \"${value}\"`;\n    }\n    return true;\n});\nexports.VersionRangeStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), \"Version range\", (value)=>{\n    if ((0, semver_1.validRange)(value) === null) {\n        return `Expected SemVer range, got \"${value}\"`;\n    }\n    return true;\n});\n/**\n * Checks whether a SemVer version is valid.\n *\n * @param version - A potential version.\n * @returns `true` if the version is valid, and `false` otherwise.\n */ function isValidSemVerVersion(version) {\n    return (0, superstruct_1.is)(version, exports.VersionStruct);\n}\nexports.isValidSemVerVersion = isValidSemVerVersion;\n/**\n * Checks whether a SemVer version range is valid.\n *\n * @param versionRange - A potential version range.\n * @returns `true` if the version range is valid, and `false` otherwise.\n */ function isValidSemVerRange(versionRange) {\n    return (0, superstruct_1.is)(versionRange, exports.VersionRangeStruct);\n}\nexports.isValidSemVerRange = isValidSemVerRange;\n/**\n * Asserts that a value is a valid concrete SemVer version.\n *\n * @param version - A potential SemVer concrete version.\n */ function assertIsSemVerVersion(version) {\n    (0, assert_1.assertStruct)(version, exports.VersionStruct);\n}\nexports.assertIsSemVerVersion = assertIsSemVerVersion;\n/**\n * Asserts that a value is a valid SemVer range.\n *\n * @param range - A potential SemVer range.\n */ function assertIsSemVerRange(range) {\n    (0, assert_1.assertStruct)(range, exports.VersionRangeStruct);\n}\nexports.assertIsSemVerRange = assertIsSemVerRange;\n/**\n * Checks whether a SemVer version is greater than another.\n *\n * @param version1 - The left-hand version.\n * @param version2 - The right-hand version.\n * @returns `version1 > version2`.\n */ function gtVersion(version1, version2) {\n    return (0, semver_1.gt)(version1, version2);\n}\nexports.gtVersion = gtVersion;\n/**\n * Checks whether a SemVer version is greater than all possibilities in a range.\n *\n * @param version - A SemvVer version.\n * @param range - The range to check against.\n * @returns `version > range`.\n */ function gtRange(version, range) {\n    return (0, semver_1.gtr)(version, range);\n}\nexports.gtRange = gtRange;\n/**\n * Returns whether a SemVer version satisfies a SemVer range.\n *\n * @param version - The SemVer version to check.\n * @param versionRange - The SemVer version range to check against.\n * @returns Whether the version satisfied the version range.\n */ function satisfiesVersionRange(version, versionRange) {\n    return (0, semver_1.satisfies)(version, versionRange, {\n        includePrerelease: true\n    });\n}\nexports.satisfiesVersionRange = satisfiesVersionRange; //# sourceMappingURL=versions.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3ZlcnNpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCw2QkFBNkIsR0FBR0EsZUFBZSxHQUFHQSxpQkFBaUIsR0FBR0EsMkJBQTJCLEdBQUdBLDZCQUE2QixHQUFHQSwwQkFBMEIsR0FBR0EsNEJBQTRCLEdBQUdBLDBCQUEwQixHQUFHQSxxQkFBcUIsR0FBRyxLQUFLO0FBQzFQLE1BQU1XLFdBQVdDLG1CQUFPQSxDQUFDLG9EQUFRO0FBQ2pDLE1BQU1DLGdCQUFnQkQsbUJBQU9BLENBQUMsb0VBQWE7QUFDM0MsTUFBTUUsV0FBV0YsbUJBQU9BLENBQUMsb0dBQVU7QUFDbkM7O0NBRUMsR0FDRFoscUJBQXFCLEdBQUcsQ0FBQyxHQUFHYSxjQUFjRSxNQUFNLEVBQUUsQ0FBQyxHQUFHRixjQUFjRyxNQUFNLEtBQUssV0FBVyxDQUFDZjtJQUN2RixJQUFJLENBQUMsR0FBR1UsU0FBU00sS0FBSyxFQUFFaEIsV0FBVyxNQUFNO1FBQ3JDLE9BQU8sQ0FBQyw4QkFBOEIsRUFBRUEsTUFBTSxDQUFDLENBQUM7SUFDcEQ7SUFDQSxPQUFPO0FBQ1g7QUFDQUQsMEJBQTBCLEdBQUcsQ0FBQyxHQUFHYSxjQUFjRSxNQUFNLEVBQUUsQ0FBQyxHQUFHRixjQUFjRyxNQUFNLEtBQUssaUJBQWlCLENBQUNmO0lBQ2xHLElBQUksQ0FBQyxHQUFHVSxTQUFTTyxVQUFVLEVBQUVqQixXQUFXLE1BQU07UUFDMUMsT0FBTyxDQUFDLDRCQUE0QixFQUFFQSxNQUFNLENBQUMsQ0FBQztJQUNsRDtJQUNBLE9BQU87QUFDWDtBQUNBOzs7OztDQUtDLEdBQ0QsU0FBU08scUJBQXFCVyxPQUFPO0lBQ2pDLE9BQU8sQ0FBQyxHQUFHTixjQUFjTyxFQUFFLEVBQUVELFNBQVNuQixRQUFRVSxhQUFhO0FBQy9EO0FBQ0FWLDRCQUE0QixHQUFHUTtBQUMvQjs7Ozs7Q0FLQyxHQUNELFNBQVNELG1CQUFtQmMsWUFBWTtJQUNwQyxPQUFPLENBQUMsR0FBR1IsY0FBY08sRUFBRSxFQUFFQyxjQUFjckIsUUFBUVMsa0JBQWtCO0FBQ3pFO0FBQ0FULDBCQUEwQixHQUFHTztBQUM3Qjs7OztDQUlDLEdBQ0QsU0FBU0Qsc0JBQXNCYSxPQUFPO0lBQ2pDLElBQUdMLFNBQVNRLFlBQVksRUFBRUgsU0FBU25CLFFBQVFVLGFBQWE7QUFDN0Q7QUFDQVYsNkJBQTZCLEdBQUdNO0FBQ2hDOzs7O0NBSUMsR0FDRCxTQUFTRCxvQkFBb0JrQixLQUFLO0lBQzdCLElBQUdULFNBQVNRLFlBQVksRUFBRUMsT0FBT3ZCLFFBQVFTLGtCQUFrQjtBQUNoRTtBQUNBVCwyQkFBMkIsR0FBR0s7QUFDOUI7Ozs7OztDQU1DLEdBQ0QsU0FBU0QsVUFBVW9CLFFBQVEsRUFBRUMsUUFBUTtJQUNqQyxPQUFPLENBQUMsR0FBR2QsU0FBU2UsRUFBRSxFQUFFRixVQUFVQztBQUN0QztBQUNBekIsaUJBQWlCLEdBQUdJO0FBQ3BCOzs7Ozs7Q0FNQyxHQUNELFNBQVNELFFBQVFnQixPQUFPLEVBQUVJLEtBQUs7SUFDM0IsT0FBTyxDQUFDLEdBQUdaLFNBQVNnQixHQUFHLEVBQUVSLFNBQVNJO0FBQ3RDO0FBQ0F2QixlQUFlLEdBQUdHO0FBQ2xCOzs7Ozs7Q0FNQyxHQUNELFNBQVNELHNCQUFzQmlCLE9BQU8sRUFBRUUsWUFBWTtJQUNoRCxPQUFPLENBQUMsR0FBR1YsU0FBU2lCLFNBQVMsRUFBRVQsU0FBU0UsY0FBYztRQUNsRFEsbUJBQW1CO0lBQ3ZCO0FBQ0o7QUFDQTdCLDZCQUE2QixHQUFHRSx1QkFDaEMsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RhYmxlLXJvdXRlci13ZWIvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3ZlcnNpb25zLmpzPzA4MTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNhdGlzZmllc1ZlcnNpb25SYW5nZSA9IGV4cG9ydHMuZ3RSYW5nZSA9IGV4cG9ydHMuZ3RWZXJzaW9uID0gZXhwb3J0cy5hc3NlcnRJc1NlbVZlclJhbmdlID0gZXhwb3J0cy5hc3NlcnRJc1NlbVZlclZlcnNpb24gPSBleHBvcnRzLmlzVmFsaWRTZW1WZXJSYW5nZSA9IGV4cG9ydHMuaXNWYWxpZFNlbVZlclZlcnNpb24gPSBleHBvcnRzLlZlcnNpb25SYW5nZVN0cnVjdCA9IGV4cG9ydHMuVmVyc2lvblN0cnVjdCA9IHZvaWQgMDtcbmNvbnN0IHNlbXZlcl8xID0gcmVxdWlyZShcInNlbXZlclwiKTtcbmNvbnN0IHN1cGVyc3RydWN0XzEgPSByZXF1aXJlKFwic3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydFwiKTtcbi8qKlxuICogQSBzdHJ1Y3QgZm9yIHZhbGlkYXRpbmcgYSB2ZXJzaW9uIHN0cmluZy5cbiAqL1xuZXhwb3J0cy5WZXJzaW9uU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEucmVmaW5lKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksICdWZXJzaW9uJywgKHZhbHVlKSA9PiB7XG4gICAgaWYgKCgwLCBzZW12ZXJfMS52YWxpZCkodmFsdWUpID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBgRXhwZWN0ZWQgU2VtVmVyIHZlcnNpb24sIGdvdCBcIiR7dmFsdWV9XCJgO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuZXhwb3J0cy5WZXJzaW9uUmFuZ2VTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5yZWZpbmUpKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgJ1ZlcnNpb24gcmFuZ2UnLCAodmFsdWUpID0+IHtcbiAgICBpZiAoKDAsIHNlbXZlcl8xLnZhbGlkUmFuZ2UpKHZhbHVlKSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYEV4cGVjdGVkIFNlbVZlciByYW5nZSwgZ290IFwiJHt2YWx1ZX1cImA7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgU2VtVmVyIHZlcnNpb24gaXMgdmFsaWQuXG4gKlxuICogQHBhcmFtIHZlcnNpb24gLSBBIHBvdGVudGlhbCB2ZXJzaW9uLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2ZXJzaW9uIGlzIHZhbGlkLCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRTZW1WZXJWZXJzaW9uKHZlcnNpb24pIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZlcnNpb24sIGV4cG9ydHMuVmVyc2lvblN0cnVjdCk7XG59XG5leHBvcnRzLmlzVmFsaWRTZW1WZXJWZXJzaW9uID0gaXNWYWxpZFNlbVZlclZlcnNpb247XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgU2VtVmVyIHZlcnNpb24gcmFuZ2UgaXMgdmFsaWQuXG4gKlxuICogQHBhcmFtIHZlcnNpb25SYW5nZSAtIEEgcG90ZW50aWFsIHZlcnNpb24gcmFuZ2UuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZlcnNpb24gcmFuZ2UgaXMgdmFsaWQsIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFNlbVZlclJhbmdlKHZlcnNpb25SYW5nZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmVyc2lvblJhbmdlLCBleHBvcnRzLlZlcnNpb25SYW5nZVN0cnVjdCk7XG59XG5leHBvcnRzLmlzVmFsaWRTZW1WZXJSYW5nZSA9IGlzVmFsaWRTZW1WZXJSYW5nZTtcbi8qKlxuICogQXNzZXJ0cyB0aGF0IGEgdmFsdWUgaXMgYSB2YWxpZCBjb25jcmV0ZSBTZW1WZXIgdmVyc2lvbi5cbiAqXG4gKiBAcGFyYW0gdmVyc2lvbiAtIEEgcG90ZW50aWFsIFNlbVZlciBjb25jcmV0ZSB2ZXJzaW9uLlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc1NlbVZlclZlcnNpb24odmVyc2lvbikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZlcnNpb24sIGV4cG9ydHMuVmVyc2lvblN0cnVjdCk7XG59XG5leHBvcnRzLmFzc2VydElzU2VtVmVyVmVyc2lvbiA9IGFzc2VydElzU2VtVmVyVmVyc2lvbjtcbi8qKlxuICogQXNzZXJ0cyB0aGF0IGEgdmFsdWUgaXMgYSB2YWxpZCBTZW1WZXIgcmFuZ2UuXG4gKlxuICogQHBhcmFtIHJhbmdlIC0gQSBwb3RlbnRpYWwgU2VtVmVyIHJhbmdlLlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc1NlbVZlclJhbmdlKHJhbmdlKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkocmFuZ2UsIGV4cG9ydHMuVmVyc2lvblJhbmdlU3RydWN0KTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNTZW1WZXJSYW5nZSA9IGFzc2VydElzU2VtVmVyUmFuZ2U7XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgU2VtVmVyIHZlcnNpb24gaXMgZ3JlYXRlciB0aGFuIGFub3RoZXIuXG4gKlxuICogQHBhcmFtIHZlcnNpb24xIC0gVGhlIGxlZnQtaGFuZCB2ZXJzaW9uLlxuICogQHBhcmFtIHZlcnNpb24yIC0gVGhlIHJpZ2h0LWhhbmQgdmVyc2lvbi5cbiAqIEByZXR1cm5zIGB2ZXJzaW9uMSA+IHZlcnNpb24yYC5cbiAqL1xuZnVuY3Rpb24gZ3RWZXJzaW9uKHZlcnNpb24xLCB2ZXJzaW9uMikge1xuICAgIHJldHVybiAoMCwgc2VtdmVyXzEuZ3QpKHZlcnNpb24xLCB2ZXJzaW9uMik7XG59XG5leHBvcnRzLmd0VmVyc2lvbiA9IGd0VmVyc2lvbjtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBTZW1WZXIgdmVyc2lvbiBpcyBncmVhdGVyIHRoYW4gYWxsIHBvc3NpYmlsaXRpZXMgaW4gYSByYW5nZS5cbiAqXG4gKiBAcGFyYW0gdmVyc2lvbiAtIEEgU2VtdlZlciB2ZXJzaW9uLlxuICogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGNoZWNrIGFnYWluc3QuXG4gKiBAcmV0dXJucyBgdmVyc2lvbiA+IHJhbmdlYC5cbiAqL1xuZnVuY3Rpb24gZ3RSYW5nZSh2ZXJzaW9uLCByYW5nZSkge1xuICAgIHJldHVybiAoMCwgc2VtdmVyXzEuZ3RyKSh2ZXJzaW9uLCByYW5nZSk7XG59XG5leHBvcnRzLmd0UmFuZ2UgPSBndFJhbmdlO1xuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgYSBTZW1WZXIgdmVyc2lvbiBzYXRpc2ZpZXMgYSBTZW1WZXIgcmFuZ2UuXG4gKlxuICogQHBhcmFtIHZlcnNpb24gLSBUaGUgU2VtVmVyIHZlcnNpb24gdG8gY2hlY2suXG4gKiBAcGFyYW0gdmVyc2lvblJhbmdlIC0gVGhlIFNlbVZlciB2ZXJzaW9uIHJhbmdlIHRvIGNoZWNrIGFnYWluc3QuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2ZXJzaW9uIHNhdGlzZmllZCB0aGUgdmVyc2lvbiByYW5nZS5cbiAqL1xuZnVuY3Rpb24gc2F0aXNmaWVzVmVyc2lvblJhbmdlKHZlcnNpb24sIHZlcnNpb25SYW5nZSkge1xuICAgIHJldHVybiAoMCwgc2VtdmVyXzEuc2F0aXNmaWVzKSh2ZXJzaW9uLCB2ZXJzaW9uUmFuZ2UsIHtcbiAgICAgICAgaW5jbHVkZVByZXJlbGVhc2U6IHRydWUsXG4gICAgfSk7XG59XG5leHBvcnRzLnNhdGlzZmllc1ZlcnNpb25SYW5nZSA9IHNhdGlzZmllc1ZlcnNpb25SYW5nZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb25zLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInNhdGlzZmllc1ZlcnNpb25SYW5nZSIsImd0UmFuZ2UiLCJndFZlcnNpb24iLCJhc3NlcnRJc1NlbVZlclJhbmdlIiwiYXNzZXJ0SXNTZW1WZXJWZXJzaW9uIiwiaXNWYWxpZFNlbVZlclJhbmdlIiwiaXNWYWxpZFNlbVZlclZlcnNpb24iLCJWZXJzaW9uUmFuZ2VTdHJ1Y3QiLCJWZXJzaW9uU3RydWN0Iiwic2VtdmVyXzEiLCJyZXF1aXJlIiwic3VwZXJzdHJ1Y3RfMSIsImFzc2VydF8xIiwicmVmaW5lIiwic3RyaW5nIiwidmFsaWQiLCJ2YWxpZFJhbmdlIiwidmVyc2lvbiIsImlzIiwidmVyc2lvblJhbmdlIiwiYXNzZXJ0U3RydWN0IiwicmFuZ2UiLCJ2ZXJzaW9uMSIsInZlcnNpb24yIiwiZ3QiLCJndHIiLCJzYXRpc2ZpZXMiLCJpbmNsdWRlUHJlcmVsZWFzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/versions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/pify/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/pify/index.js ***!
  \*******************************************************************/
/***/ ((module) => {

eval("\nconst processFn = (fn, opts)=>function() {\n        const P = opts.promiseModule;\n        const args = new Array(arguments.length);\n        for(let i = 0; i < arguments.length; i++){\n            args[i] = arguments[i];\n        }\n        return new P((resolve, reject)=>{\n            if (opts.errorFirst) {\n                args.push(function(err, result) {\n                    if (opts.multiArgs) {\n                        const results = new Array(arguments.length - 1);\n                        for(let i = 1; i < arguments.length; i++){\n                            results[i - 1] = arguments[i];\n                        }\n                        if (err) {\n                            results.unshift(err);\n                            reject(results);\n                        } else {\n                            resolve(results);\n                        }\n                    } else if (err) {\n                        reject(err);\n                    } else {\n                        resolve(result);\n                    }\n                });\n            } else {\n                args.push(function(result) {\n                    if (opts.multiArgs) {\n                        const results = new Array(arguments.length - 1);\n                        for(let i = 0; i < arguments.length; i++){\n                            results[i] = arguments[i];\n                        }\n                        resolve(results);\n                    } else {\n                        resolve(result);\n                    }\n                });\n            }\n            fn.apply(this, args);\n        });\n    };\nmodule.exports = (obj, opts)=>{\n    opts = Object.assign({\n        exclude: [\n            /.+(Sync|Stream)$/\n        ],\n        errorFirst: true,\n        promiseModule: Promise\n    }, opts);\n    const filter = (key)=>{\n        const match = (pattern)=>typeof pattern === \"string\" ? key === pattern : pattern.test(key);\n        return opts.include ? opts.include.some(match) : !opts.exclude.some(match);\n    };\n    let ret;\n    if (typeof obj === \"function\") {\n        ret = function() {\n            if (opts.excludeMain) {\n                return obj.apply(this, arguments);\n            }\n            return processFn(obj, opts).apply(this, arguments);\n        };\n    } else {\n        ret = Object.create(Object.getPrototypeOf(obj));\n    }\n    for(const key in obj){\n        const x = obj[key];\n        ret[key] = typeof x === \"function\" && filter(key) ? processFn(x, opts) : x;\n    }\n    return ret;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3BpZnkvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxZQUFZLENBQUNDLElBQUlDLE9BQVM7UUFDL0IsTUFBTUMsSUFBSUQsS0FBS0UsYUFBYTtRQUM1QixNQUFNQyxPQUFPLElBQUlDLE1BQU1DLFVBQVVDLE1BQU07UUFFdkMsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLFVBQVVDLE1BQU0sRUFBRUMsSUFBSztZQUMxQ0osSUFBSSxDQUFDSSxFQUFFLEdBQUdGLFNBQVMsQ0FBQ0UsRUFBRTtRQUN2QjtRQUVBLE9BQU8sSUFBSU4sRUFBRSxDQUFDTyxTQUFTQztZQUN0QixJQUFJVCxLQUFLVSxVQUFVLEVBQUU7Z0JBQ3BCUCxLQUFLUSxJQUFJLENBQUMsU0FBVUMsR0FBRyxFQUFFQyxNQUFNO29CQUM5QixJQUFJYixLQUFLYyxTQUFTLEVBQUU7d0JBQ25CLE1BQU1DLFVBQVUsSUFBSVgsTUFBTUMsVUFBVUMsTUFBTSxHQUFHO3dCQUU3QyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsVUFBVUMsTUFBTSxFQUFFQyxJQUFLOzRCQUMxQ1EsT0FBTyxDQUFDUixJQUFJLEVBQUUsR0FBR0YsU0FBUyxDQUFDRSxFQUFFO3dCQUM5Qjt3QkFFQSxJQUFJSyxLQUFLOzRCQUNSRyxRQUFRQyxPQUFPLENBQUNKOzRCQUNoQkgsT0FBT007d0JBQ1IsT0FBTzs0QkFDTlAsUUFBUU87d0JBQ1Q7b0JBQ0QsT0FBTyxJQUFJSCxLQUFLO3dCQUNmSCxPQUFPRztvQkFDUixPQUFPO3dCQUNOSixRQUFRSztvQkFDVDtnQkFDRDtZQUNELE9BQU87Z0JBQ05WLEtBQUtRLElBQUksQ0FBQyxTQUFVRSxNQUFNO29CQUN6QixJQUFJYixLQUFLYyxTQUFTLEVBQUU7d0JBQ25CLE1BQU1DLFVBQVUsSUFBSVgsTUFBTUMsVUFBVUMsTUFBTSxHQUFHO3dCQUU3QyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsVUFBVUMsTUFBTSxFQUFFQyxJQUFLOzRCQUMxQ1EsT0FBTyxDQUFDUixFQUFFLEdBQUdGLFNBQVMsQ0FBQ0UsRUFBRTt3QkFDMUI7d0JBRUFDLFFBQVFPO29CQUNULE9BQU87d0JBQ05QLFFBQVFLO29CQUNUO2dCQUNEO1lBQ0Q7WUFFQWQsR0FBR2tCLEtBQUssQ0FBQyxJQUFJLEVBQUVkO1FBQ2hCO0lBQ0Q7QUFFQWUsT0FBT0MsT0FBTyxHQUFHLENBQUNDLEtBQUtwQjtJQUN0QkEsT0FBT3FCLE9BQU9DLE1BQU0sQ0FBQztRQUNwQkMsU0FBUztZQUFDO1NBQW1CO1FBQzdCYixZQUFZO1FBQ1pSLGVBQWVzQjtJQUNoQixHQUFHeEI7SUFFSCxNQUFNeUIsU0FBU0MsQ0FBQUE7UUFDZCxNQUFNQyxRQUFRQyxDQUFBQSxVQUFXLE9BQU9BLFlBQVksV0FBV0YsUUFBUUUsVUFBVUEsUUFBUUMsSUFBSSxDQUFDSDtRQUN0RixPQUFPMUIsS0FBSzhCLE9BQU8sR0FBRzlCLEtBQUs4QixPQUFPLENBQUNDLElBQUksQ0FBQ0osU0FBUyxDQUFDM0IsS0FBS3VCLE9BQU8sQ0FBQ1EsSUFBSSxDQUFDSjtJQUNyRTtJQUVBLElBQUlLO0lBQ0osSUFBSSxPQUFPWixRQUFRLFlBQVk7UUFDOUJZLE1BQU07WUFDTCxJQUFJaEMsS0FBS2lDLFdBQVcsRUFBRTtnQkFDckIsT0FBT2IsSUFBSUgsS0FBSyxDQUFDLElBQUksRUFBRVo7WUFDeEI7WUFFQSxPQUFPUCxVQUFVc0IsS0FBS3BCLE1BQU1pQixLQUFLLENBQUMsSUFBSSxFQUFFWjtRQUN6QztJQUNELE9BQU87UUFDTjJCLE1BQU1YLE9BQU9hLE1BQU0sQ0FBQ2IsT0FBT2MsY0FBYyxDQUFDZjtJQUMzQztJQUVBLElBQUssTUFBTU0sT0FBT04sSUFBSztRQUN0QixNQUFNZ0IsSUFBSWhCLEdBQUcsQ0FBQ00sSUFBSTtRQUNsQk0sR0FBRyxDQUFDTixJQUFJLEdBQUcsT0FBT1UsTUFBTSxjQUFjWCxPQUFPQyxPQUFPNUIsVUFBVXNDLEdBQUdwQyxRQUFRb0M7SUFDMUU7SUFFQSxPQUFPSjtBQUNSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RhYmxlLXJvdXRlci13ZWIvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3BpZnkvaW5kZXguanM/YzE1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHByb2Nlc3NGbiA9IChmbiwgb3B0cykgPT4gZnVuY3Rpb24gKCkge1xuXHRjb25zdCBQID0gb3B0cy5wcm9taXNlTW9kdWxlO1xuXHRjb25zdCBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0YXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcblx0fVxuXG5cdHJldHVybiBuZXcgUCgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0aWYgKG9wdHMuZXJyb3JGaXJzdCkge1xuXHRcdFx0YXJncy5wdXNoKGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuXHRcdFx0XHRpZiAob3B0cy5tdWx0aUFyZ3MpIHtcblx0XHRcdFx0XHRjb25zdCByZXN1bHRzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRzLnVuc2hpZnQoZXJyKTtcblx0XHRcdFx0XHRcdHJlamVjdChyZXN1bHRzKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHRzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoZXJyKSB7XG5cdFx0XHRcdFx0cmVqZWN0KGVycik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YXJncy5wdXNoKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0XHRcdFx0aWYgKG9wdHMubXVsdGlBcmdzKSB7XG5cdFx0XHRcdFx0Y29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0cmVzdWx0c1tpXSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdHMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc29sdmUocmVzdWx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Zm4uYXBwbHkodGhpcywgYXJncyk7XG5cdH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSAob2JqLCBvcHRzKSA9PiB7XG5cdG9wdHMgPSBPYmplY3QuYXNzaWduKHtcblx0XHRleGNsdWRlOiBbLy4rKFN5bmN8U3RyZWFtKSQvXSxcblx0XHRlcnJvckZpcnN0OiB0cnVlLFxuXHRcdHByb21pc2VNb2R1bGU6IFByb21pc2Vcblx0fSwgb3B0cyk7XG5cblx0Y29uc3QgZmlsdGVyID0ga2V5ID0+IHtcblx0XHRjb25zdCBtYXRjaCA9IHBhdHRlcm4gPT4gdHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnID8ga2V5ID09PSBwYXR0ZXJuIDogcGF0dGVybi50ZXN0KGtleSk7XG5cdFx0cmV0dXJuIG9wdHMuaW5jbHVkZSA/IG9wdHMuaW5jbHVkZS5zb21lKG1hdGNoKSA6ICFvcHRzLmV4Y2x1ZGUuc29tZShtYXRjaCk7XG5cdH07XG5cblx0bGV0IHJldDtcblx0aWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAob3B0cy5leGNsdWRlTWFpbikge1xuXHRcdFx0XHRyZXR1cm4gb2JqLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwcm9jZXNzRm4ob2JqLCBvcHRzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0cmV0ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSk7XG5cdH1cblxuXHRmb3IgKGNvbnN0IGtleSBpbiBvYmopIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBndWFyZC1mb3ItaW5cblx0XHRjb25zdCB4ID0gb2JqW2tleV07XG5cdFx0cmV0W2tleV0gPSB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyAmJiBmaWx0ZXIoa2V5KSA/IHByb2Nlc3NGbih4LCBvcHRzKSA6IHg7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcbiJdLCJuYW1lcyI6WyJwcm9jZXNzRm4iLCJmbiIsIm9wdHMiLCJQIiwicHJvbWlzZU1vZHVsZSIsImFyZ3MiLCJBcnJheSIsImFyZ3VtZW50cyIsImxlbmd0aCIsImkiLCJyZXNvbHZlIiwicmVqZWN0IiwiZXJyb3JGaXJzdCIsInB1c2giLCJlcnIiLCJyZXN1bHQiLCJtdWx0aUFyZ3MiLCJyZXN1bHRzIiwidW5zaGlmdCIsImFwcGx5IiwibW9kdWxlIiwiZXhwb3J0cyIsIm9iaiIsIk9iamVjdCIsImFzc2lnbiIsImV4Y2x1ZGUiLCJQcm9taXNlIiwiZmlsdGVyIiwia2V5IiwibWF0Y2giLCJwYXR0ZXJuIiwidGVzdCIsImluY2x1ZGUiLCJzb21lIiwicmV0IiwiZXhjbHVkZU1haW4iLCJjcmVhdGUiLCJnZXRQcm90b3R5cGVPZiIsIngiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/pify/index.js\n");

/***/ })

};
;