"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/to-buffer";
exports.ids = ["vendor-chunks/to-buffer"];
exports.modules = {

/***/ "(ssr)/./node_modules/to-buffer/index.js":
/*!*****************************************!*\
  !*** ./node_modules/to-buffer/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"(ssr)/./node_modules/safe-buffer/index.js\").Buffer);\nvar isArray = __webpack_require__(/*! isarray */ \"(ssr)/./node_modules/isarray/index.js\");\nvar typedArrayBuffer = __webpack_require__(/*! typed-array-buffer */ \"(ssr)/./node_modules/typed-array-buffer/index.js\");\nvar isView = ArrayBuffer.isView || function isView(obj) {\n    try {\n        typedArrayBuffer(obj);\n        return true;\n    } catch (e) {\n        return false;\n    }\n};\nvar useUint8Array = typeof Uint8Array !== \"undefined\";\nvar useArrayBuffer = typeof ArrayBuffer !== \"undefined\" && typeof Uint8Array !== \"undefined\";\nvar useFromArrayBuffer = useArrayBuffer && (Buffer.prototype instanceof Uint8Array || Buffer.TYPED_ARRAY_SUPPORT);\nmodule.exports = function toBuffer(data, encoding) {\n    /*\n\t * No need to do anything for exact instance\n\t * This is only valid when safe-buffer.Buffer === buffer.Buffer, i.e. when Buffer.from/Buffer.alloc existed\n\t */ if (data instanceof Buffer) {\n        return data;\n    }\n    if (typeof data === \"string\") {\n        return Buffer.from(data, encoding);\n    }\n    /*\n\t * Wrap any TypedArray instances and DataViews\n\t * Makes sense only on engines with full TypedArray support -- let Buffer detect that\n\t */ if (useArrayBuffer && isView(data)) {\n        // Bug in Node.js <6.3.1, which treats this as out-of-bounds\n        if (data.byteLength === 0) {\n            return Buffer.alloc(0);\n        }\n        // When Buffer is based on Uint8Array, we can just construct it from ArrayBuffer\n        if (useFromArrayBuffer) {\n            var res = Buffer.from(data.buffer, data.byteOffset, data.byteLength);\n            /*\n\t\t\t * Recheck result size, as offset/length doesn't work on Node.js <5.10\n\t\t\t * We just go to Uint8Array case if this fails\n\t\t\t */ if (res.byteLength === data.byteLength) {\n                return res;\n            }\n        }\n        // Convert to Uint8Array bytes and then to Buffer\n        var uint8 = data instanceof Uint8Array ? data : new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n        var result = Buffer.from(uint8);\n        /*\n\t\t * Let's recheck that conversion succeeded\n\t\t * We have .length but not .byteLength when useFromArrayBuffer is false\n\t\t */ if (result.length === data.byteLength) {\n            return result;\n        }\n    }\n    /*\n\t * Uint8Array in engines where Buffer.from might not work with ArrayBuffer, just copy over\n\t * Doesn't make sense with other TypedArray instances\n\t */ if (useUint8Array && data instanceof Uint8Array) {\n        return Buffer.from(data);\n    }\n    var isArr = isArray(data);\n    if (isArr) {\n        for(var i = 0; i < data.length; i += 1){\n            var x = data[i];\n            if (typeof x !== \"number\" || x < 0 || x > 255 || ~~x !== x // NaN and integer check\n            ) {\n                throw new RangeError(\"Array items must be numbers in the range 0-255.\");\n            }\n        }\n    }\n    /*\n\t * Old Buffer polyfill on an engine that doesn't have TypedArray support\n\t * Also, this is from a different Buffer polyfill implementation then we have, as instanceof check failed\n\t * Convert to our current Buffer implementation\n\t */ if (isArr || Buffer.isBuffer(data) && data.constructor && typeof data.constructor.isBuffer === \"function\" && data.constructor.isBuffer(data)) {\n        return Buffer.from(data);\n    }\n    throw new TypeError('The \"data\" argument must be a string, an Array, a Buffer, a Uint8Array, or a DataView.');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdG8tYnVmZmVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsU0FBU0MsNEZBQTZCO0FBQzFDLElBQUlDLFVBQVVELG1CQUFPQSxDQUFDO0FBQ3RCLElBQUlFLG1CQUFtQkYsbUJBQU9BLENBQUM7QUFFL0IsSUFBSUcsU0FBU0MsWUFBWUQsTUFBTSxJQUFJLFNBQVNBLE9BQU9FLEdBQUc7SUFDckQsSUFBSTtRQUNISCxpQkFBaUJHO1FBQ2pCLE9BQU87SUFDUixFQUFFLE9BQU9DLEdBQUc7UUFDWCxPQUFPO0lBQ1I7QUFDRDtBQUVBLElBQUlDLGdCQUFnQixPQUFPQyxlQUFlO0FBQzFDLElBQUlDLGlCQUFpQixPQUFPTCxnQkFBZ0IsZUFDeEMsT0FBT0ksZUFBZTtBQUMxQixJQUFJRSxxQkFBcUJELGtCQUFtQlYsQ0FBQUEsT0FBT1ksU0FBUyxZQUFZSCxjQUFjVCxPQUFPYSxtQkFBbUI7QUFFaEhDLE9BQU9DLE9BQU8sR0FBRyxTQUFTQyxTQUFTQyxJQUFJLEVBQUVDLFFBQVE7SUFDaEQ7OztFQUdDLEdBQ0QsSUFBSUQsZ0JBQWdCakIsUUFBUTtRQUMzQixPQUFPaUI7SUFDUjtJQUVBLElBQUksT0FBT0EsU0FBUyxVQUFVO1FBQzdCLE9BQU9qQixPQUFPbUIsSUFBSSxDQUFDRixNQUFNQztJQUMxQjtJQUVBOzs7RUFHQyxHQUNELElBQUlSLGtCQUFrQk4sT0FBT2EsT0FBTztRQUNuQyw0REFBNEQ7UUFDNUQsSUFBSUEsS0FBS0csVUFBVSxLQUFLLEdBQUc7WUFDMUIsT0FBT3BCLE9BQU9xQixLQUFLLENBQUM7UUFDckI7UUFFQSxnRkFBZ0Y7UUFDaEYsSUFBSVYsb0JBQW9CO1lBQ3ZCLElBQUlXLE1BQU10QixPQUFPbUIsSUFBSSxDQUFDRixLQUFLTSxNQUFNLEVBQUVOLEtBQUtPLFVBQVUsRUFBRVAsS0FBS0csVUFBVTtZQUNuRTs7O0lBR0MsR0FDRCxJQUFJRSxJQUFJRixVQUFVLEtBQUtILEtBQUtHLFVBQVUsRUFBRTtnQkFDdkMsT0FBT0U7WUFDUjtRQUNEO1FBRUEsaURBQWlEO1FBQ2pELElBQUlHLFFBQVFSLGdCQUFnQlIsYUFBYVEsT0FBTyxJQUFJUixXQUFXUSxLQUFLTSxNQUFNLEVBQUVOLEtBQUtPLFVBQVUsRUFBRVAsS0FBS0csVUFBVTtRQUM1RyxJQUFJTSxTQUFTMUIsT0FBT21CLElBQUksQ0FBQ007UUFFekI7OztHQUdDLEdBQ0QsSUFBSUMsT0FBT0MsTUFBTSxLQUFLVixLQUFLRyxVQUFVLEVBQUU7WUFDdEMsT0FBT007UUFDUjtJQUNEO0lBRUE7OztFQUdDLEdBQ0QsSUFBSWxCLGlCQUFpQlMsZ0JBQWdCUixZQUFZO1FBQ2hELE9BQU9ULE9BQU9tQixJQUFJLENBQUNGO0lBQ3BCO0lBRUEsSUFBSVcsUUFBUTFCLFFBQVFlO0lBQ3BCLElBQUlXLE9BQU87UUFDVixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSVosS0FBS1UsTUFBTSxFQUFFRSxLQUFLLEVBQUc7WUFDeEMsSUFBSUMsSUFBSWIsSUFBSSxDQUFDWSxFQUFFO1lBQ2YsSUFDQyxPQUFPQyxNQUFNLFlBQ1ZBLElBQUksS0FDSkEsSUFBSSxPQUNKLENBQUMsQ0FBQ0EsTUFBTUEsRUFBRSx3QkFBd0I7Y0FDcEM7Z0JBQ0QsTUFBTSxJQUFJQyxXQUFXO1lBQ3RCO1FBQ0Q7SUFDRDtJQUVBOzs7O0VBSUMsR0FDRCxJQUNDSCxTQUNDNUIsT0FBT2dDLFFBQVEsQ0FBQ2YsU0FDWkEsS0FBS2dCLFdBQVcsSUFDaEIsT0FBT2hCLEtBQUtnQixXQUFXLENBQUNELFFBQVEsS0FBSyxjQUNyQ2YsS0FBS2dCLFdBQVcsQ0FBQ0QsUUFBUSxDQUFDZixPQUU5QjtRQUNELE9BQU9qQixPQUFPbUIsSUFBSSxDQUFDRjtJQUNwQjtJQUVBLE1BQU0sSUFBSWlCLFVBQVU7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGFibGUtcm91dGVyLXdlYi8uL25vZGVfbW9kdWxlcy90by1idWZmZXIvaW5kZXguanM/NTVlMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xudmFyIHR5cGVkQXJyYXlCdWZmZXIgPSByZXF1aXJlKCd0eXBlZC1hcnJheS1idWZmZXInKTtcblxudmFyIGlzVmlldyA9IEFycmF5QnVmZmVyLmlzVmlldyB8fCBmdW5jdGlvbiBpc1ZpZXcob2JqKSB7XG5cdHRyeSB7XG5cdFx0dHlwZWRBcnJheUJ1ZmZlcihvYmopO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xuXG52YXIgdXNlVWludDhBcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJztcbnZhciB1c2VBcnJheUJ1ZmZlciA9IHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCdcblx0JiYgdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnO1xudmFyIHVzZUZyb21BcnJheUJ1ZmZlciA9IHVzZUFycmF5QnVmZmVyICYmIChCdWZmZXIucHJvdG90eXBlIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdG9CdWZmZXIoZGF0YSwgZW5jb2RpbmcpIHtcblx0Lypcblx0ICogTm8gbmVlZCB0byBkbyBhbnl0aGluZyBmb3IgZXhhY3QgaW5zdGFuY2Vcblx0ICogVGhpcyBpcyBvbmx5IHZhbGlkIHdoZW4gc2FmZS1idWZmZXIuQnVmZmVyID09PSBidWZmZXIuQnVmZmVyLCBpLmUuIHdoZW4gQnVmZmVyLmZyb20vQnVmZmVyLmFsbG9jIGV4aXN0ZWRcblx0ICovXG5cdGlmIChkYXRhIGluc3RhbmNlb2YgQnVmZmVyKSB7XG5cdFx0cmV0dXJuIGRhdGE7XG5cdH1cblxuXHRpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuIEJ1ZmZlci5mcm9tKGRhdGEsIGVuY29kaW5nKTtcblx0fVxuXG5cdC8qXG5cdCAqIFdyYXAgYW55IFR5cGVkQXJyYXkgaW5zdGFuY2VzIGFuZCBEYXRhVmlld3Ncblx0ICogTWFrZXMgc2Vuc2Ugb25seSBvbiBlbmdpbmVzIHdpdGggZnVsbCBUeXBlZEFycmF5IHN1cHBvcnQgLS0gbGV0IEJ1ZmZlciBkZXRlY3QgdGhhdFxuXHQgKi9cblx0aWYgKHVzZUFycmF5QnVmZmVyICYmIGlzVmlldyhkYXRhKSkge1xuXHRcdC8vIEJ1ZyBpbiBOb2RlLmpzIDw2LjMuMSwgd2hpY2ggdHJlYXRzIHRoaXMgYXMgb3V0LW9mLWJvdW5kc1xuXHRcdGlmIChkYXRhLmJ5dGVMZW5ndGggPT09IDApIHtcblx0XHRcdHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiBCdWZmZXIgaXMgYmFzZWQgb24gVWludDhBcnJheSwgd2UgY2FuIGp1c3QgY29uc3RydWN0IGl0IGZyb20gQXJyYXlCdWZmZXJcblx0XHRpZiAodXNlRnJvbUFycmF5QnVmZmVyKSB7XG5cdFx0XHR2YXIgcmVzID0gQnVmZmVyLmZyb20oZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5ieXRlTGVuZ3RoKTtcblx0XHRcdC8qXG5cdFx0XHQgKiBSZWNoZWNrIHJlc3VsdCBzaXplLCBhcyBvZmZzZXQvbGVuZ3RoIGRvZXNuJ3Qgd29yayBvbiBOb2RlLmpzIDw1LjEwXG5cdFx0XHQgKiBXZSBqdXN0IGdvIHRvIFVpbnQ4QXJyYXkgY2FzZSBpZiB0aGlzIGZhaWxzXG5cdFx0XHQgKi9cblx0XHRcdGlmIChyZXMuYnl0ZUxlbmd0aCA9PT0gZGF0YS5ieXRlTGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCB0byBVaW50OEFycmF5IGJ5dGVzIGFuZCB0aGVuIHRvIEJ1ZmZlclxuXHRcdHZhciB1aW50OCA9IGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gZGF0YSA6IG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCk7XG5cdFx0dmFyIHJlc3VsdCA9IEJ1ZmZlci5mcm9tKHVpbnQ4KTtcblxuXHRcdC8qXG5cdFx0ICogTGV0J3MgcmVjaGVjayB0aGF0IGNvbnZlcnNpb24gc3VjY2VlZGVkXG5cdFx0ICogV2UgaGF2ZSAubGVuZ3RoIGJ1dCBub3QgLmJ5dGVMZW5ndGggd2hlbiB1c2VGcm9tQXJyYXlCdWZmZXIgaXMgZmFsc2Vcblx0XHQgKi9cblx0XHRpZiAocmVzdWx0Lmxlbmd0aCA9PT0gZGF0YS5ieXRlTGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdC8qXG5cdCAqIFVpbnQ4QXJyYXkgaW4gZW5naW5lcyB3aGVyZSBCdWZmZXIuZnJvbSBtaWdodCBub3Qgd29yayB3aXRoIEFycmF5QnVmZmVyLCBqdXN0IGNvcHkgb3ZlclxuXHQgKiBEb2Vzbid0IG1ha2Ugc2Vuc2Ugd2l0aCBvdGhlciBUeXBlZEFycmF5IGluc3RhbmNlc1xuXHQgKi9cblx0aWYgKHVzZVVpbnQ4QXJyYXkgJiYgZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcblx0XHRyZXR1cm4gQnVmZmVyLmZyb20oZGF0YSk7XG5cdH1cblxuXHR2YXIgaXNBcnIgPSBpc0FycmF5KGRhdGEpO1xuXHRpZiAoaXNBcnIpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdHZhciB4ID0gZGF0YVtpXTtcblx0XHRcdGlmIChcblx0XHRcdFx0dHlwZW9mIHggIT09ICdudW1iZXInXG5cdFx0XHRcdHx8IHggPCAwXG5cdFx0XHRcdHx8IHggPiAyNTVcblx0XHRcdFx0fHwgfn54ICE9PSB4IC8vIE5hTiBhbmQgaW50ZWdlciBjaGVja1xuXHRcdFx0KSB7XG5cdFx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKCdBcnJheSBpdGVtcyBtdXN0IGJlIG51bWJlcnMgaW4gdGhlIHJhbmdlIDAtMjU1LicpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qXG5cdCAqIE9sZCBCdWZmZXIgcG9seWZpbGwgb24gYW4gZW5naW5lIHRoYXQgZG9lc24ndCBoYXZlIFR5cGVkQXJyYXkgc3VwcG9ydFxuXHQgKiBBbHNvLCB0aGlzIGlzIGZyb20gYSBkaWZmZXJlbnQgQnVmZmVyIHBvbHlmaWxsIGltcGxlbWVudGF0aW9uIHRoZW4gd2UgaGF2ZSwgYXMgaW5zdGFuY2VvZiBjaGVjayBmYWlsZWRcblx0ICogQ29udmVydCB0byBvdXIgY3VycmVudCBCdWZmZXIgaW1wbGVtZW50YXRpb25cblx0ICovXG5cdGlmIChcblx0XHRpc0FyciB8fCAoXG5cdFx0XHRCdWZmZXIuaXNCdWZmZXIoZGF0YSlcblx0XHRcdFx0JiYgZGF0YS5jb25zdHJ1Y3RvclxuXHRcdFx0XHQmJiB0eXBlb2YgZGF0YS5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdFx0XHQmJiBkYXRhLmNvbnN0cnVjdG9yLmlzQnVmZmVyKGRhdGEpXG5cdFx0KVxuXHQpIHtcblx0XHRyZXR1cm4gQnVmZmVyLmZyb20oZGF0YSk7XG5cdH1cblxuXHR0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJkYXRhXCIgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgYW4gQXJyYXksIGEgQnVmZmVyLCBhIFVpbnQ4QXJyYXksIG9yIGEgRGF0YVZpZXcuJyk7XG59O1xuIl0sIm5hbWVzIjpbIkJ1ZmZlciIsInJlcXVpcmUiLCJpc0FycmF5IiwidHlwZWRBcnJheUJ1ZmZlciIsImlzVmlldyIsIkFycmF5QnVmZmVyIiwib2JqIiwiZSIsInVzZVVpbnQ4QXJyYXkiLCJVaW50OEFycmF5IiwidXNlQXJyYXlCdWZmZXIiLCJ1c2VGcm9tQXJyYXlCdWZmZXIiLCJwcm90b3R5cGUiLCJUWVBFRF9BUlJBWV9TVVBQT1JUIiwibW9kdWxlIiwiZXhwb3J0cyIsInRvQnVmZmVyIiwiZGF0YSIsImVuY29kaW5nIiwiZnJvbSIsImJ5dGVMZW5ndGgiLCJhbGxvYyIsInJlcyIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJ1aW50OCIsInJlc3VsdCIsImxlbmd0aCIsImlzQXJyIiwiaSIsIngiLCJSYW5nZUVycm9yIiwiaXNCdWZmZXIiLCJjb25zdHJ1Y3RvciIsIlR5cGVFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/to-buffer/index.js\n");

/***/ })

};
;