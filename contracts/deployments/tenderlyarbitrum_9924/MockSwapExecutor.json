{"metadata":"{\"defaultCompiler\":{\"version\":\"0.8.22\"},\"sources\":{\"contracts/MockSwapExecutor.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.22;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"./interfaces/ISwapExecutor.sol\\\";\\n\\n/**\\n * @title MockSwapExecutor\\n * @notice Mock swap executor for testing on Tenderly forks\\n * @dev Simulates swaps with a configurable exchange rate\\n */\\ncontract MockSwapExecutor is ISwapExecutor {\\n    using SafeERC20 for IERC20;\\n    \\n    // Events\\n    event SwapExecuted(\\n        address indexed tokenIn,\\n        address indexed tokenOut,\\n        uint256 amountIn,\\n        uint256 amountOut,\\n        address indexed executor\\n    );\\n    \\n    // Mock exchange rates (scaled by 1e18)\\n    mapping(address => mapping(address => uint256)) public exchangeRates;\\n    \\n    // Default to 1:1 for stablecoins\\n    uint256 public constant DEFAULT_RATE = 1e18;\\n    \\n    constructor() {\\n        // Can set up default rates here if needed\\n    }\\n    \\n    /**\\n     * @notice Execute a swap with mock rates\\n     * @dev For testing, this just transfers at a fixed rate\\n     */\\n    function executeSwap(SwapParams calldata params) external override returns (uint256) {\\n        require(params.tokenIn != address(0), \\\"Invalid tokenIn\\\");\\n        require(params.tokenOut != address(0), \\\"Invalid tokenOut\\\");\\n        require(params.amountIn > 0, \\\"Invalid amount\\\");\\n        \\n        // Transfer tokens in\\n        IERC20(params.tokenIn).safeTransferFrom(msg.sender, address(this), params.amountIn);\\n        \\n        // Calculate output amount using mock rate\\n        uint256 rate = exchangeRates[params.tokenIn][params.tokenOut];\\n        if (rate == 0) {\\n            rate = DEFAULT_RATE; // Default 1:1 for stablecoins\\n        }\\n        \\n        // Get decimals for proper conversion\\n        uint8 decimalsIn = 6; // Most stablecoins\\n        uint8 decimalsOut = 6;\\n        \\n        // For simplicity, assume 6 decimals for USDC/USDT/PYUSD and 18 for DAI/USDe\\n        // In production, you'd query the actual decimals\\n        \\n        // Calculate output with decimal adjustment\\n        uint256 amountOut;\\n        if (decimalsIn == decimalsOut) {\\n            amountOut = (params.amountIn * rate) / 1e18;\\n        } else if (decimalsIn > decimalsOut) {\\n            uint256 factor = 10 ** (decimalsIn - decimalsOut);\\n            amountOut = (params.amountIn * rate) / (1e18 * factor);\\n        } else {\\n            uint256 factor = 10 ** (decimalsOut - decimalsIn);\\n            amountOut = (params.amountIn * rate * factor) / 1e18;\\n        }\\n        \\n        require(amountOut >= params.minAmountOut, \\\"Slippage exceeded\\\");\\n        \\n        // For testing on forks, we might need to deal or mint tokens\\n        // In a real fork, you'd need to have the output tokens or use deal()\\n        \\n        // Transfer tokens out\\n        IERC20(params.tokenOut).safeTransfer(msg.sender, amountOut);\\n        \\n        emit SwapExecuted(\\n            params.tokenIn,\\n            params.tokenOut,\\n            params.amountIn,\\n            amountOut,\\n            msg.sender\\n        );\\n        \\n        return amountOut;\\n    }\\n    \\n    /**\\n     * @notice Set mock exchange rate\\n     * @param tokenIn Input token\\n     * @param tokenOut Output token\\n     * @param rate Exchange rate (scaled by 1e18)\\n     */\\n    function setExchangeRate(address tokenIn, address tokenOut, uint256 rate) external {\\n        exchangeRates[tokenIn][tokenOut] = rate;\\n    }\\n    \\n    /**\\n     * @notice Execute multiple swaps in batch\\n     * @dev For testing, executes swaps sequentially\\n     */\\n    function executeBatchSwaps(SwapParams[] calldata swaps) external override returns (uint256[] memory amountsOut) {\\n        amountsOut = new uint256[](swaps.length);\\n        for (uint256 i = 0; i < swaps.length; i++) {\\n            amountsOut[i] = this.executeSwap(swaps[i]);\\n        }\\n        return amountsOut;\\n    }\\n    \\n    /**\\n     * @notice Get expected output amount for a swap\\n     * @dev Returns mock calculation without actually swapping\\n     */\\n    function getAmountOut(\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 amountIn,\\n        address pool\\n    ) external view override returns (uint256) {\\n        uint256 rate = exchangeRates[tokenIn][tokenOut];\\n        if (rate == 0) {\\n            rate = DEFAULT_RATE;\\n        }\\n        \\n        // Simple calculation for preview\\n        return (amountIn * rate) / 1e18;\\n    }\\n    \\n    /**\\n     * @notice Emergency function to deal tokens for testing\\n     * @dev Only for Tenderly testing - simulates having liquidity\\n     */\\n    function dealTokens(address token, uint256 amount) external {\\n        // This would need to be implemented with Tenderly's cheat codes\\n        // or by having a faucet/whale account transfer tokens\\n    }\\n}\",\"versionPragma\":\"^0.8.22\"},\"contracts/interfaces/ISwapExecutor.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.22;\\n\\ninterface ISwapExecutor {\\n    struct SwapParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 amountIn;\\n        uint256 minAmountOut;\\n        address pool;\\n        bytes swapData;\\n    }\\n\\n    function executeSwap(SwapParams calldata params) external returns (uint256 amountOut);\\n\\n    function executeBatchSwaps(SwapParams[] calldata swaps) external returns (uint256[] memory amountsOut);\\n\\n    function getAmountOut(\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 amountIn,\\n        address pool\\n    ) external view returns (uint256);\\n}\",\"versionPragma\":\"^0.8.22\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity >=0.4.16;\\n\\n/**\\n * @dev Interface of the ERC-20 standard as defined in the ERC.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\",\"versionPragma\":\">=0.4.16\"},\"@openzeppelin/contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\\n\\npragma solidity >=0.4.16;\\n\\nimport {IERC20} from \\\"../token/ERC20/IERC20.sol\\\";\\n\",\"versionPragma\":\">=0.4.16\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity >=0.4.16;\\n\\n/**\\n * @dev Interface of the ERC-165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"versionPragma\":\">=0.4.16\"},\"@openzeppelin/contracts/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\\n\\npragma solidity >=0.4.16;\\n\\nimport {IERC165} from \\\"../utils/introspection/IERC165.sol\\\";\\n\",\"versionPragma\":\">=0.4.16\"},\"@openzeppelin/contracts/interfaces/IERC1363.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\\n\\npragma solidity >=0.6.2;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @title IERC1363\\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\\n *\\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\\n */\\ninterface IERC1363 is IERC20, IERC165 {\\n    /*\\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\\n     * 0xb0202a11 ===\\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\\n     */\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferAndCall(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @param data Additional data with no specified format, sent in call to `to`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param from The address which you want to send tokens from.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param from The address which you want to send tokens from.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @param data Additional data with no specified format, sent in call to `to`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function approveAndCall(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     * @param data Additional data with no specified format, sent in call to `spender`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\\n}\\n\",\"versionPragma\":\">=0.6.2\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\nimport {IERC1363} from \\\"../../../interfaces/IERC1363.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    /**\\n     * @dev An operation with an ERC-20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\\n     */\\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\\n     */\\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     *\\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \\\"client\\\"\\n     * smart contract uses ERC-7674 to set temporary allowances, then the \\\"client\\\" smart contract should avoid using\\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\\n     * value, non-reverting calls are assumed to be successful.\\n     *\\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \\\"client\\\"\\n     * smart contract uses ERC-7674 to set temporary allowances, then the \\\"client\\\" smart contract should avoid using\\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     *\\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\\n     * only sets the \\\"standard\\\" allowance. Any temporary allowance will remain active, in addition to the value being\\n     * set here.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\\n        if (to.code.length == 0) {\\n            safeTransfer(token, to, value);\\n        } else if (!token.transferAndCall(to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function transferFromAndCallRelaxed(\\n        IERC1363 token,\\n        address from,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal {\\n        if (to.code.length == 0) {\\n            safeTransferFrom(token, from, to, value);\\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\\n     * once without retrying, and relies on the returned value to be true.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\\n        if (to.code.length == 0) {\\n            forceApprove(token, to, value);\\n        } else if (!token.approveAndCall(to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly (\\\"memory-safe\\\") {\\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\\n            // bubble errors\\n            if iszero(success) {\\n                let ptr := mload(0x40)\\n                returndatacopy(ptr, 0, returndatasize())\\n                revert(ptr, returndatasize())\\n            }\\n            returnSize := returndatasize()\\n            returnValue := mload(0)\\n        }\\n\\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly (\\\"memory-safe\\\") {\\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0)\\n        }\\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\\n    }\\n}\\n\",\"versionPragma\":\"^0.8.20\"}}}","address":"0xD84F50DcdeC8e3E84c970d708ccbE5a3c5D68a79","bytecode":"0x6080806040523461001657610828908161001c8239f35b600080fdfe6040608081526004908136101561001557600080fd5b600091823560e01c9081632132e2c014610474578163503fa44f1461042c578163703564311461040c578163782aaeea146103c357816388030a981461033b5781639d49776114610095575063a3e860fe1461007057600080fd5b3461009157816003193601126100915760209051670de0b6b3a76400008152f35b5080fd5b8383346100915760209260031984813601126103375781359367ffffffffffffffff918286116100915760c0868501918736030112610091576001600160a01b0393846100e183610776565b16156103025760249081880194866100f887610776565b16156102ce57604492838a013595861561029c578861011687610776565b8b516323b872dd60e01b8f8201523385820152308882015260648082018b90528152911660a0820185811183821017610289578c52610155919061078a565b8861015f87610776565b168152808c52898120896101728a610776565b1682528c5289812054801561027a575b670de0b6b3a76400006101976064928a61074d565b049b01358b1061024557886101ab89610776565b8b5163a9059cbb60e01b8f82015233858201528781018e905296875216936080860193841186851017610235575050507fee4825a7988c5519a874be79f2a84d13d02cfe5f74cad97cda2d5b55d2b13bfa93610211899461021c9461021694875261078a565b610776565b94610776565b948151938452878985015280339616941692a451908152f35b634e487b7160e01b825260419052fd5b50827014db1a5c1c1859d948195e18d959591959607a1b8560116064948f8e519562461bcd60e51b8752860152840152820152fd5b50670de0b6b3a7640000610182565b5050634e487b7160e01b82525060418452fd5b50826d125b9d985b1a5908185b5bdd5b9d60921b85600e6064948f8e519562461bcd60e51b8752860152840152820152fd5b5060106064928a89519362461bcd60e51b85528401528201526f125b9d985b1a59081d1bdad95b93dd5d60821b6044820152fd5b855162461bcd60e51b8152908101889052600f60248201526e24b73b30b634b2103a37b5b2b724b760891b6044820152606490fd5b8380fd5b505034610091576080366003190112610091576103566106b8565b61035e6106d3565b906001600160a01b0390606435828116036103bf579181602095928594168352828652838320911682528452205480156103b0575b6103a8670de0b6b3a76400009160443561074d565b049051908152f35b50670de0b6b3a7640000610393565b8480fd5b505034610091576060366003190112610091576103de6106b8565b6103e66106d3565b6001600160a01b0391821684526020848152838520929091168452528120604435905580f35b50503461009157366003190112610429576104256106b8565b5080f35b80fd5b5050346100915780600319360112610091578060209261044a6106b8565b6104526106d3565b6001600160a01b03918216835282865283832091168252845220549051908152f35b90508234610429576020806003193601126100915767ffffffffffffffff91833583811161009157366023820112156100915780850135948486116106b45760249160059136848960051b840101116103bf576104d688939795969998610735565b946104e3895196876106fd565b8386526104ef84610735565b868b0198601f1992918301368b373685900360e2190190895b87811061054f578d8d8d8d8d83519485948186019282875251809352850193925b82811061053857505050500390f35b835185528695509381019392810192600101610529565b80829e9b9a9c9d9e1b89818901013584811215610695578f51639d49776160e01b81528881018e9052919089016001600160a01b03806105908e84016106e9565b168d850152604490806105a48385016106e9565b1682860152606480840135908601526084808401359086015260a4906105cb8285016106e9565b169085015260c49182810135604219823603018112156106b05701908d8201359101918882116106ac5781360383136106ac578f928f9190868c601f829660c084968501528060e48501528061010495868601378685828601015201168101030191305af19182156106a0578c9261066d575b508d5183101561065b578d018c0152999c9b9a9899600101610508565b634e487b7160e01b8c52603288528a8cfd5b9091508c81813d8311610699575b61068581836106fd565b810103126106955751903861063e565b8b80fd5b503d61067b565b50508e513d8c823e3d90fd5b8e80fd5b8f80fd5b8280fd5b600435906001600160a01b03821682036106ce57565b600080fd5b602435906001600160a01b03821682036106ce57565b35906001600160a01b03821682036106ce57565b90601f8019910116810190811067ffffffffffffffff82111761071f57604052565b634e487b7160e01b600052604160045260246000fd5b67ffffffffffffffff811161071f5760051b60200190565b8181029291811591840414171561076057565b634e487b7160e01b600052601160045260246000fd5b356001600160a01b03811681036106ce5790565b906000602091828151910182855af1156107e6576000513d6107dd57506001600160a01b0381163b155b6107bb5750565b604051635274afe760e01b81526001600160a01b039091166004820152602490fd5b600114156107b4565b6040513d6000823e3d90fdfea26469706673582212206713aabc8e39ce5b700d93dea07c5ff5765c68b4b07c01b41a7a04b7d768b3de64736f6c63430008160033","deployedBytecode":"0x6040608081526004908136101561001557600080fd5b600091823560e01c9081632132e2c014610474578163503fa44f1461042c578163703564311461040c578163782aaeea146103c357816388030a981461033b5781639d49776114610095575063a3e860fe1461007057600080fd5b3461009157816003193601126100915760209051670de0b6b3a76400008152f35b5080fd5b8383346100915760209260031984813601126103375781359367ffffffffffffffff918286116100915760c0868501918736030112610091576001600160a01b0393846100e183610776565b16156103025760249081880194866100f887610776565b16156102ce57604492838a013595861561029c578861011687610776565b8b516323b872dd60e01b8f8201523385820152308882015260648082018b90528152911660a0820185811183821017610289578c52610155919061078a565b8861015f87610776565b168152808c52898120896101728a610776565b1682528c5289812054801561027a575b670de0b6b3a76400006101976064928a61074d565b049b01358b1061024557886101ab89610776565b8b5163a9059cbb60e01b8f82015233858201528781018e905296875216936080860193841186851017610235575050507fee4825a7988c5519a874be79f2a84d13d02cfe5f74cad97cda2d5b55d2b13bfa93610211899461021c9461021694875261078a565b610776565b94610776565b948151938452878985015280339616941692a451908152f35b634e487b7160e01b825260419052fd5b50827014db1a5c1c1859d948195e18d959591959607a1b8560116064948f8e519562461bcd60e51b8752860152840152820152fd5b50670de0b6b3a7640000610182565b5050634e487b7160e01b82525060418452fd5b50826d125b9d985b1a5908185b5bdd5b9d60921b85600e6064948f8e519562461bcd60e51b8752860152840152820152fd5b5060106064928a89519362461bcd60e51b85528401528201526f125b9d985b1a59081d1bdad95b93dd5d60821b6044820152fd5b855162461bcd60e51b8152908101889052600f60248201526e24b73b30b634b2103a37b5b2b724b760891b6044820152606490fd5b8380fd5b505034610091576080366003190112610091576103566106b8565b61035e6106d3565b906001600160a01b0390606435828116036103bf579181602095928594168352828652838320911682528452205480156103b0575b6103a8670de0b6b3a76400009160443561074d565b049051908152f35b50670de0b6b3a7640000610393565b8480fd5b505034610091576060366003190112610091576103de6106b8565b6103e66106d3565b6001600160a01b0391821684526020848152838520929091168452528120604435905580f35b50503461009157366003190112610429576104256106b8565b5080f35b80fd5b5050346100915780600319360112610091578060209261044a6106b8565b6104526106d3565b6001600160a01b03918216835282865283832091168252845220549051908152f35b90508234610429576020806003193601126100915767ffffffffffffffff91833583811161009157366023820112156100915780850135948486116106b45760249160059136848960051b840101116103bf576104d688939795969998610735565b946104e3895196876106fd565b8386526104ef84610735565b868b0198601f1992918301368b373685900360e2190190895b87811061054f578d8d8d8d8d83519485948186019282875251809352850193925b82811061053857505050500390f35b835185528695509381019392810192600101610529565b80829e9b9a9c9d9e1b89818901013584811215610695578f51639d49776160e01b81528881018e9052919089016001600160a01b03806105908e84016106e9565b168d850152604490806105a48385016106e9565b1682860152606480840135908601526084808401359086015260a4906105cb8285016106e9565b169085015260c49182810135604219823603018112156106b05701908d8201359101918882116106ac5781360383136106ac578f928f9190868c601f829660c084968501528060e48501528061010495868601378685828601015201168101030191305af19182156106a0578c9261066d575b508d5183101561065b578d018c0152999c9b9a9899600101610508565b634e487b7160e01b8c52603288528a8cfd5b9091508c81813d8311610699575b61068581836106fd565b810103126106955751903861063e565b8b80fd5b503d61067b565b50508e513d8c823e3d90fd5b8e80fd5b8f80fd5b8280fd5b600435906001600160a01b03821682036106ce57565b600080fd5b602435906001600160a01b03821682036106ce57565b35906001600160a01b03821682036106ce57565b90601f8019910116810190811067ffffffffffffffff82111761071f57604052565b634e487b7160e01b600052604160045260246000fd5b67ffffffffffffffff811161071f5760051b60200190565b8181029291811591840414171561076057565b634e487b7160e01b600052601160045260246000fd5b356001600160a01b03811681036106ce5790565b906000602091828151910182855af1156107e6576000513d6107dd57506001600160a01b0381163b155b6107bb5750565b604051635274afe760e01b81526001600160a01b039091166004820152602490fd5b600114156107b4565b6040513d6000823e3d90fdfea26469706673582212206713aabc8e39ce5b700d93dea07c5ff5765c68b4b07c01b41a7a04b7d768b3de64736f6c63430008160033","abi":[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[{"internalType":"address","name":"token","type":"address"}],"name":"SafeERC20FailedOperation","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"tokenIn","type":"address"},{"indexed":true,"internalType":"address","name":"tokenOut","type":"address"},{"indexed":false,"internalType":"uint256","name":"amountIn","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amountOut","type":"uint256"},{"indexed":true,"internalType":"address","name":"executor","type":"address"}],"name":"SwapExecuted","type":"event"},{"inputs":[],"name":"DEFAULT_RATE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"dealTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"}],"name":"exchangeRates","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"tokenIn","type":"address"},{"internalType":"address","name":"tokenOut","type":"address"},{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"minAmountOut","type":"uint256"},{"internalType":"address","name":"pool","type":"address"},{"internalType":"bytes","name":"swapData","type":"bytes"}],"internalType":"struct ISwapExecutor.SwapParams[]","name":"swaps","type":"tuple[]"}],"name":"executeBatchSwaps","outputs":[{"internalType":"uint256[]","name":"amountsOut","type":"uint256[]"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"tokenIn","type":"address"},{"internalType":"address","name":"tokenOut","type":"address"},{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"minAmountOut","type":"uint256"},{"internalType":"address","name":"pool","type":"address"},{"internalType":"bytes","name":"swapData","type":"bytes"}],"internalType":"struct ISwapExecutor.SwapParams","name":"params","type":"tuple"}],"name":"executeSwap","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"tokenIn","type":"address"},{"internalType":"address","name":"tokenOut","type":"address"},{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"address","name":"pool","type":"address"}],"name":"getAmountOut","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"tokenIn","type":"address"},{"internalType":"address","name":"tokenOut","type":"address"},{"internalType":"uint256","name":"rate","type":"uint256"}],"name":"setExchangeRate","outputs":[],"stateMutability":"nonpayable","type":"function"}]}